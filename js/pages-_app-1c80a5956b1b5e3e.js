(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
	[888], {
		8626: function(e, t, n) {
			"use strict";
			n.d(t, {
				L: function() {
					return he
				}
			});
			var r = n(2212);
			const i = new WeakMap;
			class s extends r.Loader {
				constructor(e) {
					super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
						position: "POSITION",
						normal: "NORMAL",
						color: "COLOR",
						uv: "TEX_COORD"
					}, this.defaultAttributeTypes = {
						position: "Float32Array",
						normal: "Float32Array",
						color: "Float32Array",
						uv: "Float32Array"
					}
				}
				setDecoderPath(e) {
					return this.decoderPath = e, this
				}
				setDecoderConfig(e) {
					return this.decoderConfig = e, this
				}
				setWorkerLimit(e) {
					return this.workerLimit = e, this
				}
				load(e, t, n, i) {
					const s = new r.FileLoader(this.manager);
					s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (e => {
						const n = {
							attributeIDs: this.defaultAttributeIDs,
							attributeTypes: this.defaultAttributeTypes,
							useUniqueIDs: !1
						};
						this.decodeGeometry(e, n).then(t).catch(i)
					}), n, i)
				}
				decodeDracoFile(e, t, n, r) {
					const i = {
						attributeIDs: n || this.defaultAttributeIDs,
						attributeTypes: r || this.defaultAttributeTypes,
						useUniqueIDs: !!n
					};
					this.decodeGeometry(e, i).then(t)
				}
				decodeGeometry(e, t) {
					for (const i in t.attributeTypes) {
						const e = t.attributeTypes[i];
						void 0 !== e.BYTES_PER_ELEMENT && (t.attributeTypes[i] = e.name)
					}
					const n = JSON.stringify(t);
					if (i.has(e)) {
						const t = i.get(e);
						if (t.key === n) return t.promise;
						if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
					}
					let r;
					const s = this.workerNextTaskID++,
						a = e.byteLength,
						o = this._getWorker(s, a).then((n => (r = n, new Promise(((n, i) => {
							r._callbacks[s] = {
								resolve: n,
								reject: i
							}, r.postMessage({
								type: "decode",
								id: s,
								taskConfig: t,
								buffer: e
							}, [e])
						}))))).then((e => this._createGeometry(e.geometry)));
					return o.catch((() => !0)).then((() => {
						r && s && this._releaseTask(r, s)
					})), i.set(e, {
						key: n,
						promise: o
					}), o
				}
				_createGeometry(e) {
					const t = new r.BufferGeometry;
					e.index && t.setIndex(new r.BufferAttribute(e.index.array, 1));
					for (let n = 0; n < e.attributes.length; n++) {
						const i = e.attributes[n],
							s = i.name,
							a = i.array,
							o = i.itemSize;
						t.setAttribute(s, new r.BufferAttribute(a, o))
					}
					return t
				}
				_loadLibrary(e, t) {
					const n = new r.FileLoader(this.manager);
					return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, r) => {
						n.load(e, t, void 0, r)
					}))
				}
				preload() {
					return this._initDecoder(), this
				}
				_initDecoder() {
					if (this.decoderPending) return this.decoderPending;
					const e = "object" !== typeof WebAssembly || "js" === this.decoderConfig.type,
						t = [];
					return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
						const n = t[0];
						e || (this.decoderConfig.wasmBinary = t[1]);
						const r = a.toString(),
							i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
						this.workerSourceURL = URL.createObjectURL(new Blob([i]))
					})), this.decoderPending
				}
				_getWorker(e, t) {
					return this._initDecoder().then((() => {
						if (this.workerPool.length < this.workerLimit) {
							const e = new Worker(this.workerSourceURL);
							e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
								type: "init",
								decoderConfig: this.decoderConfig
							}), e.onmessage = function(t) {
								const n = t.data;
								switch (n.type) {
									case "decode":
										e._callbacks[n.id].resolve(n);
										break;
									case "error":
										e._callbacks[n.id].reject(n);
										break;
									default:
										console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
								}
							}, this.workerPool.push(e)
						} else this.workerPool.sort((function(e, t) {
							return e._taskLoad > t._taskLoad ? -1 : 1
						}));
						const n = this.workerPool[this.workerPool.length - 1];
						return n._taskCosts[e] = t, n._taskLoad += t, n
					}))
				}
				_releaseTask(e, t) {
					e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
				}
				debug() {
					console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
				}
				dispose() {
					for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
					return this.workerPool.length = 0, this
				}
			}

			function a() {
				let e, t;

				function n(e, t, n, r, i, s) {
					const a = s.num_components(),
						o = n.num_points() * a,
						l = o * i.BYTES_PER_ELEMENT,
						c = function(e, t) {
							switch (t) {
								case Float32Array:
									return e.DT_FLOAT32;
								case Int8Array:
									return e.DT_INT8;
								case Int16Array:
									return e.DT_INT16;
								case Int32Array:
									return e.DT_INT32;
								case Uint8Array:
									return e.DT_UINT8;
								case Uint16Array:
									return e.DT_UINT16;
								case Uint32Array:
									return e.DT_UINT32
							}
						}(e, i),
						u = e._malloc(l);
					t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
					const h = new i(e.HEAPF32.buffer, u, o).slice();
					return e._free(u), {
						name: r,
						array: h,
						itemSize: a
					}
				}
				onmessage = function(r) {
					const i = r.data;
					switch (i.type) {
						case "init":
							e = i.decoderConfig, t = new Promise((function(t) {
								e.onModuleLoaded = function(e) {
									t({
										draco: e
									})
								}, DracoDecoderModule(e)
							}));
							break;
						case "decode":
							const r = i.buffer,
								s = i.taskConfig;
							t.then((e => {
								const t = e.draco,
									a = new t.Decoder,
									o = new t.DecoderBuffer;
								o.Init(new Int8Array(r), r.byteLength);
								try {
									const e = function(e, t, r, i) {
											const s = i.attributeIDs,
												a = i.attributeTypes;
											let o, l;
											const c = t.GetEncodedGeometryType(r);
											if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(r, o);
											else {
												if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
												o = new e.PointCloud, l = t.DecodeBufferToPointCloud(r, o)
											}
											if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
											const u = {
												index: null,
												attributes: []
											};
											for (const h in s) {
												const r = self[a[h]];
												let l, c;
												if (i.useUniqueIDs) c = s[h], l = t.GetAttributeByUniqueId(o, c);
												else {
													if (c = t.GetAttributeId(o, e[s[h]]), -1 === c) continue;
													l = t.GetAttribute(o, c)
												}
												u.attributes.push(n(e, t, o, h, r, l))
											}
											c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
												const r = 3 * n.num_faces(),
													i = 4 * r,
													s = e._malloc(i);
												t.GetTrianglesUInt32Array(n, i, s);
												const a = new Uint32Array(e.HEAPF32.buffer, s, r).slice();
												return e._free(s), {
													array: a,
													itemSize: 1
												}
											}(e, t, o));
											return e.destroy(o), u
										}(t, a, o, s),
										r = e.attributes.map((e => e.array.buffer));
									e.index && r.push(e.index.array.buffer), self.postMessage({
										type: "decode",
										id: i.id,
										geometry: e
									}, r)
								} catch (l) {
									console.error(l), self.postMessage({
										type: "error",
										id: i.id,
										error: l.message
									})
								} finally {
									t.destroy(o), t.destroy(a)
								}
							}))
					}
				}
			}
			let o;
			const l = () => {
				if (o) return o;
				const e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
					t = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
				if ("object" !== typeof WebAssembly) return {
					supported: !1
				};
				let n, r = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
				WebAssembly.validate(e) && (r = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB");
				const i = WebAssembly.instantiate(function(e) {
					const n = new Uint8Array(e.length);
					for (let t = 0; t < e.length; ++t) {
						const r = e.charCodeAt(t);
						n[t] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62
					}
					let r = 0;
					for (let i = 0; i < e.length; ++i) n[r++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
					return n.buffer.slice(0, r)
				}(r), {}).then((e => {
					n = e.instance, n.exports.__wasm_call_ctors()
				}));

				function s(e, t, r, i, s, a) {
					const o = n.exports.sbrk,
						l = r + 3 & -4,
						c = o(l * i),
						u = o(s.length),
						h = new Uint8Array(n.exports.memory.buffer);
					h.set(s, u);
					const d = e(c, r, i, u, s.length);
					if (0 === d && a && a(c, l, i), t.set(h.subarray(c, c + r * i)), o(c - o(0)), 0 !== d) throw new Error(`Malformed buffer data: ${d}`)
				}
				const a = {
						0: "",
						1: "meshopt_decodeFilterOct",
						2: "meshopt_decodeFilterQuat",
						3: "meshopt_decodeFilterExp",
						NONE: "",
						OCTAHEDRAL: "meshopt_decodeFilterOct",
						QUATERNION: "meshopt_decodeFilterQuat",
						EXPONENTIAL: "meshopt_decodeFilterExp"
					},
					l = {
						0: "meshopt_decodeVertexBuffer",
						1: "meshopt_decodeIndexBuffer",
						2: "meshopt_decodeIndexSequence",
						ATTRIBUTES: "meshopt_decodeVertexBuffer",
						TRIANGLES: "meshopt_decodeIndexBuffer",
						INDICES: "meshopt_decodeIndexSequence"
					};
				return o = {
					ready: i,
					supported: !0,
					decodeVertexBuffer(e, t, r, i, o) {
						s(n.exports.meshopt_decodeVertexBuffer, e, t, r, i, n.exports[a[o]])
					},
					decodeIndexBuffer(e, t, r, i) {
						s(n.exports.meshopt_decodeIndexBuffer, e, t, r, i)
					},
					decodeIndexSequence(e, t, r, i) {
						s(n.exports.meshopt_decodeIndexSequence, e, t, r, i)
					},
					decodeGltfBuffer(e, t, r, i, o, c) {
						s(n.exports[l[o]], e, t, r, i, n.exports[a[c]])
					}
				}, o
			};
			class c extends r.Loader {
				constructor(e) {
					super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
						return new f(e)
					})), this.register((function(e) {
						return new _(e)
					})), this.register((function(e) {
						return new b(e)
					})), this.register((function(e) {
						return new m(e)
					})), this.register((function(e) {
						return new g(e)
					})), this.register((function(e) {
						return new v(e)
					})), this.register((function(e) {
						return new y(e)
					})), this.register((function(e) {
						return new x(e)
					})), this.register((function(e) {
						return new d(e)
					})), this.register((function(e) {
						return new w(e)
					}))
				}
				load(e, t, n, i) {
					const s = this;
					let a;
					a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r.LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
					const o = function(t) {
							i ? i(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e)
						},
						l = new r.FileLoader(this.manager);
					l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, (function(n) {
						try {
							s.parse(n, a, (function(n) {
								t(n), s.manager.itemEnd(e)
							}), o)
						} catch (r) {
							o(r)
						}
					}), n, o)
				}
				setDRACOLoader(e) {
					return this.dracoLoader = e, this
				}
				setDDSLoader() {
					throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
				}
				setKTX2Loader(e) {
					return this.ktx2Loader = e, this
				}
				setMeshoptDecoder(e) {
					return this.meshoptDecoder = e, this
				}
				register(e) {
					return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
				}
				unregister(e) {
					return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
				}
				parse(e, t, n, i) {
					let s;
					const a = {},
						o = {};
					if ("string" === typeof e) s = e;
					else {
						if (r.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === M) {
							try {
								a[h.KHR_BINARY_GLTF] = new E(e)
							} catch (u) {
								return void(i && i(u))
							}
							s = a[h.KHR_BINARY_GLTF].content
						} else s = r.LoaderUtils.decodeText(new Uint8Array(e))
					}
					const l = JSON.parse(s);
					if (void 0 === l.asset || l.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
					const c = new ie(l, {
						path: t || this.resourcePath || "",
						crossOrigin: this.crossOrigin,
						requestHeader: this.requestHeader,
						manager: this.manager,
						ktx2Loader: this.ktx2Loader,
						meshoptDecoder: this.meshoptDecoder
					});
					c.fileLoader.setRequestHeader(this.requestHeader);
					for (let r = 0; r < this.pluginCallbacks.length; r++) {
						const e = this.pluginCallbacks[r](c);
						o[e.name] = e, a[e.name] = !0
					}
					if (l.extensionsUsed)
						for (let r = 0; r < l.extensionsUsed.length; ++r) {
							const e = l.extensionsUsed[r],
								t = l.extensionsRequired || [];
							switch (e) {
								case h.KHR_MATERIALS_UNLIT:
									a[e] = new p;
									break;
								case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
									a[e] = new R;
									break;
								case h.KHR_DRACO_MESH_COMPRESSION:
									a[e] = new T(l, this.dracoLoader);
									break;
								case h.KHR_TEXTURE_TRANSFORM:
									a[e] = new C;
									break;
								case h.KHR_MESH_QUANTIZATION:
									a[e] = new L;
									break;
								default:
									t.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
							}
						}
					c.setExtensions(a), c.setPlugins(o), c.parse(n, i)
				}
				parseAsync(e, t) {
					const n = this;
					return new Promise((function(r, i) {
						n.parse(e, t, r, i)
					}))
				}
			}

			function u() {
				let e = {};
				return {
					get: function(t) {
						return e[t]
					},
					add: function(t, n) {
						e[t] = n
					},
					remove: function(t) {
						delete e[t]
					},
					removeAll: function() {
						e = {}
					}
				}
			}
			const h = {
				KHR_BINARY_GLTF: "KHR_binary_glTF",
				KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
				KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
				KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
				KHR_MATERIALS_IOR: "KHR_materials_ior",
				KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
				KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
				KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
				KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
				KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
				KHR_MATERIALS_VOLUME: "KHR_materials_volume",
				KHR_TEXTURE_BASISU: "KHR_texture_basisu",
				KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
				KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
				EXT_TEXTURE_WEBP: "EXT_texture_webp",
				EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
			};
			class d {
				constructor(e) {
					this.parser = e, this.name = h.KHR_LIGHTS_PUNCTUAL, this.cache = {
						refs: {},
						uses: {}
					}
				}
				_markDefs() {
					const e = this.parser,
						t = this.parser.json.nodes || [];
					for (let n = 0, r = t.length; n < r; n++) {
						const r = t[n];
						r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
					}
				}
				_loadLight(e) {
					const t = this.parser,
						n = "light:" + e;
					let i = t.cache.get(n);
					if (i) return i;
					const s = t.json,
						a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
					let o;
					const l = new r.Color(16777215);
					void 0 !== a.color && l.fromArray(a.color);
					const c = void 0 !== a.range ? a.range : 0;
					switch (a.type) {
						case "directional":
							o = new r.DirectionalLight(l), o.target.position.set(0, 0, -1), o.add(o.target);
							break;
						case "point":
							o = new r.PointLight(l), o.distance = c;
							break;
						case "spot":
							o = new r.SpotLight(l), o.distance = c, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
							break;
						default:
							throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
					}
					return o.position.set(0, 0, 0), o.decay = 2, void 0 !== a.intensity && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), i = Promise.resolve(o), t.cache.add(n, i), i
				}
				createNodeAttachment(e) {
					const t = this,
						n = this.parser,
						r = n.json.nodes[e],
						i = (r.extensions && r.extensions[this.name] || {}).light;
					return void 0 === i ? null : this._loadLight(i).then((function(e) {
						return n._getNodeRef(t.cache, i, e)
					}))
				}
			}
			class p {
				constructor() {
					this.name = h.KHR_MATERIALS_UNLIT
				}
				getMaterialType() {
					return r.MeshBasicMaterial
				}
				extendParams(e, t, n) {
					const i = [];
					e.color = new r.Color(1, 1, 1), e.opacity = 1;
					const s = t.pbrMetallicRoughness;
					if (s) {
						if (Array.isArray(s.baseColorFactor)) {
							const t = s.baseColorFactor;
							e.color.fromArray(t), e.opacity = t[3]
						}
						void 0 !== s.baseColorTexture && i.push(n.assignTexture(e, "map", s.baseColorTexture))
					}
					return Promise.all(i)
				}
			}
			class f {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_CLEARCOAT
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser,
						i = n.json.materials[e];
					if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
					const s = [],
						a = i.extensions[this.name];
					if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && s.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (s.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
						const e = a.clearcoatNormalTexture.scale;
						t.clearcoatNormalScale = new r.Vector2(e, e)
					}
					return Promise.all(s)
				}
			}
			class m {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_SHEEN
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser,
						i = n.json.materials[e];
					if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
					const s = [];
					t.sheenColor = new r.Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
					const a = i.extensions[this.name];
					return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture)), void 0 !== a.sheenRoughnessTexture && s.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s)
				}
			}
			class g {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_TRANSMISSION
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser,
						r = n.json.materials[e];
					if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
					const i = [],
						s = r.extensions[this.name];
					return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i)
				}
			}
			class v {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_VOLUME
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser,
						i = n.json.materials[e];
					if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
					const s = [],
						a = i.extensions[this.name];
					t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0;
					const o = a.attenuationColor || [1, 1, 1];
					return t.attenuationColor = new r.Color(o[0], o[1], o[2]), Promise.all(s)
				}
			}
			class y {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_IOR
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser.json.materials[e];
					if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
					const r = n.extensions[this.name];
					return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
				}
			}
			class x {
				constructor(e) {
					this.parser = e, this.name = h.KHR_MATERIALS_SPECULAR
				}
				getMaterialType(e) {
					const t = this.parser.json.materials[e];
					return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
				}
				extendMaterialParams(e, t) {
					const n = this.parser,
						i = n.json.materials[e];
					if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
					const s = [],
						a = i.extensions[this.name];
					t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
					const o = a.specularColorFactor || [1, 1, 1];
					return t.specularColor = new r.Color(o[0], o[1], o[2]), void 0 !== a.specularColorTexture && s.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture).then((function(e) {
						e.encoding = r.sRGBEncoding
					}))), Promise.all(s)
				}
			}
			class _ {
				constructor(e) {
					this.parser = e, this.name = h.KHR_TEXTURE_BASISU
				}
				loadTexture(e) {
					const t = this.parser,
						n = t.json,
						r = n.textures[e];
					if (!r.extensions || !r.extensions[this.name]) return null;
					const i = r.extensions[this.name],
						s = n.images[i.source],
						a = t.options.ktx2Loader;
					if (!a) {
						if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
						return null
					}
					return t.loadTextureImage(e, s, a)
				}
			}
			class b {
				constructor(e) {
					this.parser = e, this.name = h.EXT_TEXTURE_WEBP, this.isSupported = null
				}
				loadTexture(e) {
					const t = this.name,
						n = this.parser,
						r = n.json,
						i = r.textures[e];
					if (!i.extensions || !i.extensions[t]) return null;
					const s = i.extensions[t],
						a = r.images[s.source];
					let o = n.textureLoader;
					if (a.uri) {
						const e = n.options.manager.getHandler(a.uri);
						null !== e && (o = e)
					}
					return this.detectSupport().then((function(i) {
						if (i) return n.loadTextureImage(e, a, o);
						if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
						return n.loadTexture(e)
					}))
				}
				detectSupport() {
					return this.isSupported || (this.isSupported = new Promise((function(e) {
						const t = new Image;
						t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
							e(1 === t.height)
						}
					}))), this.isSupported
				}
			}
			class w {
				constructor(e) {
					this.name = h.EXT_MESHOPT_COMPRESSION, this.parser = e
				}
				loadBufferView(e) {
					const t = this.parser.json,
						n = t.bufferViews[e];
					if (n.extensions && n.extensions[this.name]) {
						const e = n.extensions[this.name],
							r = this.parser.getDependency("buffer", e.buffer),
							i = this.parser.options.meshoptDecoder;
						if (!i || !i.supported) {
							if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
							return null
						}
						return Promise.all([r, i.ready]).then((function(t) {
							const n = e.byteOffset || 0,
								r = e.byteLength || 0,
								s = e.count,
								a = e.byteStride,
								o = new ArrayBuffer(s * a),
								l = new Uint8Array(t[0], n, r);
							return i.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
						}))
					}
					return null
				}
			}
			const M = "glTF",
				A = 1313821514,
				S = 5130562;
			class E {
				constructor(e) {
					this.name = h.KHR_BINARY_GLTF, this.content = null, this.body = null;
					const t = new DataView(e, 0, 12);
					if (this.header = {
							magic: r.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
							version: t.getUint32(4, !0),
							length: t.getUint32(8, !0)
						}, this.header.magic !== M) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
					if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
					const n = this.header.length - 12,
						i = new DataView(e, 12);
					let s = 0;
					for (; s < n;) {
						const t = i.getUint32(s, !0);
						s += 4;
						const n = i.getUint32(s, !0);
						if (s += 4, n === A) {
							const n = new Uint8Array(e, 12 + s, t);
							this.content = r.LoaderUtils.decodeText(n)
						} else if (n === S) {
							const n = 12 + s;
							this.body = e.slice(n, n + t)
						}
						s += t
					}
					if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
				}
			}
			class T {
				constructor(e, t) {
					if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
					this.name = h.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
				}
				decodePrimitive(e, t) {
					const n = this.json,
						r = this.dracoLoader,
						i = e.extensions[this.name].bufferView,
						s = e.extensions[this.name].attributes,
						a = {},
						o = {},
						l = {};
					for (const c in s) {
						const e = J[c] || c.toLowerCase();
						a[e] = s[c]
					}
					for (const c in e.attributes) {
						const t = J[c] || c.toLowerCase();
						if (void 0 !== s[c]) {
							const r = n.accessors[e.attributes[c]],
								i = z[r.componentType];
							l[t] = i, o[t] = !0 === r.normalized
						}
					}
					return t.getDependency("bufferView", i).then((function(e) {
						return new Promise((function(t) {
							r.decodeDracoFile(e, (function(e) {
								for (const t in e.attributes) {
									const n = e.attributes[t],
										r = o[t];
									void 0 !== r && (n.normalized = r)
								}
								t(e)
							}), a, l)
						}))
					}))
				}
			}
			class C {
				constructor() {
					this.name = h.KHR_TEXTURE_TRANSFORM
				}
				extendTexture(e, t) {
					return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
				}
			}
			class B extends r.MeshStandardMaterial {
				constructor(e) {
					super(), this.isGLTFSpecularGlossinessMaterial = !0;
					const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
						n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
						i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
						s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
						a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
						o = {
							specular: {
								value: (new r.Color).setHex(16777215)
							},
							glossiness: {
								value: 1
							},
							specularMap: {
								value: null
							},
							glossinessMap: {
								value: null
							}
						};
					this._extraUniforms = o, this.onBeforeCompile = function(e) {
						for (const t in o) e.uniforms[t] = o[t];
						e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", a)
					}, Object.defineProperties(this, {
						specular: {
							get: function() {
								return o.specular.value
							},
							set: function(e) {
								o.specular.value = e
							}
						},
						specularMap: {
							get: function() {
								return o.specularMap.value
							},
							set: function(e) {
								o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
							}
						},
						glossiness: {
							get: function() {
								return o.glossiness.value
							},
							set: function(e) {
								o.glossiness.value = e
							}
						},
						glossinessMap: {
							get: function() {
								return o.glossinessMap.value
							},
							set: function(e) {
								o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
							}
						}
					}), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
				}
			}
			class R {
				constructor() {
					this.name = h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
				}
				getMaterialType() {
					return B
				}
				extendParams(e, t, n) {
					const i = t.extensions[this.name];
					e.color = new r.Color(1, 1, 1), e.opacity = 1;
					const s = [];
					if (Array.isArray(i.diffuseFactor)) {
						const t = i.diffuseFactor;
						e.color.fromArray(t), e.opacity = t[3]
					}
					if (void 0 !== i.diffuseTexture && s.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new r.Color(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new r.Color(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
						const t = i.specularGlossinessTexture;
						s.push(n.assignTexture(e, "glossinessMap", t)), s.push(n.assignTexture(e, "specularMap", t))
					}
					return Promise.all(s)
				}
				createMaterial(e) {
					const t = new B(e);
					return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = r.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
				}
			}
			class L {
				constructor() {
					this.name = h.KHR_MESH_QUANTIZATION
				}
			}
			class I extends r.Interpolant {
				constructor(e, t, n, r) {
					super(e, t, n, r)
				}
				copySampleValue_(e) {
					const t = this.resultBuffer,
						n = this.sampleValues,
						r = this.valueSize,
						i = e * r * 3 + r;
					for (let s = 0; s !== r; s++) t[s] = n[i + s];
					return t
				}
			}
			I.prototype.beforeStart_ = I.prototype.copySampleValue_, I.prototype.afterEnd_ = I.prototype.copySampleValue_, I.prototype.interpolate_ = function(e, t, n, r) {
				const i = this.resultBuffer,
					s = this.sampleValues,
					a = this.valueSize,
					o = 2 * a,
					l = 3 * a,
					c = r - t,
					u = (n - t) / c,
					h = u * u,
					d = h * u,
					p = e * l,
					f = p - l,
					m = -2 * d + 3 * h,
					g = d - h,
					v = 1 - m,
					y = g - h + u;
				for (let x = 0; x !== a; x++) {
					const e = s[f + x + a],
						t = s[f + x + o] * c,
						n = s[p + x + a],
						r = s[p + x] * c;
					i[x] = v * e + y * t + m * n + g * r
				}
				return i
			};
			const P = new r.Quaternion;
			class D extends I {
				interpolate_(e, t, n, r) {
					const i = super.interpolate_(e, t, n, r);
					return P.fromArray(i).normalize().toArray(i), i
				}
			}
			const F = 0,
				O = 1,
				N = 2,
				H = 3,
				k = 4,
				G = 5,
				U = 6,
				z = {
					5120: Int8Array,
					5121: Uint8Array,
					5122: Int16Array,
					5123: Uint16Array,
					5125: Uint32Array,
					5126: Float32Array
				},
				V = {
					9728: r.NearestFilter,
					9729: r.LinearFilter,
					9984: r.NearestMipmapNearestFilter,
					9985: r.LinearMipmapNearestFilter,
					9986: r.NearestMipmapLinearFilter,
					9987: r.LinearMipmapLinearFilter
				},
				W = {
					33071: r.ClampToEdgeWrapping,
					33648: r.MirroredRepeatWrapping,
					10497: r.RepeatWrapping
				},
				j = {
					SCALAR: 1,
					VEC2: 2,
					VEC3: 3,
					VEC4: 4,
					MAT2: 4,
					MAT3: 9,
					MAT4: 16
				},
				J = {
					POSITION: "position",
					NORMAL: "normal",
					TANGENT: "tangent",
					TEXCOORD_0: "uv",
					TEXCOORD_1: "uv2",
					COLOR_0: "color",
					WEIGHTS_0: "skinWeight",
					JOINTS_0: "skinIndex"
				},
				X = {
					scale: "scale",
					translation: "position",
					rotation: "quaternion",
					weights: "morphTargetInfluences"
				},
				q = {
					CUBICSPLINE: void 0,
					LINEAR: r.InterpolateLinear,
					STEP: r.InterpolateDiscrete
				},
				K = "OPAQUE",
				Y = "MASK",
				Q = "BLEND";

			function Z(e, t, n) {
				for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
			}

			function $(e, t) {
				void 0 !== t.extras && ("object" === typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
			}

			function ee(e, t) {
				if (e.updateMorphTargets(), void 0 !== t.weights)
					for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
				if (t.extras && Array.isArray(t.extras.targetNames)) {
					const n = t.extras.targetNames;
					if (e.morphTargetInfluences.length === n.length) {
						e.morphTargetDictionary = {};
						for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t
					} else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
				}
			}

			function te(e) {
				const t = e.extensions && e.extensions[h.KHR_DRACO_MESH_COMPRESSION];
				let n;
				return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + ne(t.attributes) : e.indices + ":" + ne(e.attributes) + ":" + e.mode, n
			}

			function ne(e) {
				let t = "";
				const n = Object.keys(e).sort();
				for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
				return t
			}

			function re(e) {
				switch (e) {
					case Int8Array:
						return 1 / 127;
					case Uint8Array:
						return 1 / 255;
					case Int16Array:
						return 1 / 32767;
					case Uint16Array:
						return 1 / 65535;
					default:
						throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
				}
			}
			class ie {
				constructor(e = {}, t = {}) {
					this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new u, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
						refs: {},
						uses: {}
					}, this.cameraCache = {
						refs: {},
						uses: {}
					}, this.lightCache = {
						refs: {},
						uses: {}
					}, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" !== typeof createImageBitmap && !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new r.ImageBitmapLoader(this.options.manager) : this.textureLoader = new r.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new r.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
				}
				setExtensions(e) {
					this.extensions = e
				}
				setPlugins(e) {
					this.plugins = e
				}
				parse(e, t) {
					const n = this,
						r = this.json,
						i = this.extensions;
					this.cache.removeAll(), this._invokeAll((function(e) {
						return e._markDefs && e._markDefs()
					})), Promise.all(this._invokeAll((function(e) {
						return e.beforeRoot && e.beforeRoot()
					}))).then((function() {
						return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
					})).then((function(t) {
						const s = {
							scene: t[0][r.scene || 0],
							scenes: t[0],
							animations: t[1],
							cameras: t[2],
							asset: r.asset,
							parser: n,
							userData: {}
						};
						Z(i, s, r), $(s, r), Promise.all(n._invokeAll((function(e) {
							return e.afterRoot && e.afterRoot(s)
						}))).then((function() {
							e(s)
						}))
					})).catch(t)
				}
				_markDefs() {
					const e = this.json.nodes || [],
						t = this.json.skins || [],
						n = this.json.meshes || [];
					for (let r = 0, i = t.length; r < i; r++) {
						const n = t[r].joints;
						for (let t = 0, r = n.length; t < r; t++) e[n[t]].isBone = !0
					}
					for (let r = 0, i = e.length; r < i; r++) {
						const t = e[r];
						void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh), void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)), void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
					}
				}
				_addNodeRef(e, t) {
					void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
				}
				_getNodeRef(e, t, n) {
					if (e.refs[t] <= 1) return n;
					const r = n.clone(),
						i = (e, t) => {
							const n = this.associations.get(e);
							null != n && this.associations.set(t, n);
							for (const [r, s] of e.children.entries()) i(s, t.children[r])
						};
					return i(n, r), r.name += "_instance_" + e.uses[t]++, r
				}
				_invokeOne(e) {
					const t = Object.values(this.plugins);
					t.push(this);
					for (let n = 0; n < t.length; n++) {
						const r = e(t[n]);
						if (r) return r
					}
					return null
				}
				_invokeAll(e) {
					const t = Object.values(this.plugins);
					t.unshift(this);
					const n = [];
					for (let r = 0; r < t.length; r++) {
						const i = e(t[r]);
						i && n.push(i)
					}
					return n
				}
				getDependency(e, t) {
					const n = e + ":" + t;
					let r = this.cache.get(n);
					if (!r) {
						switch (e) {
							case "scene":
								r = this.loadScene(t);
								break;
							case "node":
								r = this.loadNode(t);
								break;
							case "mesh":
								r = this._invokeOne((function(e) {
									return e.loadMesh && e.loadMesh(t)
								}));
								break;
							case "accessor":
								r = this.loadAccessor(t);
								break;
							case "bufferView":
								r = this._invokeOne((function(e) {
									return e.loadBufferView && e.loadBufferView(t)
								}));
								break;
							case "buffer":
								r = this.loadBuffer(t);
								break;
							case "material":
								r = this._invokeOne((function(e) {
									return e.loadMaterial && e.loadMaterial(t)
								}));
								break;
							case "texture":
								r = this._invokeOne((function(e) {
									return e.loadTexture && e.loadTexture(t)
								}));
								break;
							case "skin":
								r = this.loadSkin(t);
								break;
							case "animation":
								r = this.loadAnimation(t);
								break;
							case "camera":
								r = this.loadCamera(t);
								break;
							default:
								throw new Error("Unknown type: " + e)
						}
						this.cache.add(n, r)
					}
					return r
				}
				getDependencies(e) {
					let t = this.cache.get(e);
					if (!t) {
						const n = this,
							r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
						t = Promise.all(r.map((function(t, r) {
							return n.getDependency(e, r)
						}))), this.cache.add(e, t)
					}
					return t
				}
				loadBuffer(e) {
					const t = this.json.buffers[e],
						n = this.fileLoader;
					if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
					if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);
					const i = this.options;
					return new Promise((function(e, s) {
						n.load(r.LoaderUtils.resolveURL(t.uri, i.path), e, void 0, (function() {
							s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
						}))
					}))
				}
				loadBufferView(e) {
					const t = this.json.bufferViews[e];
					return this.getDependency("buffer", t.buffer).then((function(e) {
						const n = t.byteLength || 0,
							r = t.byteOffset || 0;
						return e.slice(r, r + n)
					}))
				}
				loadAccessor(e) {
					const t = this,
						n = this.json,
						i = this.json.accessors[e];
					if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
					const s = [];
					return void 0 !== i.bufferView ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), void 0 !== i.sparse && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then((function(e) {
						const s = e[0],
							a = j[i.type],
							o = z[i.componentType],
							l = o.BYTES_PER_ELEMENT,
							c = l * a,
							u = i.byteOffset || 0,
							h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
							d = !0 === i.normalized;
						let p, f;
						if (h && h !== c) {
							const e = Math.floor(u / h),
								n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
							let c = t.cache.get(n);
							c || (p = new o(s, e * h, i.count * h / l), c = new r.InterleavedBuffer(p, h / l), t.cache.add(n, c)), f = new r.InterleavedBufferAttribute(c, a, u % h / l, d)
						} else p = null === s ? new o(i.count * a) : new o(s, u, i.count * a), f = new r.BufferAttribute(p, a, d);
						if (void 0 !== i.sparse) {
							const t = j.SCALAR,
								n = z[i.sparse.indices.componentType],
								l = i.sparse.indices.byteOffset || 0,
								c = i.sparse.values.byteOffset || 0,
								u = new n(e[1], l, i.sparse.count * t),
								h = new o(e[2], c, i.sparse.count * a);
							null !== s && (f = new r.BufferAttribute(f.array.slice(), f.itemSize, f.normalized));
							for (let e = 0, r = u.length; e < r; e++) {
								const t = u[e];
								if (f.setX(t, h[e * a]), a >= 2 && f.setY(t, h[e * a + 1]), a >= 3 && f.setZ(t, h[e * a + 2]), a >= 4 && f.setW(t, h[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
							}
						}
						return f
					}))
				}
				loadTexture(e) {
					const t = this.json,
						n = this.options,
						r = t.textures[e],
						i = t.images[r.source];
					let s = this.textureLoader;
					if (i.uri) {
						const e = n.manager.getHandler(i.uri);
						null !== e && (s = e)
					}
					return this.loadTextureImage(e, i, s)
				}
				loadTextureImage(e, t, n) {
					const i = this,
						s = this.json,
						a = this.options,
						o = s.textures[e],
						l = (t.uri || t.bufferView) + ":" + o.sampler;
					if (this.textureCache[l]) return this.textureCache[l];
					const c = self.URL || self.webkitURL;
					let u = t.uri || "",
						h = !1;
					if (void 0 !== t.bufferView) u = i.getDependency("bufferView", t.bufferView).then((function(e) {
						h = !0;
						const n = new Blob([e], {
							type: t.mimeType
						});
						return u = c.createObjectURL(n), u
					}));
					else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
					const d = Promise.resolve(u).then((function(e) {
						return new Promise((function(t, i) {
							let s = t;
							!0 === n.isImageBitmapLoader && (s = function(e) {
								const n = new r.Texture(e);
								n.needsUpdate = !0, t(n)
							}), n.load(r.LoaderUtils.resolveURL(e, a.path), s, void 0, i)
						}))
					})).then((function(t) {
						!0 === h && c.revokeObjectURL(u), t.flipY = !1, o.name && (t.name = o.name);
						const n = (s.samplers || {})[o.sampler] || {};
						return t.magFilter = V[n.magFilter] || r.LinearFilter, t.minFilter = V[n.minFilter] || r.LinearMipmapLinearFilter, t.wrapS = W[n.wrapS] || r.RepeatWrapping, t.wrapT = W[n.wrapT] || r.RepeatWrapping, i.associations.set(t, {
							textures: e
						}), t
					})).catch((function() {
						return console.error("THREE.GLTFLoader: Couldn't load texture", u), null
					}));
					return this.textureCache[l] = d, d
				}
				assignTexture(e, t, n) {
					const r = this;
					return this.getDependency("texture", n.index).then((function(i) {
						if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), r.extensions[h.KHR_TEXTURE_TRANSFORM]) {
							const e = void 0 !== n.extensions ? n.extensions[h.KHR_TEXTURE_TRANSFORM] : void 0;
							if (e) {
								const t = r.associations.get(i);
								i = r.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(i, e), r.associations.set(i, t)
							}
						}
						return e[t] = i, i
					}))
				}
				assignFinalMaterial(e) {
					const t = e.geometry;
					let n = e.material;
					const i = void 0 === t.attributes.tangent,
						s = void 0 !== t.attributes.color,
						a = void 0 === t.attributes.normal;
					if (e.isPoints) {
						const e = "PointsMaterial:" + n.uuid;
						let t = this.cache.get(e);
						t || (t = new r.PointsMaterial, r.Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
					} else if (e.isLine) {
						const e = "LineBasicMaterial:" + n.uuid;
						let t = this.cache.get(e);
						t || (t = new r.LineBasicMaterial, r.Material.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
					}
					if (i || s || a) {
						let e = "ClonedMaterial:" + n.uuid + ":";
						n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), a && (e += "flat-shading:");
						let t = this.cache.get(e);
						t || (t = n.clone(), s && (t.vertexColors = !0), a && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
					}
					n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
				}
				getMaterialType() {
					return r.MeshStandardMaterial
				}
				loadMaterial(e) {
					const t = this,
						n = this.json,
						i = this.extensions,
						s = n.materials[e];
					let a;
					const o = {},
						l = s.extensions || {},
						c = [];
					if (l[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
						const e = i[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
						a = e.getMaterialType(), c.push(e.extendParams(o, s, t))
					} else if (l[h.KHR_MATERIALS_UNLIT]) {
						const e = i[h.KHR_MATERIALS_UNLIT];
						a = e.getMaterialType(), c.push(e.extendParams(o, s, t))
					} else {
						const n = s.pbrMetallicRoughness || {};
						if (o.color = new r.Color(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
							const e = n.baseColorFactor;
							o.color.fromArray(e), o.opacity = e[3]
						}
						void 0 !== n.baseColorTexture && c.push(t.assignTexture(o, "map", n.baseColorTexture)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function(t) {
							return t.getMaterialType && t.getMaterialType(e)
						})), c.push(Promise.all(this._invokeAll((function(t) {
							return t.extendMaterialParams && t.extendMaterialParams(e, o)
						}))))
					}!0 === s.doubleSided && (o.side = r.DoubleSide);
					const u = s.alphaMode || K;
					if (u === Q ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, u === Y && (o.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && a !== r.MeshBasicMaterial && (c.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new r.Vector2(1, 1), void 0 !== s.normalTexture.scale)) {
						const e = s.normalTexture.scale;
						o.normalScale.set(e, e)
					}
					return void 0 !== s.occlusionTexture && a !== r.MeshBasicMaterial && (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (o.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && a !== r.MeshBasicMaterial && (o.emissive = (new r.Color).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && a !== r.MeshBasicMaterial && c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture)), Promise.all(c).then((function() {
						let n;
						return n = a === B ? i[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new a(o), s.name && (n.name = s.name), n.map && (n.map.encoding = r.sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = r.sRGBEncoding), $(n, s), t.associations.set(n, {
							materials: e
						}), s.extensions && Z(i, n, s), n
					}))
				}
				createUniqueName(e) {
					const t = r.PropertyBinding.sanitizeNodeName(e || "");
					let n = t;
					for (let r = 1; this.nodeNamesUsed[n]; ++r) n = t + "_" + r;
					return this.nodeNamesUsed[n] = !0, n
				}
				loadGeometries(e) {
					const t = this,
						n = this.extensions,
						i = this.primitiveCache;

					function s(e) {
						return n[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
							return ae(n, e, t)
						}))
					}
					const a = [];
					for (let o = 0, l = e.length; o < l; o++) {
						const n = e[o],
							l = te(n),
							c = i[l];
						if (c) a.push(c.promise);
						else {
							let e;
							e = n.extensions && n.extensions[h.KHR_DRACO_MESH_COMPRESSION] ? s(n) : ae(new r.BufferGeometry, n, t), i[l] = {
								primitive: n,
								promise: e
							}, a.push(e)
						}
					}
					return Promise.all(a)
				}
				loadMesh(e) {
					const t = this,
						n = this.json,
						i = this.extensions,
						s = n.meshes[e],
						a = s.primitives,
						o = [];
					for (let c = 0, u = a.length; c < u; c++) {
						const e = void 0 === a[c].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new r.MeshStandardMaterial({
							color: 16777215,
							emissive: 0,
							metalness: 1,
							roughness: 1,
							transparent: !1,
							depthTest: !0,
							side: r.FrontSide
						})), l.DefaultMaterial) : this.getDependency("material", a[c].material);
						o.push(e)
					}
					var l;
					return o.push(t.loadGeometries(a)), Promise.all(o).then((function(n) {
						const o = n.slice(0, n.length - 1),
							l = n[n.length - 1],
							c = [];
						for (let h = 0, d = l.length; h < d; h++) {
							const n = l[h],
								u = a[h];
							let d;
							const p = o[h];
							if (u.mode === k || u.mode === G || u.mode === U || void 0 === u.mode) d = !0 === s.isSkinnedMesh ? new r.SkinnedMesh(n, p) : new r.Mesh(n, p), !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), u.mode === G ? d.geometry = oe(d.geometry, r.TriangleStripDrawMode) : u.mode === U && (d.geometry = oe(d.geometry, r.TriangleFanDrawMode));
							else if (u.mode === O) d = new r.LineSegments(n, p);
							else if (u.mode === H) d = new r.Line(n, p);
							else if (u.mode === N) d = new r.LineLoop(n, p);
							else {
								if (u.mode !== F) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
								d = new r.Points(n, p)
							}
							Object.keys(d.geometry.morphAttributes).length > 0 && ee(d, s), d.name = t.createUniqueName(s.name || "mesh_" + e), $(d, s), u.extensions && Z(i, d, u), t.assignFinalMaterial(d), c.push(d)
						}
						for (let r = 0, i = c.length; r < i; r++) t.associations.set(c[r], {
							meshes: e,
							primitives: r
						});
						if (1 === c.length) return c[0];
						const u = new r.Group;
						t.associations.set(u, {
							meshes: e
						});
						for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);
						return u
					}))
				}
				loadCamera(e) {
					let t;
					const n = this.json.cameras[e],
						i = n[n.type];
					if (i) return "perspective" === n.type ? t = new r.PerspectiveCamera(r.MathUtils.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new r.OrthographicCamera(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), $(t, n), Promise.resolve(t);
					console.warn("THREE.GLTFLoader: Missing camera parameters.")
				}
				loadSkin(e) {
					const t = this.json.skins[e],
						n = {
							joints: t.joints
						};
					return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
						return n.inverseBindMatrices = e, n
					}))
				}
				loadAnimation(e) {
					const t = this.json.animations[e],
						n = [],
						i = [],
						s = [],
						a = [],
						o = [];
					for (let r = 0, l = t.channels.length; r < l; r++) {
						const e = t.channels[r],
							l = t.samplers[e.sampler],
							c = e.target,
							u = void 0 !== c.node ? c.node : c.id,
							h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
							d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
						n.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), s.push(this.getDependency("accessor", d)), a.push(l), o.push(c)
					}
					return Promise.all([Promise.all(n), Promise.all(i), Promise.all(s), Promise.all(a), Promise.all(o)]).then((function(n) {
						const i = n[0],
							s = n[1],
							a = n[2],
							o = n[3],
							l = n[4],
							c = [];
						for (let e = 0, t = i.length; e < t; e++) {
							const t = i[e],
								n = s[e],
								u = a[e],
								h = o[e],
								d = l[e];
							if (void 0 === t) continue;
							let p;
							switch (t.updateMatrix(), t.matrixAutoUpdate = !0, X[d.path]) {
								case X.weights:
									p = r.NumberKeyframeTrack;
									break;
								case X.rotation:
									p = r.QuaternionKeyframeTrack;
									break;
								case X.position:
								case X.scale:
								default:
									p = r.VectorKeyframeTrack
							}
							const f = t.name ? t.name : t.uuid,
								m = void 0 !== h.interpolation ? q[h.interpolation] : r.InterpolateLinear,
								g = [];
							X[d.path] === X.weights ? t.traverse((function(e) {
								e.morphTargetInfluences && g.push(e.name ? e.name : e.uuid)
							})) : g.push(f);
							let v = u.array;
							if (u.normalized) {
								const e = re(v.constructor),
									t = new Float32Array(v.length);
								for (let n = 0, r = v.length; n < r; n++) t[n] = v[n] * e;
								v = t
							}
							for (let e = 0, i = g.length; e < i; e++) {
								const t = new p(g[e] + "." + X[d.path], n.array, v, m);
								"CUBICSPLINE" === h.interpolation && (t.createInterpolant = function(e) {
									return new(this instanceof r.QuaternionKeyframeTrack ? D : I)(this.times, this.values, this.getValueSize() / 3, e)
								}, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t)
							}
						}
						const u = t.name ? t.name : "animation_" + e;
						return new r.AnimationClip(u, void 0, c)
					}))
				}
				createNodeMesh(e) {
					const t = this.json,
						n = this,
						r = t.nodes[e];
					return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
						const t = n._getNodeRef(n.meshCache, r.mesh, e);
						return void 0 !== r.weights && t.traverse((function(e) {
							if (e.isMesh)
								for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
						})), t
					}))
				}
				loadNode(e) {
					const t = this.json,
						n = this.extensions,
						i = this,
						s = t.nodes[e],
						a = s.name ? i.createUniqueName(s.name) : "";
					return function() {
						const t = [],
							n = i._invokeOne((function(t) {
								return t.createNodeMesh && t.createNodeMesh(e)
							}));
						return n && t.push(n), void 0 !== s.camera && t.push(i.getDependency("camera", s.camera).then((function(e) {
							return i._getNodeRef(i.cameraCache, s.camera, e)
						}))), i._invokeAll((function(t) {
							return t.createNodeAttachment && t.createNodeAttachment(e)
						})).forEach((function(e) {
							t.push(e)
						})), Promise.all(t)
					}().then((function(t) {
						let o;
						if (o = !0 === s.isBone ? new r.Bone : t.length > 1 ? new r.Group : 1 === t.length ? t[0] : new r.Object3D, o !== t[0])
							for (let e = 0, n = t.length; e < n; e++) o.add(t[e]);
						if (s.name && (o.userData.name = s.name, o.name = a), $(o, s), s.extensions && Z(n, o, s), void 0 !== s.matrix) {
							const e = new r.Matrix4;
							e.fromArray(s.matrix), o.applyMatrix4(e)
						} else void 0 !== s.translation && o.position.fromArray(s.translation), void 0 !== s.rotation && o.quaternion.fromArray(s.rotation), void 0 !== s.scale && o.scale.fromArray(s.scale);
						return i.associations.has(o) || i.associations.set(o, {}), i.associations.get(o).nodes = e, o
					}))
				}
				loadScene(e) {
					const t = this.json,
						n = this.extensions,
						i = this.json.scenes[e],
						s = this,
						a = new r.Group;
					i.name && (a.name = s.createUniqueName(i.name)), $(a, i), i.extensions && Z(n, a, i);
					const o = i.nodes || [],
						l = [];
					for (let r = 0, c = o.length; r < c; r++) l.push(se(o[r], a, t, s));
					return Promise.all(l).then((function() {
						return s.associations = (e => {
							const t = new Map;
							for (const [n, i] of s.associations)(n instanceof r.Material || n instanceof r.Texture) && t.set(n, i);
							return e.traverse((e => {
								const n = s.associations.get(e);
								null != n && t.set(e, n)
							})), t
						})(a), a
					}))
				}
			}

			function se(e, t, n, i) {
				const s = n.nodes[e];
				return i.getDependency("node", e).then((function(e) {
					if (void 0 === s.skin) return e;
					let t;
					return i.getDependency("skin", s.skin).then((function(e) {
						t = e;
						const n = [];
						for (let r = 0, s = t.joints.length; r < s; r++) n.push(i.getDependency("node", t.joints[r]));
						return Promise.all(n)
					})).then((function(n) {
						return e.traverse((function(e) {
							if (!e.isMesh) return;
							const i = [],
								s = [];
							for (let a = 0, o = n.length; a < o; a++) {
								const e = n[a];
								if (e) {
									i.push(e);
									const n = new r.Matrix4;
									void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * a), s.push(n)
								} else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
							}
							e.bind(new r.Skeleton(i, s), e.matrixWorld)
						})), e
					}))
				})).then((function(e) {
					t.add(e);
					const r = [];
					if (s.children) {
						const t = s.children;
						for (let s = 0, a = t.length; s < a; s++) {
							const a = t[s];
							r.push(se(a, e, n, i))
						}
					}
					return Promise.all(r)
				}))
			}

			function ae(e, t, n) {
				const i = t.attributes,
					s = [];

				function a(t, r) {
					return n.getDependency("accessor", t).then((function(t) {
						e.setAttribute(r, t)
					}))
				}
				for (const r in i) {
					const t = J[r] || r.toLowerCase();
					t in e.attributes || s.push(a(i[r], t))
				}
				if (void 0 !== t.indices && !e.index) {
					const r = n.getDependency("accessor", t.indices).then((function(t) {
						e.setIndex(t)
					}));
					s.push(r)
				}
				return $(e, t),
					function(e, t, n) {
						const i = t.attributes,
							s = new r.Box3;
						if (void 0 === i.POSITION) return; {
							const e = n.json.accessors[i.POSITION],
								t = e.min,
								a = e.max;
							if (void 0 === t || void 0 === a) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
							if (s.set(new r.Vector3(t[0], t[1], t[2]), new r.Vector3(a[0], a[1], a[2])), e.normalized) {
								const t = re(z[e.componentType]);
								s.min.multiplyScalar(t), s.max.multiplyScalar(t)
							}
						}
						const a = t.targets;
						if (void 0 !== a) {
							const e = new r.Vector3,
								t = new r.Vector3;
							for (let r = 0, i = a.length; r < i; r++) {
								const i = a[r];
								if (void 0 !== i.POSITION) {
									const r = n.json.accessors[i.POSITION],
										s = r.min,
										a = r.max;
									if (void 0 !== s && void 0 !== a) {
										if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), r.normalized) {
											const e = re(z[r.componentType]);
											t.multiplyScalar(e)
										}
										e.max(t)
									} else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
								}
							}
							s.expandByVector(e)
						}
						e.boundingBox = s;
						const o = new r.Sphere;
						s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = o
					}(e, t, n), Promise.all(s).then((function() {
						return void 0 !== t.targets ? function(e, t, n) {
							let r = !1,
								i = !1;
							for (let o = 0, l = t.length; o < l; o++) {
								const e = t[o];
								if (void 0 !== e.POSITION && (r = !0), void 0 !== e.NORMAL && (i = !0), r && i) break
							}
							if (!r && !i) return Promise.resolve(e);
							const s = [],
								a = [];
							for (let o = 0, l = t.length; o < l; o++) {
								const l = t[o];
								if (r) {
									const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position;
									s.push(t)
								}
								if (i) {
									const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal;
									a.push(t)
								}
							}
							return Promise.all([Promise.all(s), Promise.all(a)]).then((function(t) {
								const n = t[0],
									s = t[1];
								return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e
							}))
						}(e, t.targets, n) : e
					}))
			}

			function oe(e, t) {
				let n = e.getIndex();
				if (null === n) {
					const t = [],
						r = e.getAttribute("position");
					if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
					for (let e = 0; e < r.count; e++) t.push(e);
					e.setIndex(t), n = e.getIndex()
				}
				const i = n.count - 2,
					s = [];
				if (t === r.TriangleFanDrawMode)
					for (let r = 1; r <= i; r++) s.push(n.getX(0)), s.push(n.getX(r)), s.push(n.getX(r + 1));
				else
					for (let r = 0; r < i; r++) r % 2 === 0 ? (s.push(n.getX(r)), s.push(n.getX(r + 1)), s.push(n.getX(r + 2))) : (s.push(n.getX(r + 2)), s.push(n.getX(r + 1)), s.push(n.getX(r)));
				s.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
				const a = e.clone();
				return a.setIndex(s), a
			}
			var le = n(6447);
			let ce = null;

			function ue(e, t, n) {
				return r => {
					n && n(r), e && (ce || (ce = new s), ce.setDecoderPath("string" === typeof e ? e : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), r.setDRACOLoader(ce)), t && r.setMeshoptDecoder(l())
				}
			}

			function he(e, t = !0, n = !0, r) {
				return (0, le.U2)(c, e, ue(t, n, r))
			}
			he.preload = (e, t = !0, n = !0, r) => le.U2.preload(c, e, ue(t, n, r)), he.clear = e => le.U2.clear(c, e)
		},
		6447: function(e, t, n) {
			"use strict";
			n.d(t, {
				Xz: function() {
					return K
				},
				gy: function() {
					return z
				},
				nH: function() {
					return oe
				},
				xQ: function() {
					return Z
				},
				U2: function() {
					return te
				},
				Ky: function() {
					return Q
				}
			});
			var r = n(2212),
				i = n(7294);

			function s(e) {
				let t;
				const n = new Set,
					r = (e, r) => {
						const i = "function" === typeof e ? e(t) : e;
						if (i !== t) {
							const e = t;
							t = r ? i : Object.assign({}, t, i), n.forEach((n => n(t, e)))
						}
					},
					i = () => t,
					s = {
						setState: r,
						getState: i,
						subscribe: (e, r, s) => r || s ? ((e, r = i, s = Object.is) => {
							console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
							let a = r(t);

							function o() {
								const n = r(t);
								if (!s(a, n)) {
									const t = a;
									e(a = n, t)
								}
							}
							return n.add(o), () => n.delete(o)
						})(e, r, s) : (n.add(e), () => n.delete(e)),
						destroy: () => n.clear()
					};
				return t = e(r, i, s), s
			}
			const a = "undefined" === typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent) ? i.useEffect : i.useLayoutEffect;
			var o = n(6525),
				l = n.n(o),
				c = n(3840),
				u = n(4063),
				h = n.n(u);
			const d = [];

			function p(e, t, n, r = 0, i = !1) {
				for (const a of t)
					if (h()(n, a.args)) {
						if (i) return;
						if (a.error) throw a.error;
						if (a.response) return a.response;
						throw a.promise
					} const s = {
					args: n,
					promise: e(...n).then((e => s.response = null == e || e)).catch((e => s.error = null != e ? e : "unknown error")).then((() => {
						r > 0 && setTimeout((() => {
							const e = t.indexOf(s); - 1 !== e && t.splice(e, 1)
						}), r)
					}))
				};
				if (t.push(s), !i) throw s.promise
			}

			function f(e, ...t) {
				if (void 0 === t || 0 === t.length) e.splice(0, e.length);
				else {
					const n = e.find((e => h()(t, e.args)));
					if (n) {
						const t = e.indexOf(n); - 1 !== t && e.splice(t, 1)
					}
				}
			}

			function m(e, ...t) {
				return p(e, d, t, m.lifespan)
			}
			m.lifespan = 0, m.clear = (...e) => f(d, ...e), m.preload = (e, ...t) => {
				p(e, d, t, m.lifespan, !0)
			}, m.peek = (...e) => {
				var t;
				return null == (t = d.find((t => h()(e, t.args)))) ? void 0 : t.response
			};
			var g = function(e) {
					return function(t) {
						e.forEach((function(e) {
							"function" === typeof e ? e(t) : null != e && (e.current = t)
						}))
					}
				},
				v = n(296),
				y = n.n(v);

			function x(e) {
				let {
					debounce: t,
					scroll: n,
					polyfill: r,
					offsetSize: s
				} = void 0 === e ? {
					debounce: 0,
					scroll: !1,
					offsetSize: !1
				} : e;
				const a = r || ("undefined" === typeof window ? class {} : window.ResizeObserver);
				if (!a) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
				const [o, l] = (0, i.useState)({
					left: 0,
					top: 0,
					width: 0,
					height: 0,
					bottom: 0,
					right: 0,
					x: 0,
					y: 0
				}), c = (0, i.useRef)({
					element: null,
					scrollContainers: null,
					resizeObserver: null,
					lastBounds: o
				}), u = t ? "number" === typeof t ? t : t.scroll : null, h = t ? "number" === typeof t ? t : t.resize : null, d = (0, i.useRef)(!1);
				(0, i.useEffect)((() => (d.current = !0, () => {
					d.current = !1
				})));
				const [p, f, m] = (0, i.useMemo)((() => {
					const e = () => {
						if (!c.current.element) return;
						const {
							left: e,
							top: t,
							width: n,
							height: r,
							bottom: i,
							right: a,
							x: o,
							y: u
						} = c.current.element.getBoundingClientRect(), h = {
							left: e,
							top: t,
							width: n,
							height: r,
							bottom: i,
							right: a,
							x: o,
							y: u
						};
						c.current.element instanceof HTMLElement && s && (h.height = c.current.element.offsetHeight, h.width = c.current.element.offsetWidth), Object.freeze(h), d.current && !w(c.current.lastBounds, h) && l(c.current.lastBounds = h)
					};
					return [e, h ? y()(e, h) : e, u ? y()(e, u) : e]
				}), [l, s, u, h]);

				function g() {
					c.current.scrollContainers && (c.current.scrollContainers.forEach((e => e.removeEventListener("scroll", m, !0))), c.current.scrollContainers = null), c.current.resizeObserver && (c.current.resizeObserver.disconnect(), c.current.resizeObserver = null)
				}

				function v() {
					c.current.element && (c.current.resizeObserver = new a(m), c.current.resizeObserver.observe(c.current.element), n && c.current.scrollContainers && c.current.scrollContainers.forEach((e => e.addEventListener("scroll", m, {
						capture: !0,
						passive: !0
					}))))
				}
				var x, b, M;
				return x = m, b = Boolean(n), (0, i.useEffect)((() => {
					if (b) {
						const e = x;
						return window.addEventListener("scroll", e, {
							capture: !0,
							passive: !0
						}), () => {
							window.removeEventListener("scroll", e, !0)
						}
					}
				}), [x, b]), M = f, (0, i.useEffect)((() => {
					const e = M;
					return window.addEventListener("resize", e), () => {
						window.removeEventListener("resize", e)
					}
				}), [M]), (0, i.useEffect)((() => {
					g(), v()
				}), [n, m, f]), (0, i.useEffect)((() => g), []), [e => {
					e && e !== c.current.element && (g(), c.current.element = e, c.current.scrollContainers = _(e), v())
				}, o, p]
			}

			function _(e) {
				const t = [];
				if (!e || e === document.body) return t;
				const {
					overflow: n,
					overflowX: r,
					overflowY: i
				} = window.getComputedStyle(e);
				return [n, r, i].some((e => "auto" === e || "scroll" === e)) && t.push(e), [...t, ..._(e.parentElement)]
			}
			const b = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
				w = (e, t) => b.every((n => e[n] === t[n]));
			const M = {
				obj: e => e === Object(e) && !M.arr(e) && "function" !== typeof e,
				fun: e => "function" === typeof e,
				str: e => "string" === typeof e,
				num: e => "number" === typeof e,
				und: e => void 0 === e,
				arr: e => Array.isArray(e),
				equ(e, t) {
					if (typeof e !== typeof t || !!e !== !!t) return !1;
					if (M.str(e) || M.num(e) || M.obj(e)) return e === t;
					if (M.arr(e) && e == t) return !0;
					let n;
					for (n in e)
						if (!(n in t)) return !1;
					for (n in t)
						if (e[n] !== t[n]) return !1;
					return !M.und(n) || e === t
				}
			};

			function A(e) {
				return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
			}

			function S(e, t, n, r) {
				const i = n.get(t);
				i && (n.delete(t), 0 === n.size && (e.delete(r), i.target.releasePointerCapture(r)))
			}

			function E(e) {
				const t = new r.Vector3;

				function n(e) {
					return e.filter((e => ["Move", "Over", "Enter", "Out", "Leave"].some((t => {
						var n;
						return null == (n = e.__r3f) ? void 0 : n.handlers["onPointer" + t]
					}))))
				}

				function i(t) {
					const {
						internal: n
					} = e.getState();
					Array.from(n.hovered.values()).forEach((e => {
						if (!t.length || !t.find((t => t.object === e.object && t.index === e.index && t.instanceId === e.instanceId))) {
							const r = e.eventObject.__r3f,
								i = null == r ? void 0 : r.handlers;
							if (n.hovered.delete(A(e)), null != r && r.eventCount) {
								const n = {
									...e,
									intersections: t || []
								};
								null == i.onPointerOut || i.onPointerOut(n), null == i.onPointerLeave || i.onPointerLeave(n)
							}
						}
					}))
				}

				function s(e, t) {
					t.forEach((t => {
						var n;
						return null == (n = t.__r3f) || null == n.handlers.onPointerMissed ? void 0 : n.handlers.onPointerMissed(e)
					}))
				}
				return {
					handlePointer: r => {
						switch (r) {
							case "onPointerLeave":
							case "onPointerCancel":
								return () => i([]);
							case "onLostPointerCapture":
								return t => {
									const {
										internal: n
									} = e.getState();
									"pointerId" in t && !n.capturedMap.has(t.pointerId) && (n.capturedMap.delete(t.pointerId), i([]))
								}
						}
						return a => {
							const {
								onPointerMissed: o,
								internal: l
							} = e.getState();
							! function(t) {
								var n;
								const r = e.getState(),
									{
										raycaster: i,
										mouse: s,
										camera: a,
										size: o
									} = r,
									{
										offsetX: l,
										offsetY: c
									} = null != (n = null == i.computeOffsets ? void 0 : i.computeOffsets(t, r)) ? n : t,
									{
										width: u,
										height: h
									} = o;
								s.set(l / u * 2 - 1, -c / h * 2 + 1), i.setFromCamera(s, a)
							}(a), l.lastEvent.current = a;
							const c = "onPointerMove" === r,
								u = "onClick" === r || "onContextMenu" === r || "onDoubleClick" === r,
								h = function(t, n) {
									const {
										internal: r
									} = e.getState();
									if ("pointerId" in n && r.capturedMap.has(n.pointerId))
										for (let e of r.capturedMap.get(n.pointerId).values()) t.push(e.intersection);
									return t
								}(function(t) {
									const n = e.getState(),
										{
											raycaster: r,
											internal: i
										} = n;
									if (!r.enabled) return [];
									const s = new Set,
										a = [],
										o = t ? t(i.interaction) : i.interaction;
									let l = r.intersectObjects(o, !0).filter((e => {
										const t = A(e);
										return !s.has(t) && (s.add(t), !0)
									}));
									r.filter && (l = r.filter(l, n));
									for (const e of l) {
										let t = e.object;
										for (; t;) {
											var c;
											null != (c = t.__r3f) && c.eventCount && a.push({
												...e,
												eventObject: t
											}), t = t.parent
										}
									}
									return a
								}(c ? n : void 0), a),
								d = u ? function(t) {
									const {
										internal: n
									} = e.getState(), r = t.offsetX - n.initialClick[0], i = t.offsetY - n.initialClick[1];
									return Math.round(Math.sqrt(r * r + i * i))
								}(a) : 0;
							"onPointerDown" === r && (l.initialClick = [a.offsetX, a.offsetY], l.initialHits = h.map((e => e.eventObject))), u && !h.length && d <= 2 && (s(a, l.interaction), o && o(a)), c && i(h),
								function(n, r, s, a) {
									const {
										raycaster: o,
										mouse: l,
										camera: c,
										internal: u
									} = e.getState();
									if (n.length) {
										const e = t.set(l.x, l.y, 0).unproject(c),
											h = {
												stopped: !1
											};
										for (const t of n) {
											const d = e => {
													var n, r;
													return null != (n = null == (r = u.capturedMap.get(e)) ? void 0 : r.has(t.eventObject)) && n
												},
												p = e => {
													const n = {
														intersection: t,
														target: r.target
													};
													u.capturedMap.has(e) ? u.capturedMap.get(e).set(t.eventObject, n) : u.capturedMap.set(e, new Map([
														[t.eventObject, n]
													])), r.target.setPointerCapture(e)
												},
												f = e => {
													const n = u.capturedMap.get(e);
													n && S(u.capturedMap, t.eventObject, n, e)
												};
											let m = {};
											for (let e in r) {
												let t = r[e];
												"function" !== typeof t && (m[e] = t)
											}
											let g = {
												...t,
												...m,
												spaceX: l.x,
												spaceY: l.y,
												intersections: n,
												stopped: h.stopped,
												delta: s,
												unprojectedPoint: e,
												ray: o.ray,
												camera: c,
												stopPropagation: () => {
													const e = "pointerId" in r && u.capturedMap.get(r.pointerId);
													(!e || e.has(t.eventObject)) && (g.stopped = h.stopped = !0, u.hovered.size && Array.from(u.hovered.values()).find((e => e.eventObject === t.eventObject))) && i([...n.slice(0, n.indexOf(t)), t])
												},
												target: {
													hasPointerCapture: d,
													setPointerCapture: p,
													releasePointerCapture: f
												},
												currentTarget: {
													hasPointerCapture: d,
													setPointerCapture: p,
													releasePointerCapture: f
												},
												sourceEvent: r,
												nativeEvent: r
											};
											if (a(g), !0 === h.stopped) break
										}
									}
								}(h, a, d, (e => {
									const t = e.eventObject,
										n = t.__r3f,
										i = null == n ? void 0 : n.handlers;
									if (null != n && n.eventCount)
										if (c) {
											if (i.onPointerOver || i.onPointerEnter || i.onPointerOut || i.onPointerLeave) {
												const t = A(e),
													n = l.hovered.get(t);
												n ? n.stopped && e.stopPropagation() : (l.hovered.set(t, e), null == i.onPointerOver || i.onPointerOver(e), null == i.onPointerEnter || i.onPointerEnter(e))
											}
											null == i.onPointerMove || i.onPointerMove(e)
										} else {
											const n = i[r];
											n ? u && !l.initialHits.includes(t) || (s(a, l.interaction.filter((e => !l.initialHits.includes(e)))), n(e)) : u && l.initialHits.includes(t) && s(a, l.interaction.filter((e => !l.initialHits.includes(e))))
										}
								}))
						}
					}
				}
			}
			const T = e => e && !!e.getState,
				C = (e, t) => {
					var n, r;
					return {
						root: T(e) ? e : null != (n = null == (r = e.__r3f) ? void 0 : r.root) ? n : t.__r3f.root,
						container: T(e) ? e.getState().scene : e
					}
				},
				B = "__default",
				R = {};
			let L = {};

			function I(e, t) {
				const n = e;
				return (null != t && t.primitive || !n.__r3f) && (n.__r3f = {
					root: null,
					memoizedProps: {},
					eventCount: 0,
					handlers: {},
					objects: [],
					parent: null,
					...t
				}), e
			}
			const P = e => e && e.isOrthographicCamera;

			function D(e) {
				return Array.isArray(e) ? Math.min(Math.max(e[0], window.devicePixelRatio), e[1]) : e
			}
			const F = i.createContext(null),
				O = (e, t, n, o) => {
					const {
						gl: l,
						size: c,
						shadows: u = !1,
						linear: h = !1,
						flat: d = !1,
						vr: p = !1,
						orthographic: f = !1,
						frameloop: m = "always",
						dpr: g = 1,
						performance: v,
						clock: y = new r.Clock,
						raycaster: x,
						camera: _,
						onPointerMissed: b
					} = o;
					u && (l.shadowMap.enabled = !0, "object" === typeof u ? Object.assign(l.shadowMap, u) : l.shadowMap.type = r.PCFSoftShadowMap), h && (l.outputEncoding = r.LinearEncoding), d && (l.toneMapping = r.NoToneMapping), "never" === m && (y.stop(), y.elapsedTime = 0);
					const w = function(e) {
							const t = "function" === typeof e ? s(e) : e,
								n = (e = t.getState, n = Object.is) => {
									const [, r] = (0, i.useReducer)((e => e + 1), 0), s = t.getState(), o = (0, i.useRef)(s), l = (0, i.useRef)(e), c = (0, i.useRef)(n), u = (0, i.useRef)(!1), h = (0, i.useRef)();
									let d;
									void 0 === h.current && (h.current = e(s));
									let p = !1;
									(o.current !== s || l.current !== e || c.current !== n || u.current) && (d = e(s), p = !n(h.current, d)), a((() => {
										p && (h.current = d), o.current = s, l.current = e, c.current = n, u.current = !1
									}));
									const f = (0, i.useRef)(s);
									a((() => {
										const e = () => {
												try {
													const e = t.getState(),
														n = l.current(e);
													c.current(h.current, n) || (o.current = e, h.current = n, r())
												} catch (e) {
													u.current = !0, r()
												}
											},
											n = t.subscribe(e);
										return t.getState() !== f.current && e(), n
									}), []);
									const m = p ? d : h.current;
									return (0, i.useDebugValue)(m), m
								};
							return Object.assign(n, t), n[Symbol.iterator] = function() {
								console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
								const e = [n, t];
								return {
									next() {
										const t = e.length <= 0;
										return {
											value: e.shift(),
											done: t
										}
									}
								}
							}, n
						}(((s, a) => {
							const c = new r.Raycaster,
								{
									params: u,
									...w
								} = x || {};
							e(c, {
								enabled: !0,
								...w,
								params: {
									...c.params,
									...u
								}
							});
							const M = _ instanceof r.Camera,
								A = M ? _ : f ? new r.OrthographicCamera(0, 0, 0, 0, .1, 1e3) : new r.PerspectiveCamera(75, 0, .1, 1e3);
							M || (A.position.z = 5, _ && e(A, _), null != _ && _.rotation || A.lookAt(0, 0, 0));
							const S = D(g),
								E = new r.Vector3,
								T = new r.Vector3,
								C = new r.Vector3;

							function B(e = a().camera, t = T, n = a().size) {
								const {
									width: i,
									height: s
								} = n, o = i / s;
								t instanceof r.Vector3 ? C.copy(t) : C.set(...t);
								const l = e.getWorldPosition(E).distanceTo(C);
								if (P(e)) return {
									width: i / e.zoom,
									height: s / e.zoom,
									factor: 1,
									distance: l,
									aspect: o
								}; {
									const t = e.fov * Math.PI / 180,
										n = 2 * Math.tan(t / 2) * l,
										r = n * (i / s);
									return {
										width: r,
										height: n,
										factor: i / r,
										distance: l,
										aspect: o
									}
								}
							}
							let R;
							const L = e => s((t => ({
								performance: {
									...t.performance,
									current: e
								}
							})));
							return {
								gl: l,
								set: s,
								get: a,
								invalidate: () => t(a()),
								advance: (e, t) => n(e, t, a()),
								linear: h,
								flat: d,
								scene: I(new r.Scene),
								camera: A,
								controls: null,
								raycaster: c,
								clock: y,
								mouse: new r.Vector2,
								vr: p,
								frameloop: m,
								onPointerMissed: b,
								performance: {
									current: 1,
									min: .5,
									max: 1,
									debounce: 200,
									...v,
									regress: () => {
										const e = a();
										R && clearTimeout(R), e.performance.current !== e.performance.min && L(e.performance.min), R = setTimeout((() => L(a().performance.max)), e.performance.debounce)
									}
								},
								size: {
									width: 0,
									height: 0
								},
								viewport: {
									initialDpr: S,
									dpr: S,
									width: 0,
									height: 0,
									aspect: 0,
									distance: 0,
									factor: 0,
									getCurrentViewport: B
								},
								setSize: (e, t) => {
									const n = {
										width: e,
										height: t
									};
									s((e => ({
										size: n,
										viewport: {
											...e.viewport,
											...B(A, T, n)
										}
									})))
								},
								setDpr: e => s((t => ({
									viewport: {
										...t.viewport,
										dpr: D(e)
									}
								}))),
								setFrameloop: (e = "always") => s((() => ({
									frameloop: e
								}))),
								events: {
									connected: !1
								},
								internal: {
									active: !1,
									priority: 0,
									frames: 0,
									lastProps: o,
									lastEvent: i.createRef(),
									interaction: [],
									hovered: new Map,
									subscribers: [],
									initialClick: [0, 0],
									initialHits: [],
									capturedMap: new Map,
									subscribe: (e, t = 0) => (s((({
										internal: n
									}) => ({
										internal: {
											...n,
											priority: n.priority + (t > 0 ? 1 : 0),
											subscribers: [...n.subscribers, {
												ref: e,
												priority: t
											}].sort(((e, t) => e.priority - t.priority))
										}
									}))), () => {
										s((({
											internal: n
										}) => ({
											internal: {
												...n,
												priority: n.priority - (t > 0 ? 1 : 0),
												subscribers: n.subscribers.filter((t => t.ref !== e))
											}
										})))
									})
								}
							}
						})),
						M = w.getState();
					let A = M.size,
						S = M.viewport.dpr;
					return w.subscribe((() => {
						const {
							camera: e,
							size: t,
							viewport: n,
							internal: i
						} = w.getState();
						t === A && n.dpr === S || (e.manual || i.lastProps.camera instanceof r.Camera || (P(e) ? (e.left = t.width / -2, e.right = t.width / 2, e.top = t.height / 2, e.bottom = t.height / -2) : e.aspect = t.width / t.height, e.updateProjectionMatrix(), e.updateMatrixWorld()), l.setPixelRatio(n.dpr), l.setSize(t.width, t.height), A = t, S = n.dpr)
					})), c && M.setSize(c.width, c.height), w.subscribe((e => t(e))), w
				};

			function N(e, t) {
				const n = t.length;
				return t.push(e), () => {
					t.splice(n, 1)
				}
			}
			let H, k = [],
				G = [],
				U = [];
			const z = e => N(e, k);

			function V(e, t) {
				for (H = 0; H < e.length; H++) e[H](t)
			}

			function W(e, t) {
				let n = t.clock.getDelta();
				for ("never" === t.frameloop && "number" === typeof e && (n = e - t.clock.elapsedTime, t.clock.oldTime = t.clock.elapsedTime, t.clock.elapsedTime = e), H = 0; H < t.internal.subscribers.length; H++) t.internal.subscribers[H].ref.current(t, n);
				return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera), t.internal.frames = Math.max(0, t.internal.frames - 1), "always" === t.frameloop ? 1 : t.internal.frames
			}

			function j(e) {
				const {
					handlePointer: t
				} = E(e), n = {
					onClick: ["click", !1],
					onContextMenu: ["contextmenu", !1],
					onDoubleClick: ["dblclick", !1],
					onWheel: ["wheel", !0],
					onPointerDown: ["pointerdown", !0],
					onPointerUp: ["pointerup", !0],
					onPointerLeave: ["pointerleave", !0],
					onPointerMove: ["pointermove", !0],
					onPointerCancel: ["pointercancel", !0],
					onLostPointerCapture: ["lostpointercapture", !0]
				};
				return {
					connected: !1,
					handlers: Object.keys(n).reduce(((e, n) => ({
						...e,
						[n]: t(n)
					})), {}),
					connect: t => {
						var r;
						const {
							set: i,
							events: s
						} = e.getState();
						null == s.disconnect || s.disconnect(), i((e => ({
							events: {
								...e.events,
								connected: t
							}
						}))), Object.entries(null != (r = null == s ? void 0 : s.handlers) ? r : []).forEach((([e, r]) => {
							const [i, s] = n[e];
							t.addEventListener(i, r, {
								passive: s
							})
						}))
					},
					disconnect: () => {
						const {
							set: t,
							events: r
						} = e.getState();
						var i;
						r.connected && (Object.entries(null != (i = r.handlers) ? i : []).forEach((([e, t]) => {
							if (r && r.connected instanceof HTMLElement) {
								const [i] = n[e];
								r.connected.removeEventListener(i, t)
							}
						})), t((e => ({
							events: {
								...e.events,
								connected: !1
							}
						}))))
					}
				}
			}
			const J = "undefined" !== typeof window ? i.useLayoutEffect : i.useEffect;

			function X({
				set: e
			}) {
				return J((() => (e(new Promise((() => null))), () => e(!1))), []), null
			}
			class q extends i.Component {
				constructor(...e) {
					super(...e), this.state = {
						error: !1
					}
				}
				componentDidCatch(e) {
					this.props.set(e)
				}
				render() {
					return this.state.error ? null : this.props.children
				}
			}
			q.getDerivedStateFromError = () => ({
				error: !0
			});
			const K = i.forwardRef((function({
				children: e,
				fallback: t,
				tabIndex: n,
				resize: s,
				id: a,
				style: o,
				className: l,
				events: c,
				...u
			}, h) {
				const [d, {
					width: p,
					height: f
				}] = x({
					scroll: !0,
					debounce: {
						scroll: 50,
						resize: 0
					},
					...s
				}), m = i.useRef(null), [v, y] = i.useState(!1), [_, b] = i.useState(!1);
				if (v) throw v;
				if (_) throw _;
				return J((() => {
					p > 0 && f > 0 && function(e, t, {
						gl: n,
						size: s,
						mode: a = re[1],
						events: o,
						onCreated: l,
						...c
					} = {}) {
						var u, h, d, p, f;
						s || (s = {
							width: null != (h = null == (d = t.parentElement) ? void 0 : d.clientWidth) ? h : 0,
							height: null != (p = null == (f = t.parentElement) ? void 0 : f.clientHeight) ? p : 0
						});
						let m = ne.get(t),
							g = null == m ? void 0 : m.fiber,
							v = null == m ? void 0 : m.store,
							y = null == (u = v) ? void 0 : u.getState();
						if (g && y) {
							void 0 === c.dpr || M.equ(y.viewport.dpr, D(c.dpr)) || y.setDpr(c.dpr), y.size.width === s.width && y.size.height === s.height || y.setSize(s.width, s.height), y.frameloop !== c.frameloop && y.setFrameloop(c.frameloop);
							c.linear !== y.internal.lastProps.linear && (ce(t), g = void 0)
						}
						if (!g) {
							const e = ((e, t) => {
								const n = "function" === typeof e ? e(t) : e;
								if (i = n, null != i && i.render) return n;
								var i;
								const s = new r.WebGLRenderer({
									powerPreference: "high-performance",
									canvas: t,
									antialias: !0,
									alpha: !0,
									...e
								});
								s.outputEncoding = r.sRGBEncoding, s.toneMapping = r.ACESFilmicToneMapping, e && oe(s, e);
								return s
							})(n, t);
							c.vr && (e.xr.enabled = !0, e.setAnimationLoop((e => se(e, !0)))), v = O(oe, ie, se, {
								gl: e,
								size: s,
								...c
							});
							const i = v.getState();
							g = ae.createContainer(v, re.indexOf(a), !1, null), ne.set(t, {
								fiber: g,
								store: v
							}), o && i.set({
								events: o(v)
							})
						}
						if (v && g) return ae.updateContainer(i.createElement(le, {
							store: v,
							element: e,
							onCreated: l,
							target: t
						}), g, null, (() => {})), v;
						throw "Error creating root!"
					}(i.createElement(q, {
						set: b
					}, i.createElement(i.Suspense, {
						fallback: i.createElement(X, {
							set: y
						})
					}, e)), m.current, {
						...u,
						size: {
							width: p,
							height: f
						},
						events: c || j
					})
				}), [p, f, e]), J((() => {
					const e = m.current;
					return () => ce(e)
				}), []), i.createElement("div", {
					ref: d,
					id: a,
					className: l,
					tabIndex: n,
					style: {
						position: "relative",
						width: "100%",
						height: "100%",
						overflow: "hidden",
						...o
					}
				}, i.createElement("canvas", {
					ref: g([m, h]),
					style: {
						display: "block"
					}
				}, t))
			}));

			function Y() {
				const e = i.useContext(F);
				if (!e) throw "R3F hooks can only be used within the Canvas component!";
				return e
			}

			function Q(e = (e => e), t) {
				return Y()(e, t)
			}

			function Z(e, t = 0) {
				const n = Y().getState().internal.subscribe,
					r = i.useRef(e);
				return i.useLayoutEffect((() => {
					r.current = e
				}), [e]), i.useLayoutEffect((() => n(r, t)), [t, n]), null
			}

			function $(e) {
				const t = {
					nodes: {},
					materials: {}
				};
				return e && e.traverse((e => {
					e.name && (t.nodes[e.name] = e), e.material && !t.materials[e.material.name] && (t.materials[e.material.name] = e.material)
				})), t
			}

			function ee(e, t) {
				return function(n, ...r) {
					const i = new n;
					return e && e(i), Promise.all(r.map((e => new Promise(((n, r) => i.load(e, (e => {
						e.scene && Object.assign(e, $(e.scene)), n(e)
					}), t, (t => r(`Could not load ${e}: ${t.message}`))))))))
				}
			}

			function te(e, t, n, r) {
				const i = Array.isArray(t) ? t : [t],
					s = m(ee(n, r), e, ...i);
				return Array.isArray(t) ? s : s[0]
			}
			te.preload = function(e, t, n) {
				const r = Array.isArray(t) ? t : [t];
				return m.preload(ee(n), e, ...r)
			}, te.clear = function(e, t) {
				const n = Array.isArray(t) ? t : [t];
				return m.clear(e, ...n)
			};
			const ne = new Map,
				re = ["legacy", "blocking", "concurrent"],
				{
					invalidate: ie,
					advance: se
				} = function(e) {
					let t, n = !1;

					function r(i) {
						if (n = !0, t = 0, V(k, i), e.forEach((e => {
								const n = e.store.getState();
								n.internal.active && ("always" === n.frameloop || n.internal.frames > 0) && (t += W(i, n))
							})), V(G, i), t > 0) return requestAnimationFrame(r);
						V(U, i), n = !1
					}
					return {
						loop: r,
						invalidate: function t(i) {
							if (!i) return e.forEach((e => t(e.store.getState())));
							!i.vr && i.internal.active && "never" !== i.frameloop && (i.internal.frames = Math.min(60, i.internal.frames + 1), n || (n = !0, requestAnimationFrame(r)))
						},
						advance: function(t, n = !0, r) {
							n && V(k, t), r ? W(t, r) : e.forEach((e => W(t, e.store.getState()))), n && V(G, t)
						}
					}
				}(ne),
				{
					reconciler: ae,
					applyProps: oe
				} = function(e) {
					function t(e, {
						children: t,
						key: n,
						ref: r,
						...i
					}, {
						children: s,
						key: a,
						ref: o,
						...l
					} = {}, c = !1) {
						var u;
						const h = null != (u = null == e ? void 0 : e.__r3f) ? u : {},
							d = Object.entries(i),
							p = [];
						if (c) {
							const e = Object.keys(l);
							for (let t = 0; t < e.length; t++) i.hasOwnProperty(e[t]) || d.unshift([e[t], B + "remove"])
						}
						d.forEach((([t, n]) => {
							var r, i, s;
							if (null != (r = e.__r3f) && r.primitive && "object" === t) return;
							if (i = n, s = l[t], M.arr(i) && M.equ(i, s) || i === s) return;
							if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(t)) return p.push([t, n, !0, []]);
							let a = [];
							t.includes("-") && (a = t.split("-")), p.push([t, n, !1, a])
						}));
						const f = {
							...i
						};
						return h.memoizedProps && h.memoizedProps.args && (f.args = h.memoizedProps.args), h.memoizedProps && h.memoizedProps.attach && (f.attach = h.memoizedProps.attach), {
							accumulative: c,
							memoized: f,
							changes: p
						}
					}

					function n(e, n) {
						var a, o, l;
						const c = null != (a = null == e ? void 0 : e.__r3f) ? a : {},
							u = c.root,
							h = null != (o = null == u || null == u.getState ? void 0 : u.getState()) ? o : {},
							{
								memoized: d,
								changes: p
							} = (f = n) && f.memoized && f.changes ? n : t(e, n);
						var f;
						const m = c.eventCount;
						if (e.__r3f && (e.__r3f.memoizedProps = d), p.forEach((([t, n, s, a]) => {
								let o = e,
									l = o[t];
								if (a.length && (l = a.reduce(((e, t) => e[t]), e), !l || !l.set)) {
									const [n, ...r] = a.reverse();
									o = r.reverse().reduce(((e, t) => e[t]), e), t = n
								}
								if (n === B + "remove")
									if (l && l.constructor) n = new l.constructor(d.args);
									else if (o.constructor) {
									const e = new o.constructor(o.__r3f.memoizedProps.args);
									n = e[l], e.dispose && e.dispose()
								} else n = 0;
								if (s) n ? c.handlers[t] = n : delete c.handlers[t], c.eventCount = Object.keys(c.handlers).length;
								else if (l && l.set && (l.copy || l instanceof r.Layers)) {
									if (Array.isArray(n)) l.fromArray ? l.fromArray(n) : l.set(...n);
									else if (l.copy && n && n.constructor && l.constructor.name === n.constructor.name) l.copy(n);
									else if (void 0 !== n) {
										const e = l instanceof r.Color;
										!e && l.setScalar ? l.setScalar(n) : l instanceof r.Layers && n instanceof r.Layers ? l.mask = n.mask : l.set(n), !h.linear && e && l.convertSRGBToLinear()
									}
								} else o[t] = n, !h.linear && o[t] instanceof r.Texture && (o[t].encoding = r.sRGBEncoding);
								i(e)
							})), c.parent && h.internal && e.raycast && m !== c.eventCount) {
							const t = h.internal.interaction.indexOf(e);
							t > -1 && h.internal.interaction.splice(t, 1), c.eventCount && h.internal.interaction.push(e)
						}
						return p.length && null != (l = e.__r3f) && l.parent && s(e), e
					}

					function i(e) {
						var t, n;
						const r = null == (t = e.__r3f) || null == (n = t.root) || null == n.getState ? void 0 : n.getState();
						r && 0 === r.internal.frames && r.invalidate()
					}

					function s(e) {
						null == e.onUpdate || e.onUpdate(e)
					}

					function a(e, {
						args: t = [],
						...i
					}, s, a, o) {
						let l, c = `${e[0].toUpperCase()}${e.slice(1)}`;
						if (!T(s) && o) {
							const e = t => t.return ? e(t.return) : t.stateNode && t.stateNode.containerInfo;
							s = e(o)
						}
						if (!s || !T(s)) throw `No valid root for ${c}!`;
						if ("primitive" === e) {
							if (void 0 === i.object) throw "Primitives without 'object' are invalid!";
							l = I(i.object, {
								root: s,
								primitive: !0
							})
						} else {
							const e = L[c] || r[c];
							if (!e) throw `${c} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;
							if (!Array.isArray(t)) throw "The args prop must be an array!";
							l = I(new e(...t), {
								root: s,
								memoizedProps: {
									args: 0 === t.length ? null : t
								}
							})
						}
						return "attachFns" in i || (c.endsWith("Geometry") ? i = {
							attach: "geometry",
							...i
						} : c.endsWith("Material") && (i = {
							attach: "material",
							...i
						})), n(l, i), l
					}

					function o(e, t) {
						let n = !1;
						if (t) {
							if (t.attachArray) M.arr(e[t.attachArray]) || (e[t.attachArray] = []), e[t.attachArray].push(t);
							else if (t.attachObject) M.obj(e[t.attachObject[0]]) || (e[t.attachObject[0]] = {}), e[t.attachObject[0]][t.attachObject[1]] = t;
							else if (t.attach && !M.fun(t.attach)) e[t.attach] = t;
							else if (M.arr(t.attachFns)) {
								const [n] = t.attachFns;
								M.str(n) && M.fun(e[n]) ? e[n](t) : M.fun(n) && n(t, e)
							} else t.isObject3D && e.isObject3D && (e.add(t), n = !0);
							n || e.__r3f.objects.push(t), t.__r3f || I(t, {}), t.__r3f.parent = e, s(t), i(t)
						}
					}

					function u(e, t, n) {
						let r = !1;
						if (t) {
							if (t.attachArray) {
								const r = e[t.attachArray];
								M.arr(r) || (e[t.attachArray] = []), r.splice(r.indexOf(n), 0, t)
							} else {
								if (t.attachObject || t.attach && !M.fun(t.attach)) return o(e, t);
								if (t.isObject3D && e.isObject3D) {
									t.parent = e, t.dispatchEvent({
										type: "added"
									});
									const i = e.children.filter((e => e !== t)),
										s = i.indexOf(n);
									e.children = [...i.slice(0, s), t, ...i.slice(s)], r = !0
								}
							}
							r || e.__r3f.objects.push(t), t.__r3f || I(t, {}), t.__r3f.parent = e, s(t), i(t)
						}
					}

					function h(e, t, n = !1) {
						e && [...e].forEach((e => d(t, e, n)))
					}

					function d(e, t, n) {
						if (t) {
							var r, s;
							if (t.__r3f && (t.__r3f.parent = null), null != (r = e.__r3f) && r.objects && (e.__r3f.objects = e.__r3f.objects.filter((e => e !== t))), t.attachArray) e[t.attachArray] = e[t.attachArray].filter((e => e !== t));
							else if (t.attachObject) delete e[t.attachObject[0]][t.attachObject[1]];
							else if (t.attach && !M.fun(t.attach) && e[t.attach] === t) e[t.attach] = null;
							else if (M.arr(t.attachFns)) {
								const [, n] = t.attachFns;
								M.str(n) && M.fun(e[n]) ? e[n](t) : M.fun(n) && n(t, e)
							} else if (t.isObject3D && e.isObject3D) {
								var a;
								e.remove(t), null != (a = t.__r3f) && a.root && function(e, t) {
									const {
										internal: n
									} = e.getState();
									n.interaction = n.interaction.filter((e => e !== t)), n.initialHits = n.initialHits.filter((e => e !== t)), n.hovered.forEach(((e, r) => {
										e.eventObject !== t && e.object !== t || n.hovered.delete(r)
									})), n.capturedMap.forEach(((e, r) => {
										S(n.capturedMap, t, e, r)
									}))
								}(t.__r3f.root, t)
							}
							const l = null == (s = t.__r3f) ? void 0 : s.primitive,
								u = void 0 === n ? null !== t.dispose && !l : n;
							var o;
							if (!l) h(null == (o = t.__r3f) ? void 0 : o.objects, t, u), h(t.children, t, u);
							t.__r3f && (delete t.__r3f.root, delete t.__r3f.objects, delete t.__r3f.handlers, delete t.__r3f.memoizedProps, l || delete t.__r3f), u && t.dispose && "Scene" !== t.type && (0, c.unstable_runWithPriority)(c.unstable_IdlePriority, (() => {
								try {
									t.dispose()
								} catch (e) {}
							})), i(e)
						}
					}
					return {
						reconciler: l()({
							now: c.unstable_now,
							createInstance: a,
							removeChild: d,
							appendChild: o,
							appendInitialChild: o,
							insertBefore: u,
							warnsIfNotActing: !0,
							supportsMutation: !0,
							isPrimaryRenderer: !1,
							scheduleTimeout: M.fun(setTimeout) ? setTimeout : void 0,
							cancelTimeout: M.fun(clearTimeout) ? clearTimeout : void 0,
							setTimeout: M.fun(setTimeout) ? setTimeout : void 0,
							clearTimeout: M.fun(clearTimeout) ? clearTimeout : void 0,
							noTimeout: -1,
							appendChildToContainer: (e, t) => {
								const {
									container: n,
									root: r
								} = C(e, t);
								n.__r3f.root = r, o(n, t)
							},
							removeChildFromContainer: (e, t) => d(C(e, t).container, t),
							insertInContainerBefore: (e, t, n) => u(C(e, t).container, t, n),
							prepareUpdate(e, n, r, i) {
								if (e.__r3f.primitive && i.object && i.object !== e) return [!0]; {
									const {
										args: n = [],
										children: s,
										...a
									} = i, {
										args: l = [],
										children: c,
										...u
									} = r;
									if (!Array.isArray(n)) throw "The args prop must be an array!";
									if (n.some(((e, t) => e !== l[t]))) return [!0];
									const h = t(e, a, u, !0);
									if (h.changes.length) return [!1, h];
									if (e.attach && "function" !== typeof e.attach) {
										const t = e.__r3f.parent;
										t && t[e.attach] !== e && o(t, e)
									}
									return null
								}
							},
							commitUpdate(e, [t, r], i, s, l, c) {
								t ? function(e, t, n, r) {
									var i;
									const s = null == (i = e.__r3f) ? void 0 : i.parent;
									if (!s) return;
									const l = a(t, n, e.__r3f.root);
									"primitive" !== t && e.children && (e.children.forEach((e => o(l, e))), e.children = []), e.__r3f.objects.forEach((e => o(l, e))), e.__r3f.objects = [], d(s, e), o(s, l), [r, r.alternate].forEach((e => {
										null !== e && (e.stateNode = l, e.ref && ("function" === typeof e.ref ? e.ref(l) : e.ref.current = l))
									}))
								}(e, i, l, c) : n(e, r)
							},
							hideInstance(e) {
								e.isObject3D && (e.visible = !1, i(e))
							},
							unhideInstance(e, t) {
								(e.isObject3D && null == t.visible || t.visible) && (e.visible = !0, i(e))
							},
							hideTextInstance() {
								throw new Error("Text is not allowed in the R3F tree.")
							},
							getPublicInstance: e => e,
							getRootHostContext: e => R,
							getChildHostContext: e => e,
							createTextInstance() {},
							finalizeInitialChildren(e) {
								var t;
								return !!(null != (t = null == e ? void 0 : e.__r3f) ? t : {}).handlers
							},
							commitMount(e) {
								var t;
								const n = null != (t = null == e ? void 0 : e.__r3f) ? t : {};
								e.raycast && n.handlers && n.eventCount && e.__r3f.root.getState().internal.interaction.push(e)
							},
							shouldDeprioritizeSubtree: () => !1,
							prepareForCommit: () => null,
							preparePortalMount(e) {
								I(e)
							},
							resetAfterCommit() {},
							shouldSetTextContent: () => !1,
							clearContainer: () => !1
						}),
						applyProps: n
					}
				}();

			function le({
				store: e,
				element: t,
				onCreated: n,
				target: r
			}) {
				return i.useEffect((() => {
					const t = e.getState();
					t.set((e => ({
						internal: {
							...e.internal,
							active: !0
						}
					}))), null == t.events.connect || t.events.connect(r), n && n(t)
				}), []), i.createElement(F.Provider, {
					value: e
				}, t)
			}

			function ce(e, t) {
				const n = ne.get(e),
					r = null == n ? void 0 : n.fiber;
				if (r) {
					const i = null == n ? void 0 : n.store.getState();
					i && (i.internal.active = !1), ae.updateContainer(null, r, null, (() => {
						i && setTimeout((() => {
							var n, r, s;
							null == i.events.disconnect || i.events.disconnect(), null == (n = i.gl) || null == (r = n.renderLists) || null == r.dispose || r.dispose(), null == (s = i.gl) || null == s.forceContextLoss || s.forceContextLoss(),
								function(e) {
									e.dispose && "Scene" !== e.type && e.dispose();
									for (const r in e) {
										var t, n;
										null == (t = (n = r).dispose) || t.call(n), delete e[r]
									}
								}(i), ne.delete(e), t && t(e)
						}), 500)
					}))
				}
			}
			ae.act;
			ae.injectIntoDevTools({
				bundleType: 0,
				rendererPackageName: "@react-three/fiber",
				version: "17.0.2"
			})
		},
		4773: function(e, t, n) {
			"use strict";
			n.d(t, {
				dr: function() {
					return u
				},
				aB: function() {
					return h
				},
				ME: function() {
					return d
				}
			});
			var r = n(655),
				i = n(3819),
				s = n(2844),
				a = n(6893),
				o = n(7597),
				l = n(1130),
				c = n(7873);

			function u(e, t, n) {
				var r = d(t, n && n.syntheticException || void 0, {
					attachStacktrace: e.attachStacktrace
				});
				return (0, s.EG)(r), r.level = i.z.Error, n && n.event_id && (r.event_id = n.event_id), (0, a.WD)(r)
			}

			function h(e, t, n, r) {
				void 0 === n && (n = i.z.Info);
				var s = p(t, r && r.syntheticException || void 0, {
					attachStacktrace: e.attachStacktrace
				});
				return s.level = n, r && r.event_id && (s.event_id = r.event_id), (0, a.WD)(s)
			}

			function d(e, t, n) {
				var i;
				if (void 0 === n && (n = {}), (0, o.VW)(e) && e.error) return e = e.error, i = (0, l.Vf)((0, c._)(e));
				if ((0, o.TX)(e) || (0, o.fm)(e)) {
					var a = e;
					if ("stack" in e) i = (0, l.Vf)((0, c._)(e));
					else {
						var u = a.name || ((0, o.TX)(a) ? "DOMError" : "DOMException"),
							h = a.message ? u + ": " + a.message : u;
						i = p(h, t, n), (0, s.Db)(i, h)
					}
					return "code" in a && (i.tags = (0, r.pi)((0, r.pi)({}, i.tags), {
						"DOMException.code": "" + a.code
					})), i
				}
				if ((0, o.VZ)(e)) return i = (0, l.Vf)((0, c._)(e));
				if ((0, o.PO)(e) || (0, o.cO)(e)) {
					var d = e;
					return i = (0, l.QI)(d, t, n.isRejection), (0, s.EG)(i, {
						synthetic: !0
					}), i
				}
				return i = p(e, t, n), (0, s.Db)(i, "" + e, void 0), (0, s.EG)(i, {
					synthetic: !0
				}), i
			}

			function p(e, t, n) {
				void 0 === n && (n = {});
				var r = {
					message: e
				};
				if (n.attachStacktrace && t) {
					var i = (0, c._)(t),
						s = (0, l.LU)(i.stack);
					r.stacktrace = {
						frames: s
					}
				}
				return r
			}
		},
		6891: function(e, t, n) {
			"use strict";
			n.d(t, {
				Wz: function() {
					return p
				},
				re: function() {
					return m
				},
				BS: function() {
					return g
				}
			});
			var r = n(655),
				i = n(9666),
				s = n(1984),
				a = n(2991),
				o = n(8252),
				l = n(2844),
				c = n(8518),
				u = n(2343),
				h = (0, a.R)(),
				d = 0;

			function p() {
				return d > 0
			}

			function f() {
				d += 1, setTimeout((function() {
					d -= 1
				}))
			}

			function m(e, t, n) {
				if (void 0 === t && (t = {}), "function" !== typeof e) return e;
				try {
					var s = e.__sentry_wrapped__;
					if (s) return s;
					if ((0, o.HK)(e)) return e
				} catch (u) {
					return e
				}
				var a = function() {
					var s = Array.prototype.slice.call(arguments);
					try {
						n && "function" === typeof n && n.apply(this, arguments);
						var a = s.map((function(e) {
							return m(e, t)
						}));
						return e.apply(this, a)
					} catch (o) {
						throw f(), (0, i.$e)((function(e) {
							e.addEventProcessor((function(e) {
								return t.mechanism && ((0, l.Db)(e, void 0, void 0), (0, l.EG)(e, t.mechanism)), e.extra = (0, r.pi)((0, r.pi)({}, e.extra), {
									arguments: s
								}), e
							})), (0, i.Tb)(o)
						})), o
					}
				};
				try {
					for (var c in e) Object.prototype.hasOwnProperty.call(e, c) && (a[c] = e[c])
				} catch (h) {}(0, o.$Q)(a, e), (0, o.xp)(e, "__sentry_wrapped__", a);
				try {
					Object.getOwnPropertyDescriptor(a, "name").configurable && Object.defineProperty(a, "name", {
						get: function() {
							return e.name
						}
					})
				} catch (h) {}
				return a
			}

			function g(e) {
				if (void 0 === e && (e = {}), h.document)
					if (e.eventId)
						if (e.dsn) {
							var t = h.document.createElement("script");
							t.async = !0, t.src = (0, s.hR)(e.dsn, e), e.onLoad && (t.onload = e.onLoad);
							var n = h.document.head || h.document.body;
							n && n.appendChild(t)
						} else(0, c.c)() && u.k.error("Missing dsn option in showReportDialog call");
				else(0, c.c)() && u.k.error("Missing eventId option in showReportDialog call")
			}
		},
		1861: function(e, t, n) {
			"use strict";
			n.d(t, {
				O: function() {
					return d
				}
			});
			var r = n(655),
				i = n(9472),
				s = n(3819);

			function a(e) {
				return "warn" === e ? s.z.Warning : function(e) {
					return -1 !== s.a.indexOf(e)
				}(e) ? e : s.z.Log
			}
			var o = n(2844),
				l = n(9732),
				c = n(8464),
				u = n(7321),
				h = n(2991),
				d = function() {
					function e(t) {
						this.name = e.id, this._options = (0, r.pi)({
							console: !0,
							dom: !0,
							fetch: !0,
							history: !0,
							sentry: !0,
							xhr: !0
						}, t)
					}
					return e.prototype.addSentryBreadcrumb = function(e) {
						this._options.sentry && (0, i.Gd)().addBreadcrumb({
							category: "sentry." + ("transaction" === e.type ? "transaction" : "event"),
							event_id: e.event_id,
							level: e.level,
							message: (0, o.jH)(e)
						}, {
							event: e
						})
					}, e.prototype.setupOnce = function() {
						this._options.console && (0, l.o)("console", p), this._options.dom && (0, l.o)("dom", function(e) {
							function t(t) {
								var n, r = "object" === typeof e ? e.serializeAttribute : void 0;
								"string" === typeof r && (r = [r]);
								try {
									n = t.event.target ? (0, c.R)(t.event.target, r) : (0, c.R)(t.event, r)
								} catch (s) {
									n = "<unknown>"
								}
								0 !== n.length && (0, i.Gd)().addBreadcrumb({
									category: "ui." + t.name,
									message: n
								}, {
									event: t.event,
									name: t.name,
									global: t.global
								})
							}
							return t
						}(this._options.dom)), this._options.xhr && (0, l.o)("xhr", f), this._options.fetch && (0, l.o)("fetch", m), this._options.history && (0, l.o)("history", g)
					}, e.id = "Breadcrumbs", e
				}();

			function p(e) {
				var t = {
					category: "console",
					data: {
						arguments: e.args,
						logger: "console"
					},
					level: a(e.level),
					message: (0, u.nK)(e.args, " ")
				};
				if ("assert" === e.level) {
					if (!1 !== e.args[0]) return;
					t.message = "Assertion failed: " + ((0, u.nK)(e.args.slice(1), " ") || "console.assert"), t.data.arguments = e.args.slice(1)
				}(0, i.Gd)().addBreadcrumb(t, {
					input: e.args,
					level: e.level
				})
			}

			function f(e) {
				if (e.endTimestamp) {
					if (e.xhr.__sentry_own_request__) return;
					var t = e.xhr.__sentry_xhr__ || {},
						n = t.method,
						r = t.url,
						s = t.status_code,
						a = t.body;
					(0, i.Gd)().addBreadcrumb({
						category: "xhr",
						data: {
							method: n,
							url: r,
							status_code: s
						},
						type: "http"
					}, {
						xhr: e.xhr,
						input: a
					})
				} else;
			}

			function m(e) {
				e.endTimestamp && (e.fetchData.url.match(/sentry_key/) && "POST" === e.fetchData.method || (e.error ? (0, i.Gd)().addBreadcrumb({
					category: "fetch",
					data: e.fetchData,
					level: s.z.Error,
					type: "http"
				}, {
					data: e.error,
					input: e.args
				}) : (0, i.Gd)().addBreadcrumb({
					category: "fetch",
					data: (0, r.pi)((0, r.pi)({}, e.fetchData), {
						status_code: e.response.status
					}),
					type: "http"
				}, {
					input: e.args,
					response: e.response
				})))
			}

			function g(e) {
				var t = (0, h.R)(),
					n = e.from,
					r = e.to,
					s = (0, o.en)(t.location.href),
					a = (0, o.en)(n),
					l = (0, o.en)(r);
				a.path || (a = s), s.protocol === l.protocol && s.host === l.host && (r = l.relative), s.protocol === a.protocol && s.host === a.host && (n = a.relative), (0, i.Gd)().addBreadcrumb({
					category: "navigation",
					data: {
						from: n,
						to: r
					}
				})
			}
		},
		9730: function(e, t, n) {
			"use strict";
			n.d(t, {
				I: function() {
					return i
				}
			});
			var r = n(2343),
				i = function() {
					function e() {
						this.name = e.id
					}
					return e.prototype.setupOnce = function(t, n) {
						t((function(t) {
							var i = n().getIntegration(e);
							if (i) {
								try {
									if (function(e, t) {
											if (!t) return !1;
											if (function(e, t) {
													var n = e.message,
														r = t.message;
													if (!n && !r) return !1;
													if (n && !r || !n && r) return !1;
													if (n !== r) return !1;
													if (!a(e, t)) return !1;
													if (!s(e, t)) return !1;
													return !0
												}(e, t)) return !0;
											if (function(e, t) {
													var n = o(t),
														r = o(e);
													if (!n || !r) return !1;
													if (n.type !== r.type || n.value !== r.value) return !1;
													if (!a(e, t)) return !1;
													if (!s(e, t)) return !1;
													return !0
												}(e, t)) return !0;
											return !1
										}(t, i._previousEvent)) return r.k.warn("Event dropped due to being a duplicate of previously captured event."), null
								} catch (l) {
									return i._previousEvent = t
								}
								return i._previousEvent = t
							}
							return t
						}))
					}, e.id = "Dedupe", e
				}();

			function s(e, t) {
				var n = l(e),
					r = l(t);
				if (!n && !r) return !0;
				if (n && !r || !n && r) return !1;
				if (n = n, (r = r).length !== n.length) return !1;
				for (var i = 0; i < r.length; i++) {
					var s = r[i],
						a = n[i];
					if (s.filename !== a.filename || s.lineno !== a.lineno || s.colno !== a.colno || s.function !== a.function) return !1
				}
				return !0
			}

			function a(e, t) {
				var n = e.fingerprint,
					r = t.fingerprint;
				if (!n && !r) return !0;
				if (n && !r || !n && r) return !1;
				n = n, r = r;
				try {
					return !(n.join("") !== r.join(""))
				} catch (i) {
					return !1
				}
			}

			function o(e) {
				return e.exception && e.exception.values && e.exception.values[0]
			}

			function l(e) {
				var t = e.exception;
				if (t) try {
					return t.values[0].stacktrace.frames
				} catch (n) {
					return
				} else if (e.stacktrace) return e.stacktrace.frames
			}
		},
		2136: function(e, t, n) {
			"use strict";
			n.d(t, {
				d: function() {
					return f
				}
			});
			var r = n(655),
				i = n(9472),
				s = n(3819),
				a = n(9732),
				o = n(7597),
				l = n(8464),
				c = n(8518),
				u = n(2343),
				h = n(2844),
				d = n(4773),
				p = n(6891),
				f = function() {
					function e(t) {
						this.name = e.id, this._installFunc = {
							onerror: m,
							onunhandledrejection: g
						}, this._options = (0, r.pi)({
							onerror: !0,
							onunhandledrejection: !0
						}, t)
					}
					return e.prototype.setupOnce = function() {
						Error.stackTraceLimit = 50;
						var e = this._options;
						for (var t in e) {
							var n = this._installFunc[t];
							n && e[t] && (y(t), n(), this._installFunc[t] = void 0)
						}
					}, e.id = "GlobalHandlers", e
				}();

			function m() {
				(0, a.o)("error", (function(e) {
					var t = (0, r.CR)(_(), 2),
						n = t[0],
						i = t[1];
					if (n.getIntegration(f)) {
						var a = e.msg,
							l = e.url,
							c = e.line,
							u = e.column,
							h = e.error;
						if (!((0, p.Wz)() || h && h.__sentry_own_request__)) {
							var m = void 0 === h && (0, o.HD)(a) ? function(e, t, n, r) {
								var i = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i,
									s = (0, o.VW)(e) ? e.message : e,
									a = "Error",
									l = s.match(i);
								l && (a = l[1], s = l[2]);
								return v({
									exception: {
										values: [{
											type: a,
											value: s
										}]
									}
								}, t, n, r)
							}(a, l, c, u) : v((0, d.ME)(h || a, void 0, {
								attachStacktrace: i,
								isRejection: !1
							}), l, c, u);
							m.level = s.z.Error, x(n, h, m, "onerror")
						}
					}
				}))
			}

			function g() {
				(0, a.o)("unhandledrejection", (function(e) {
					var t = (0, r.CR)(_(), 2),
						n = t[0],
						i = t[1];
					if (n.getIntegration(f)) {
						var a = e;
						try {
							"reason" in e ? a = e.reason : "detail" in e && "reason" in e.detail && (a = e.detail.reason)
						} catch (c) {}
						if ((0, p.Wz)() || a && a.__sentry_own_request__) return !0;
						var l = (0, o.pt)(a) ? {
							exception: {
								values: [{
									type: "UnhandledRejection",
									value: "Non-Error promise rejection captured with value: " + String(a)
								}]
							}
						} : (0, d.ME)(a, void 0, {
							attachStacktrace: i,
							isRejection: !0
						});
						l.level = s.z.Error, x(n, a, l, "onunhandledrejection")
					}
				}))
			}

			function v(e, t, n, r) {
				var i = e.exception = e.exception || {},
					s = i.values = i.values || [],
					a = s[0] = s[0] || {},
					c = a.stacktrace = a.stacktrace || {},
					u = c.frames = c.frames || [],
					h = isNaN(parseInt(r, 10)) ? void 0 : r,
					d = isNaN(parseInt(n, 10)) ? void 0 : n,
					p = (0, o.HD)(t) && t.length > 0 ? t : (0, l.l)();
				return 0 === u.length && u.push({
					colno: h,
					filename: p,
					function: "?",
					in_app: !0,
					lineno: d
				}), e
			}

			function y(e) {
				(0, c.c)() && u.k.log("Global Handler attached: " + e)
			}

			function x(e, t, n, r) {
				(0, h.EG)(n, {
					handled: !1,
					type: r
				}), e.captureEvent(n, {
					originalException: t
				})
			}

			function _() {
				var e = (0, i.Gd)(),
					t = e.getClient();
				return [e, t && t.getOptions().attachStacktrace]
			}
		},
		1634: function(e, t, n) {
			"use strict";
			n.d(t, {
				iP: function() {
					return c
				}
			});
			var r = n(655),
				i = n(6769),
				s = n(9472),
				a = n(7597),
				o = n(1130),
				l = n(7873),
				c = function() {
					function e(t) {
						void 0 === t && (t = {}), this.name = e.id, this._key = t.key || "cause", this._limit = t.limit || 5
					}
					return e.prototype.setupOnce = function() {
						(0, i.c)((function(t, n) {
							var i = (0, s.Gd)().getIntegration(e);
							return i ? function(e, t, n, i) {
								if (!n.exception || !n.exception.values || !i || !(0, a.V9)(i.originalException, Error)) return n;
								var s = u(t, i.originalException, e);
								return n.exception.values = (0, r.fl)(s, n.exception.values), n
							}(i._key, i._limit, t, n) : t
						}))
					}, e.id = "LinkedErrors", e
				}();

			function u(e, t, n, i) {
				if (void 0 === i && (i = []), !(0, a.V9)(t[n], Error) || i.length + 1 >= e) return i;
				var s = (0, l._)(t[n]),
					c = (0, o.__)(s);
				return u(e, t[n], n, (0, r.fl)([c], i))
			}
		},
		3692: function(e, t, n) {
			"use strict";
			n.d(t, {
				p: function() {
					return c
				}
			});
			var r = n(655),
				i = n(2991),
				s = n(8252),
				a = n(360),
				o = n(6891),
				l = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
				c = function() {
					function e(t) {
						this.name = e.id, this._options = (0, r.pi)({
							XMLHttpRequest: !0,
							eventTarget: !0,
							requestAnimationFrame: !0,
							setInterval: !0,
							setTimeout: !0
						}, t)
					}
					return e.prototype.setupOnce = function() {
						var e = (0, i.R)();
						this._options.setTimeout && (0, s.hl)(e, "setTimeout", u), this._options.setInterval && (0, s.hl)(e, "setInterval", u), this._options.requestAnimationFrame && (0, s.hl)(e, "requestAnimationFrame", h), this._options.XMLHttpRequest && "XMLHttpRequest" in e && (0, s.hl)(XMLHttpRequest.prototype, "send", d);
						var t = this._options.eventTarget;
						t && (Array.isArray(t) ? t : l).forEach(p)
					}, e.id = "TryCatch", e
				}();

			function u(e) {
				return function() {
					for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
					var r = t[0];
					return t[0] = (0, o.re)(r, {
						mechanism: {
							data: {
								function: (0, a.$)(e)
							},
							handled: !0,
							type: "instrument"
						}
					}), e.apply(this, t)
				}
			}

			function h(e) {
				return function(t) {
					return e.call(this, (0, o.re)(t, {
						mechanism: {
							data: {
								function: "requestAnimationFrame",
								handler: (0, a.$)(e)
							},
							handled: !0,
							type: "instrument"
						}
					}))
				}
			}

			function d(e) {
				return function() {
					for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
					var r = this,
						i = ["onload", "onerror", "onprogress", "onreadystatechange"];
					return i.forEach((function(e) {
						e in r && "function" === typeof r[e] && (0, s.hl)(r, e, (function(t) {
							var n = {
									mechanism: {
										data: {
											function: e,
											handler: (0, a.$)(t)
										},
										handled: !0,
										type: "instrument"
									}
								},
								r = (0, s.HK)(t);
							return r && (n.mechanism.data.handler = (0, a.$)(r)), (0, o.re)(t, n)
						}))
					})), e.apply(this, t)
				}
			}

			function p(e) {
				var t = (0, i.R)(),
					n = t[e] && t[e].prototype;
				n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && ((0, s.hl)(n, "addEventListener", (function(t) {
					return function(n, r, i) {
						try {
							"function" === typeof r.handleEvent && (r.handleEvent = (0, o.re)(r.handleEvent.bind(r), {
								mechanism: {
									data: {
										function: "handleEvent",
										handler: (0, a.$)(r),
										target: e
									},
									handled: !0,
									type: "instrument"
								}
							}))
						} catch (s) {}
						return t.call(this, n, (0, o.re)(r, {
							mechanism: {
								data: {
									function: "addEventListener",
									handler: (0, a.$)(r),
									target: e
								},
								handled: !0,
								type: "instrument"
							}
						}), i)
					}
				})), (0, s.hl)(n, "removeEventListener", (function(e) {
					return function(t, n, r) {
						var i = n;
						try {
							var s = i && i.__sentry_wrapped__;
							s && e.call(this, t, s, r)
						} catch (a) {}
						return e.call(this, t, i, r)
					}
				})))
			}
		},
		3931: function(e, t, n) {
			"use strict";
			n.d(t, {
				Z: function() {
					return o
				}
			});
			var r = n(655),
				i = n(6769),
				s = n(9472),
				a = (0, n(2991).R)(),
				o = function() {
					function e() {
						this.name = e.id
					}
					return e.prototype.setupOnce = function() {
						(0, i.c)((function(t) {
							if ((0, s.Gd)().getIntegration(e)) {
								if (!a.navigator && !a.location && !a.document) return t;
								var n = t.request && t.request.url || a.location && a.location.href,
									i = (a.document || {}).referrer,
									o = (a.navigator || {}).userAgent,
									l = (0, r.pi)((0, r.pi)((0, r.pi)({}, t.request && t.request.headers), i && {
										Referer: i
									}), o && {
										"User-Agent": o
									}),
									c = (0, r.pi)((0, r.pi)({}, n && {
										url: n
									}), {
										headers: l
									});
								return (0, r.pi)((0, r.pi)({}, t), {
									request: c
								})
							}
							return t
						}))
					}, e.id = "UserAgent", e
				}()
		},
		1130: function(e, t, n) {
			"use strict";
			n.d(t, {
				__: function() {
					return a
				},
				QI: function() {
					return o
				},
				Vf: function() {
					return l
				},
				LU: function() {
					return c
				}
			});
			var r = n(7597),
				i = n(8252),
				s = n(7873);

			function a(e) {
				var t = c(e.stack),
					n = {
						type: e.name,
						value: e.message
					};
				return t && t.length && (n.stacktrace = {
					frames: t
				}), void 0 === n.type && "" === n.value && (n.value = "Unrecoverable error caught"), n
			}

			function o(e, t, n) {
				var a = {
					exception: {
						values: [{
							type: (0, r.cO)(e) ? e.constructor.name : n ? "UnhandledRejection" : "Error",
							value: "Non-Error " + (n ? "promise rejection" : "exception") + " captured with keys: " + (0, i.zf)(e)
						}]
					},
					extra: {
						__serialized__: (0, i.Qy)(e)
					}
				};
				if (t) {
					var o = c((0, s._)(t).stack);
					a.stacktrace = {
						frames: o
					}
				}
				return a
			}

			function l(e) {
				return {
					exception: {
						values: [a(e)]
					}
				}
			}

			function c(e) {
				if (!e || !e.length) return [];
				var t = e,
					n = t[0].func || "",
					r = t[t.length - 1].func || "";
				return -1 === n.indexOf("captureMessage") && -1 === n.indexOf("captureException") || (t = t.slice(1)), -1 !== r.indexOf("sentryWrapped") && (t = t.slice(0, -1)), t.slice(0, 50).map((function(e) {
					return {
						colno: null === e.column ? void 0 : e.column,
						filename: e.url || t[0].url,
						function: e.func || "?",
						in_app: !0,
						lineno: null === e.line ? void 0 : e.line
					}
				})).reverse()
			}
		},
		1802: function(e, t, n) {
			"use strict";
			n.d(t, {
				yl: function() {
					return te
				},
				S1: function() {
					return ee
				}
			});
			var r = n(9472),
				i = n(2343);
			var s = n(2422),
				a = n(9116),
				o = n(2991),
				l = n(8518),
				c = n(6893),
				u = n(9732),
				h = n(655),
				d = n(105),
				p = n(6769),
				f = n(292),
				m = n(2844),
				g = n(7597),
				v = n(1170),
				y = n(8252),
				x = n(7321),
				_ = n(7047),
				b = [];

			function w(e) {
				return e.reduce((function(e, t) {
					return e.every((function(e) {
						return t.name !== e.name
					})) && e.push(t), e
				}), [])
			}

			function M(e) {
				var t = {};
				return function(e) {
					var t = e.defaultIntegrations && (0, h.fl)(e.defaultIntegrations) || [],
						n = e.integrations,
						r = (0, h.fl)(w(t));
					Array.isArray(n) ? r = (0, h.fl)(r.filter((function(e) {
						return n.every((function(t) {
							return t.name !== e.name
						}))
					})), w(n)) : "function" === typeof n && (r = n(r), r = Array.isArray(r) ? r : [r]);
					var i = r.map((function(e) {
							return e.name
						})),
						s = "Debug";
					return -1 !== i.indexOf(s) && r.push.apply(r, (0, h.fl)(r.splice(i.indexOf(s), 1))), r
				}(e).forEach((function(e) {
					t[e.name] = e,
						function(e) {
							-1 === b.indexOf(e.name) && (e.setupOnce(p.c, r.Gd), b.push(e.name), i.k.log("Integration installed: " + e.name))
						}(e)
				})), (0, y.xp)(t, "initialized", !0), t
			}
			var A = "Not capturing exception because it's already been captured.",
				S = function() {
					function e(e, t) {
						this._integrations = {}, this._numProcessing = 0, this._backend = new e(t), this._options = t, t.dsn && (this._dsn = (0, f.v)(t.dsn))
					}
					return e.prototype.captureException = function(e, t, n) {
						var r = this;
						if (!(0, m.YO)(e)) {
							var s = t && t.event_id;
							return this._process(this._getBackend().eventFromException(e, t).then((function(e) {
								return r._captureEvent(e, t, n)
							})).then((function(e) {
								s = e
							}))), s
						}
						i.k.log(A)
					}, e.prototype.captureMessage = function(e, t, n, r) {
						var i = this,
							s = n && n.event_id,
							a = (0, g.pt)(e) ? this._getBackend().eventFromMessage(String(e), t, n) : this._getBackend().eventFromException(e, n);
						return this._process(a.then((function(e) {
							return i._captureEvent(e, n, r)
						})).then((function(e) {
							s = e
						}))), s
					}, e.prototype.captureEvent = function(e, t, n) {
						if (!(t && t.originalException && (0, m.YO)(t.originalException))) {
							var r = t && t.event_id;
							return this._process(this._captureEvent(e, t, n).then((function(e) {
								r = e
							}))), r
						}
						i.k.log(A)
					}, e.prototype.captureSession = function(e) {
						this._isEnabled() ? "string" !== typeof e.release ? (0, l.c)() && i.k.warn("Discarded session because of missing or non-string release") : (this._sendSession(e), e.update({
							init: !1
						})) : (0, l.c)() && i.k.warn("SDK not enabled, will not capture session.")
					}, e.prototype.getDsn = function() {
						return this._dsn
					}, e.prototype.getOptions = function() {
						return this._options
					}, e.prototype.getTransport = function() {
						return this._getBackend().getTransport()
					}, e.prototype.flush = function(e) {
						var t = this;
						return this._isClientDoneProcessing(e).then((function(n) {
							return t.getTransport().close(e).then((function(e) {
								return n && e
							}))
						}))
					}, e.prototype.close = function(e) {
						var t = this;
						return this.flush(e).then((function(e) {
							return t.getOptions().enabled = !1, e
						}))
					}, e.prototype.setupIntegrations = function() {
						this._isEnabled() && !this._integrations.initialized && (this._integrations = M(this._options))
					}, e.prototype.getIntegration = function(e) {
						try {
							return this._integrations[e.id] || null
						} catch (t) {
							return i.k.warn("Cannot retrieve integration " + e.id + " from the current Client"), null
						}
					}, e.prototype._updateSessionFromEvent = function(e, t) {
						var n, r, i = !1,
							s = !1,
							a = t.exception && t.exception.values;
						if (a) {
							s = !0;
							try {
								for (var o = (0, h.XA)(a), l = o.next(); !l.done; l = o.next()) {
									var c = l.value.mechanism;
									if (c && !1 === c.handled) {
										i = !0;
										break
									}
								}
							} catch (d) {
								n = {
									error: d
								}
							} finally {
								try {
									l && !l.done && (r = o.return) && r.call(o)
								} finally {
									if (n) throw n.error
								}
							}
						}
						var u = "ok" === e.status;
						(u && 0 === e.errors || u && i) && (e.update((0, h.pi)((0, h.pi)({}, i && {
							status: "crashed"
						}), {
							errors: e.errors || Number(s || i)
						})), this.captureSession(e))
					}, e.prototype._sendSession = function(e) {
						this._getBackend().sendSession(e)
					}, e.prototype._isClientDoneProcessing = function(e) {
						var t = this;
						return new c.cW((function(n) {
							var r = 0,
								i = setInterval((function() {
									0 == t._numProcessing ? (clearInterval(i), n(!0)) : (r += 1, e && r >= e && (clearInterval(i), n(!1)))
								}), 1)
						}))
					}, e.prototype._getBackend = function() {
						return this._backend
					}, e.prototype._isEnabled = function() {
						return !1 !== this.getOptions().enabled && void 0 !== this._dsn
					}, e.prototype._prepareEvent = function(e, t, n) {
						var r = this,
							i = this.getOptions().normalizeDepth,
							s = void 0 === i ? 3 : i,
							a = (0, h.pi)((0, h.pi)({}, e), {
								event_id: e.event_id || (n && n.event_id ? n.event_id : (0, m.DM)()),
								timestamp: e.timestamp || (0, v.yW)()
							});
						this._applyClientOptions(a), this._applyIntegrationsMetadata(a);
						var o = t;
						n && n.captureContext && (o = p.s.clone(o).update(n.captureContext));
						var l = (0, c.WD)(a);
						return o && (l = o.applyToEvent(a, n)), l.then((function(e) {
							return "number" === typeof s && s > 0 ? r._normalizeEvent(e, s) : e
						}))
					}, e.prototype._normalizeEvent = function(e, t) {
						if (!e) return null;
						var n = (0, h.pi)((0, h.pi)((0, h.pi)((0, h.pi)((0, h.pi)({}, e), e.breadcrumbs && {
							breadcrumbs: e.breadcrumbs.map((function(e) {
								return (0, h.pi)((0, h.pi)({}, e), e.data && {
									data: (0, y.Fv)(e.data, t)
								})
							}))
						}), e.user && {
							user: (0, y.Fv)(e.user, t)
						}), e.contexts && {
							contexts: (0, y.Fv)(e.contexts, t)
						}), e.extra && {
							extra: (0, y.Fv)(e.extra, t)
						});
						return e.contexts && e.contexts.trace && (n.contexts.trace = e.contexts.trace), e.sdkProcessingMetadata = (0, h.pi)((0, h.pi)({}, e.sdkProcessingMetadata), {
							baseClientNormalized: !0
						}), n
					}, e.prototype._applyClientOptions = function(e) {
						var t = this.getOptions(),
							n = t.environment,
							r = t.release,
							i = t.dist,
							s = t.maxValueLength,
							a = void 0 === s ? 250 : s;
						"environment" in e || (e.environment = "environment" in t ? n : "production"), void 0 === e.release && void 0 !== r && (e.release = r), void 0 === e.dist && void 0 !== i && (e.dist = i), e.message && (e.message = (0, x.$G)(e.message, a));
						var o = e.exception && e.exception.values && e.exception.values[0];
						o && o.value && (o.value = (0, x.$G)(o.value, a));
						var l = e.request;
						l && l.url && (l.url = (0, x.$G)(l.url, a))
					}, e.prototype._applyIntegrationsMetadata = function(e) {
						var t = Object.keys(this._integrations);
						t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = (0, h.fl)(e.sdk.integrations || [], t))
					}, e.prototype._sendEvent = function(e) {
						this._getBackend().sendEvent(e)
					}, e.prototype._captureEvent = function(e, t, n) {
						return this._processEvent(e, t, n).then((function(e) {
							return e.event_id
						}), (function(e) {
							i.k.error(e)
						}))
					}, e.prototype._processEvent = function(e, t, n) {
						var r = this,
							i = this.getOptions(),
							s = i.beforeSend,
							a = i.sampleRate,
							o = this.getTransport();

						function l(e, t) {
							o.recordLostEvent && o.recordLostEvent(e, t)
						}
						if (!this._isEnabled()) return (0, c.$2)(new _.b("SDK not enabled, will not capture event."));
						var u = "transaction" === e.type;
						return !u && "number" === typeof a && Math.random() > a ? (l("sample_rate", "event"), (0, c.$2)(new _.b("Discarding event because it's not included in the random sample (sampling rate = " + a + ")"))) : this._prepareEvent(e, n, t).then((function(n) {
							if (null === n) throw l("event_processor", e.type || "event"), new _.b("An event processor returned null, will not send event.");
							return t && t.data && !0 === t.data.__sentry__ || u || !s ? n : function(e) {
								var t = "`beforeSend` method has to return `null` or a valid event.";
								if ((0, g.J8)(e)) return e.then((function(e) {
									if (!(0, g.PO)(e) && null !== e) throw new _.b(t);
									return e
								}), (function(e) {
									throw new _.b("beforeSend rejected with " + e)
								}));
								if (!(0, g.PO)(e) && null !== e) throw new _.b(t);
								return e
							}(s(n, t))
						})).then((function(t) {
							if (null === t) throw l("before_send", e.type || "event"), new _.b("`beforeSend` returned `null`, will not send event.");
							var i = n && n.getSession && n.getSession();
							return !u && i && r._updateSessionFromEvent(i, t), r._sendEvent(t), t
						})).then(null, (function(e) {
							if (e instanceof _.b) throw e;
							throw r.captureException(e, {
								data: {
									__sentry__: !0
								},
								originalException: e
							}), new _.b("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + e)
						}))
					}, e.prototype._process = function(e) {
						var t = this;
						this._numProcessing += 1, e.then((function(e) {
							return t._numProcessing -= 1, e
						}), (function(e) {
							return t._numProcessing -= 1, e
						}))
					}, e
				}();
			var E = function() {
					function e() {}
					return e.prototype.sendEvent = function(e) {
						return (0, c.WD)({
							reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
							status: "skipped"
						})
					}, e.prototype.close = function(e) {
						return (0, c.WD)(!0)
					}, e
				}(),
				T = function() {
					function e(e) {
						this._options = e, this._options.dsn || i.k.warn("No DSN provided, backend will not do anything."), this._transport = this._setupTransport()
					}
					return e.prototype.eventFromException = function(e, t) {
						throw new _.b("Backend has to implement `eventFromException` method")
					}, e.prototype.eventFromMessage = function(e, t, n) {
						throw new _.b("Backend has to implement `eventFromMessage` method")
					}, e.prototype.sendEvent = function(e) {
						this._transport.sendEvent(e).then(null, (function(e) {
							(0, l.c)() && i.k.error("Error while sending event: " + e)
						}))
					}, e.prototype.sendSession = function(e) {
						this._transport.sendSession ? this._transport.sendSession(e).then(null, (function(e) {
							(0, l.c)() && i.k.error("Error while sending session: " + e)
						})) : (0, l.c)() && i.k.warn("Dropping session because custom transport doesn't implement sendSession")
					}, e.prototype.getTransport = function() {
						return this._transport
					}, e.prototype._setupTransport = function() {
						return new E
					}, e
				}(),
				C = n(3819),
				B = n(8823),
				R = n(4773),
				L = n(1984);

			function I(e) {
				if (e.metadata && e.metadata.sdk) {
					var t = e.metadata.sdk;
					return {
						name: t.name,
						version: t.version
					}
				}
			}

			function P(e, t) {
				var n, r = I(t),
					i = e.type || "event",
					s = "transaction" === i || !!t.tunnel,
					a = (e.sdkProcessingMetadata || {}).transactionSampling || {},
					o = a.method,
					l = a.rate;
				! function(e, t) {
					t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = (0, h.fl)(e.sdk.integrations || [], t.integrations || []), e.sdk.packages = (0, h.fl)(e.sdk.packages || [], t.packages || []))
				}(e, t.metadata.sdk), e.tags = e.tags || {}, e.extra = e.extra || {}, e.sdkProcessingMetadata && e.sdkProcessingMetadata.baseClientNormalized || (e.tags.skippedNormalization = !0), delete e.sdkProcessingMetadata;
				try {
					n = JSON.stringify(e)
				} catch (p) {
					e.tags.JSONStringifyError = !0, e.extra.JSONStringifyError = p;
					try {
						n = JSON.stringify((0, y.Fv)(e))
					} catch (m) {
						var c = m;
						n = JSON.stringify({
							message: "JSON.stringify error after renormalization",
							extra: {
								message: c.message,
								stack: c.stack
							}
						})
					}
				}
				var u = {
					body: n,
					type: i,
					url: s ? (0, L.Ut)(t.dsn, t.tunnel) : (0, L.qi)(t.dsn)
				};
				if (s) {
					var d = JSON.stringify((0, h.pi)((0, h.pi)({
						event_id: e.event_id,
						sent_at: (new Date).toISOString()
					}, r && {
						sdk: r
					}), !!t.tunnel && {
						dsn: (0, f.R)(t.dsn)
					})) + "\n" + JSON.stringify({
						type: i,
						sample_rates: [{
							id: o,
							rate: l
						}]
					}) + "\n" + u.body;
					u.body = d
				}
				return u
			}

			function D(e) {
				var t = [];

				function n(e) {
					return t.splice(t.indexOf(e), 1)[0]
				}
				return {
					$: t,
					add: function(r) {
						if (!(void 0 === e || t.length < e)) return (0, c.$2)(new _.b("Not adding Promise due to buffer limit reached."));
						var i = r();
						return -1 === t.indexOf(i) && t.push(i), i.then((function() {
							return n(i)
						})).then(null, (function() {
							return n(i).then(null, (function() {}))
						})), i
					},
					drain: function(e) {
						return new c.cW((function(n, r) {
							var i = t.length;
							if (!i) return n(!0);
							var s = setTimeout((function() {
								e && e > 0 && n(!1)
							}), e);
							t.forEach((function(e) {
								(0, c.WD)(e).then((function() {
									--i || (clearTimeout(s), n(!0))
								}), r)
							}))
						}))
					}
				}
			}
			var F, O = (0, o.R)();

			function N() {
				if (F) return F;
				if ((0, B.Du)(O.fetch)) return F = O.fetch.bind(O);
				var e = O.document,
					t = O.fetch;
				if (e && "function" === typeof e.createElement) try {
					var n = e.createElement("iframe");
					n.hidden = !0, e.head.appendChild(n);
					var r = n.contentWindow;
					r && r.fetch && (t = r.fetch), e.head.removeChild(n)
				} catch (s) {
					(0, l.c)() && i.k.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", s)
				}
				return F = t.bind(O)
			}

			function H(e, t) {
				if ("[object Navigator]" === Object.prototype.toString.call(O && O.navigator) && "function" === typeof O.navigator.sendBeacon) return O.navigator.sendBeacon.bind(O.navigator)(e, t);
				if ((0, B.Ak)()) {
					var n = N();
					n(e, {
						body: t,
						method: "POST",
						credentials: "omit",
						keepalive: !0
					}).then(null, (function(e) {
						console.error(e)
					}))
				} else;
			}

			function k(e) {
				return "event" === e ? "error" : e
			}
			var G = (0, o.R)(),
				U = function() {
					function e(e) {
						var t = this;
						this.options = e, this._buffer = D(30), this._rateLimits = {}, this._outcomes = {}, this._api = (0, L.hd)(e.dsn, e._metadata, e.tunnel), this.url = (0, L.qi)(this._api.dsn), this.options.sendClientReports && G.document && G.document.addEventListener("visibilitychange", (function() {
							"hidden" === G.document.visibilityState && t._flushOutcomes()
						}))
					}
					return e.prototype.sendEvent = function(e) {
						return this._sendRequest(P(e, this._api), e)
					}, e.prototype.sendSession = function(e) {
						return this._sendRequest(function(e, t) {
							var n = I(t),
								r = "aggregates" in e ? "sessions" : "session";
							return {
								body: JSON.stringify((0, h.pi)((0, h.pi)({
									sent_at: (new Date).toISOString()
								}, n && {
									sdk: n
								}), !!t.tunnel && {
									dsn: (0, f.R)(t.dsn)
								})) + "\n" + JSON.stringify({
									type: r
								}) + "\n" + JSON.stringify(e),
								type: r,
								url: (0, L.Ut)(t.dsn, t.tunnel)
							}
						}(e, this._api), e)
					}, e.prototype.close = function(e) {
						return this._buffer.drain(e)
					}, e.prototype.recordLostEvent = function(e, t) {
						var n;
						if (this.options.sendClientReports) {
							var r = k(t) + ":" + e;
							i.k.log("Adding outcome: " + r), this._outcomes[r] = (null !== (n = this._outcomes[r]) && void 0 !== n ? n : 0) + 1
						}
					}, e.prototype._flushOutcomes = function() {
						if (this.options.sendClientReports) {
							var e = this._outcomes;
							if (this._outcomes = {}, Object.keys(e).length) {
								i.k.log("Flushing outcomes:\n" + JSON.stringify(e, null, 2));
								var t = (0, L.Ut)(this._api.dsn, this._api.tunnel),
									n = JSON.stringify((0, h.pi)({}, this._api.tunnel && {
										dsn: (0, f.R)(this._api.dsn)
									})) + "\n" + JSON.stringify({
										type: "client_report"
									}) + "\n" + JSON.stringify({
										timestamp: (0, v.yW)(),
										discarded_events: Object.keys(e).map((function(t) {
											var n = (0, h.CR)(t.split(":"), 2),
												r = n[0];
											return {
												reason: n[1],
												category: r,
												quantity: e[t]
											}
										}))
									});
								try {
									H(t, n)
								} catch (r) {
									i.k.error(r)
								}
							} else i.k.log("No outcomes to flush")
						}
					}, e.prototype._handleResponse = function(e) {
						var t, n = e.requestType,
							r = e.response,
							s = e.headers,
							a = e.resolve,
							o = e.reject,
							c = (t = r.status) >= 200 && t < 300 ? "success" : 429 === t ? "rate_limit" : t >= 400 && t < 500 ? "invalid" : t >= 500 ? "failed" : "unknown";
						this._handleRateLimit(s) && (0, l.c)() && i.k.warn("Too many " + n + " requests, backing off until: " + this._disabledUntil(n)), "success" !== c ? o(r) : a({
							status: c
						})
					}, e.prototype._disabledUntil = function(e) {
						var t = k(e);
						return this._rateLimits[t] || this._rateLimits.all
					}, e.prototype._isRateLimited = function(e) {
						return this._disabledUntil(e) > new Date(Date.now())
					}, e.prototype._handleRateLimit = function(e) {
						var t, n, r, i, s = Date.now(),
							a = e["x-sentry-rate-limits"],
							o = e["retry-after"];
						if (a) {
							try {
								for (var l = (0, h.XA)(a.trim().split(",")), c = l.next(); !c.done; c = l.next()) {
									var u = c.value.split(":", 2),
										d = parseInt(u[0], 10),
										p = 1e3 * (isNaN(d) ? 60 : d);
									try {
										for (var f = (r = void 0, (0, h.XA)(u[1].split(";"))), g = f.next(); !g.done; g = f.next()) {
											var v = g.value;
											this._rateLimits[v || "all"] = new Date(s + p)
										}
									} catch (y) {
										r = {
											error: y
										}
									} finally {
										try {
											g && !g.done && (i = f.return) && i.call(f)
										} finally {
											if (r) throw r.error
										}
									}
								}
							} catch (x) {
								t = {
									error: x
								}
							} finally {
								try {
									c && !c.done && (n = l.return) && n.call(l)
								} finally {
									if (t) throw t.error
								}
							}
							return !0
						}
						return !!o && (this._rateLimits.all = new Date(s + (0, m.JY)(s, o)), !0)
					}, e
				}(),
				z = function(e) {
					function t(t, n) {
						void 0 === n && (n = N());
						var r = e.call(this, t) || this;
						return r._fetch = n, r
					}
					return (0, h.ZT)(t, e), t.prototype._sendRequest = function(e, t) {
						var n = this;
						if (this._isRateLimited(e.type)) return this.recordLostEvent("ratelimit_backoff", e.type), Promise.reject({
							event: t,
							type: e.type,
							reason: "Transport for " + e.type + " requests locked till " + this._disabledUntil(e.type) + " due to too many requests.",
							status: 429
						});
						var r = {
							body: e.body,
							method: "POST",
							referrerPolicy: (0, B.hv)() ? "origin" : ""
						};
						return void 0 !== this.options.fetchParameters && Object.assign(r, this.options.fetchParameters), void 0 !== this.options.headers && (r.headers = this.options.headers), this._buffer.add((function() {
							return new c.cW((function(t, i) {
								n._fetch(e.url, r).then((function(r) {
									var s = {
										"x-sentry-rate-limits": r.headers.get("X-Sentry-Rate-Limits"),
										"retry-after": r.headers.get("Retry-After")
									};
									n._handleResponse({
										requestType: e.type,
										response: r,
										headers: s,
										resolve: t,
										reject: i
									})
								})).catch(i)
							}))
						})).then(void 0, (function(t) {
							throw t instanceof _.b ? n.recordLostEvent("queue_overflow", e.type) : n.recordLostEvent("network_error", e.type), t
						}))
					}, t
				}(U),
				V = function(e) {
					function t() {
						return null !== e && e.apply(this, arguments) || this
					}
					return (0, h.ZT)(t, e), t.prototype._sendRequest = function(e, t) {
						var n = this;
						return this._isRateLimited(e.type) ? (this.recordLostEvent("ratelimit_backoff", e.type), Promise.reject({
							event: t,
							type: e.type,
							reason: "Transport for " + e.type + " requests locked till " + this._disabledUntil(e.type) + " due to too many requests.",
							status: 429
						})) : this._buffer.add((function() {
							return new c.cW((function(t, r) {
								var i = new XMLHttpRequest;
								for (var s in i.onreadystatechange = function() {
										if (4 === i.readyState) {
											var s = {
												"x-sentry-rate-limits": i.getResponseHeader("X-Sentry-Rate-Limits"),
												"retry-after": i.getResponseHeader("Retry-After")
											};
											n._handleResponse({
												requestType: e.type,
												response: i,
												headers: s,
												resolve: t,
												reject: r
											})
										}
									}, i.open("POST", e.url), n.options.headers) Object.prototype.hasOwnProperty.call(n.options.headers, s) && i.setRequestHeader(s, n.options.headers[s]);
								i.send(e.body)
							}))
						})).then(void 0, (function(t) {
							throw t instanceof _.b ? n.recordLostEvent("queue_overflow", e.type) : n.recordLostEvent("network_error", e.type), t
						}))
					}, t
				}(U),
				W = function(e) {
					function t() {
						return null !== e && e.apply(this, arguments) || this
					}
					return (0, h.ZT)(t, e), t.prototype.eventFromException = function(e, t) {
						return (0, R.dr)(this._options, e, t)
					}, t.prototype.eventFromMessage = function(e, t, n) {
						return void 0 === t && (t = C.z.Info), (0, R.aB)(this._options, e, t, n)
					}, t.prototype._setupTransport = function() {
						if (!this._options.dsn) return e.prototype._setupTransport.call(this);
						var t = (0, h.pi)((0, h.pi)({}, this._options.transportOptions), {
							dsn: this._options.dsn,
							tunnel: this._options.tunnel,
							sendClientReports: this._options.sendClientReports,
							_metadata: this._options._metadata
						});
						return this._options.transport ? new this._options.transport(t) : (0, B.Ak)() ? new z(t) : new V(t)
					}, t
				}(T),
				j = n(6891),
				J = n(1861),
				X = function(e) {
					function t(t) {
						void 0 === t && (t = {});
						return t._metadata = t._metadata || {}, t._metadata.sdk = t._metadata.sdk || {
							name: "sentry.javascript.browser",
							packages: [{
								name: "npm:@sentry/browser",
								version: d.J
							}],
							version: d.J
						}, e.call(this, W, t) || this
					}
					return (0, h.ZT)(t, e), t.prototype.showReportDialog = function(e) {
						void 0 === e && (e = {}), (0, o.R)().document && (this._isEnabled() ? (0, j.BS)((0, h.pi)((0, h.pi)({}, e), {
							dsn: e.dsn || this.getDsn()
						})) : i.k.error("Trying to call showReportDialog with Sentry Client disabled"))
					}, t.prototype._prepareEvent = function(t, n, r) {
						return t.platform = t.platform || "javascript", e.prototype._prepareEvent.call(this, t, n, r)
					}, t.prototype._sendEvent = function(t) {
						var n = this.getIntegration(J.O);
						n && n.addSentryBreadcrumb(t), e.prototype._sendEvent.call(this, t)
					}, t
				}(S),
				q = n(3692),
				K = n(2136),
				Y = n(1634),
				Q = n(9730),
				Z = n(3931),
				$ = [new s.Q, new a.c, new q.p, new J.O, new K.d, new Y.iP, new Q.I, new Z.Z];

			function ee(e) {
				if (void 0 === e && (e = {}), void 0 === e.defaultIntegrations && (e.defaultIntegrations = $), void 0 === e.release) {
					var t = (0, o.R)();
					t.SENTRY_RELEASE && t.SENTRY_RELEASE.id && (e.release = t.SENTRY_RELEASE.id)
				}
				void 0 === e.autoSessionTracking && (e.autoSessionTracking = !0), void 0 === e.sendClientReports && (e.sendClientReports = !0),
					function(e, t) {
						!0 === t.debug && i.k.enable();
						var n = (0, r.Gd)(),
							s = n.getScope();
						s && s.update(t.initialScope);
						var a = new e(t);
						n.bindClient(a)
					}(X, e), e.autoSessionTracking && function() {
						if ("undefined" === typeof(0, o.R)().document) return void((0, l.c)() && i.k.warn("Session tracking in non-browser environment with @sentry/browser is not supported."));
						var e = (0, r.Gd)();
						if (!e.captureSession) return;
						ne(e), (0, u.o)("history", (function(e) {
							var t = e.from,
								n = e.to;
							void 0 !== t && t !== n && ne((0, r.Gd)())
						}))
					}()
			}

			function te(e) {
				var t = (0, r.Gd)().getClient();
				return t ? t.flush(e) : ((0, l.c)() && i.k.warn("Cannot flush events. No client defined."), (0, c.WD)(!1))
			}

			function ne(e) {
				e.startSession({
					ignoreDuration: !0
				}), e.captureSession()
			}
		},
		7873: function(e, t, n) {
			"use strict";
			n.d(t, {
				_: function() {
					return h
				}
			});
			var r = n(655),
				i = "?",
				s = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
				a = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
				o = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
				l = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
				c = /\((\S*)(?::(\d+))(?::(\d+))\)/,
				u = /Minified React error #\d+;/i;

			function h(e) {
				var t = null,
					n = 0;
				e && ("number" === typeof e.framesToPop ? n = e.framesToPop : u.test(e.message) && (n = 1));
				try {
					if (t = function(e) {
							if (!e || !e.stacktrace) return null;
							for (var t, n = e.stacktrace, r = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i, s = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\((.*)\))? in (.*):\s*$/i, a = n.split("\n"), o = [], l = 0; l < a.length; l += 2) {
								var c = null;
								(t = r.exec(a[l])) ? c = {
									url: t[2],
									func: t[3],
									args: [],
									line: +t[1],
									column: null
								}: (t = s.exec(a[l])) && (c = {
									url: t[6],
									func: t[3] || t[4],
									args: t[5] ? t[5].split(",") : [],
									line: +t[1],
									column: +t[2]
								}), c && (!c.func && c.line && (c.func = i), o.push(c))
							}
							if (!o.length) return null;
							return {
								message: f(e),
								name: e.name,
								stack: o
							}
						}(e)) return p(t, n)
				} catch (h) {}
				try {
					if (t = function(e) {
							var t, n;
							if (!e || !e.stack) return null;
							for (var u, h, p, m = [], g = e.stack.split("\n"), v = 0; v < g.length; ++v) {
								if (h = s.exec(g[v])) {
									var y = h[2] && 0 === h[2].indexOf("native");
									h[2] && 0 === h[2].indexOf("eval") && (u = c.exec(h[2])) && (h[2] = u[1], h[3] = u[2], h[4] = u[3]);
									var x = h[2] && 0 === h[2].indexOf("address at ") ? h[2].substr("address at ".length) : h[2],
										_ = h[1] || i;
									_ = (t = (0, r.CR)(d(_, x), 2))[0], p = {
										url: x = t[1],
										func: _,
										args: y ? [h[2]] : [],
										line: h[3] ? +h[3] : null,
										column: h[4] ? +h[4] : null
									}
								} else if (h = o.exec(g[v])) p = {
									url: h[2],
									func: h[1] || i,
									args: [],
									line: +h[3],
									column: h[4] ? +h[4] : null
								};
								else {
									if (!(h = a.exec(g[v]))) continue;
									h[3] && h[3].indexOf(" > eval") > -1 && (u = l.exec(h[3])) ? (h[1] = h[1] || "eval", h[3] = u[1], h[4] = u[2], h[5] = "") : 0 !== v || h[5] || void 0 === e.columnNumber || (m[0].column = e.columnNumber + 1);
									x = h[3], _ = h[1] || i;
									_ = (n = (0, r.CR)(d(_, x), 2))[0], p = {
										url: x = n[1],
										func: _,
										args: h[2] ? h[2].split(",") : [],
										line: h[4] ? +h[4] : null,
										column: h[5] ? +h[5] : null
									}
								}!p.func && p.line && (p.func = i), m.push(p)
							}
							if (!m.length) return null;
							return {
								message: f(e),
								name: e.name,
								stack: m
							}
						}(e)) return p(t, n)
				} catch (h) {}
				return {
					message: f(e),
					name: e && e.name,
					stack: [],
					failed: !0
				}
			}
			var d = function(e, t) {
				var n = -1 !== e.indexOf("safari-extension"),
					r = -1 !== e.indexOf("safari-web-extension");
				return n || r ? [-1 !== e.indexOf("@") ? e.split("@")[0] : i, n ? "safari-extension:" + t : "safari-web-extension:" + t] : [e, t]
			};

			function p(e, t) {
				try {
					return (0, r.pi)((0, r.pi)({}, e), {
						stack: e.stack.slice(t)
					})
				} catch (n) {
					return e
				}
			}

			function f(e) {
				var t = e && e.message;
				return t ? t.error && "string" === typeof t.error.message ? t.error.message : t : "No error message"
			}
		},
		1984: function(e, t, n) {
			"use strict";
			n.d(t, {
				hd: function() {
					return s
				},
				qi: function() {
					return u
				},
				Ut: function() {
					return h
				},
				hR: function() {
					return d
				}
			});
			var r = n(292),
				i = n(8252);
			! function() {
				function e(e, t, n) {
					void 0 === t && (t = {}), this.dsn = e, this._dsnObject = (0, r.v)(e), this.metadata = t, this._tunnel = n
				}
				e.prototype.getDsn = function() {
					return this._dsnObject
				}, e.prototype.forceEnvelope = function() {
					return !!this._tunnel
				}, e.prototype.getBaseApiEndpoint = function() {
					return a(this._dsnObject)
				}, e.prototype.getStoreEndpoint = function() {
					return c(this._dsnObject)
				}, e.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
					return u(this._dsnObject)
				}, e.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
					return h(this._dsnObject, this._tunnel)
				}
			}();

			function s(e, t, n) {
				return {
					initDsn: e,
					metadata: t || {},
					dsn: (0, r.v)(e),
					tunnel: n
				}
			}

			function a(e) {
				var t = e.protocol ? e.protocol + ":" : "",
					n = e.port ? ":" + e.port : "";
				return t + "//" + e.host + n + (e.path ? "/" + e.path : "") + "/api/"
			}

			function o(e, t) {
				return "" + a(e) + e.projectId + "/" + t + "/"
			}

			function l(e) {
				return (0, i._j)({
					sentry_key: e.publicKey,
					sentry_version: "7"
				})
			}

			function c(e) {
				return o(e, "store")
			}

			function u(e) {
				return c(e) + "?" + l(e)
			}

			function h(e, t) {
				return t || function(e) {
					return o(e, "envelope")
				}(e) + "?" + l(e)
			}

			function d(e, t) {
				var n = (0, r.v)(e),
					i = a(n) + "embed/error-page/",
					s = "dsn=" + (0, r.R)(n);
				for (var o in t)
					if ("dsn" !== o)
						if ("user" === o) {
							if (!t.user) continue;
							t.user.name && (s += "&name=" + encodeURIComponent(t.user.name)), t.user.email && (s += "&email=" + encodeURIComponent(t.user.email))
						} else s += "&" + encodeURIComponent(o) + "=" + encodeURIComponent(t[o]);
				return i + "?" + s
			}
		},
		9116: function(e, t, n) {
			"use strict";
			n.d(t, {
				c: function() {
					return s
				}
			});
			var r, i = n(8252),
				s = function() {
					function e() {
						this.name = e.id
					}
					return e.prototype.setupOnce = function() {
						r = Function.prototype.toString, Function.prototype.toString = function() {
							for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
							var n = (0, i.HK)(this) || this;
							return r.apply(n, e)
						}
					}, e.id = "FunctionToString", e
				}()
		},
		2422: function(e, t, n) {
			"use strict";
			n.d(t, {
				Q: function() {
					return h
				}
			});
			var r = n(655),
				i = n(6769),
				s = n(9472),
				a = n(8518),
				o = n(2343),
				l = n(2844),
				c = n(7321),
				u = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/],
				h = function() {
					function e(t) {
						void 0 === t && (t = {}), this._options = t, this.name = e.id
					}
					return e.prototype.setupOnce = function() {
						(0, i.c)((function(t) {
							var n = (0, s.Gd)();
							if (!n) return t;
							var r = n.getIntegration(e);
							if (r) {
								var i = n.getClient(),
									a = i ? i.getOptions() : {},
									o = "function" === typeof r._mergeOptions ? r._mergeOptions(a) : {};
								return "function" !== typeof r._shouldDropEvent ? t : r._shouldDropEvent(t, o) ? null : t
							}
							return t
						}))
					}, e.prototype._shouldDropEvent = function(e, t) {
						return this._isSentryError(e, t) ? ((0, a.c)() && o.k.warn("Event dropped due to being internal Sentry Error.\nEvent: " + (0, l.jH)(e)), !0) : this._isIgnoredError(e, t) ? ((0, a.c)() && o.k.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + (0, l.jH)(e)), !0) : this._isDeniedUrl(e, t) ? ((0, a.c)() && o.k.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + (0, l.jH)(e) + ".\nUrl: " + this._getEventFilterUrl(e)), !0) : !this._isAllowedUrl(e, t) && ((0, a.c)() && o.k.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + (0, l.jH)(e) + ".\nUrl: " + this._getEventFilterUrl(e)), !0)
					}, e.prototype._isSentryError = function(e, t) {
						if (!t.ignoreInternal) return !1;
						try {
							return "SentryError" === e.exception.values[0].type
						} catch (n) {}
						return !1
					}, e.prototype._isIgnoredError = function(e, t) {
						return !(!t.ignoreErrors || !t.ignoreErrors.length) && this._getPossibleEventMessages(e).some((function(e) {
							return t.ignoreErrors.some((function(t) {
								return (0, c.zC)(e, t)
							}))
						}))
					}, e.prototype._isDeniedUrl = function(e, t) {
						if (!t.denyUrls || !t.denyUrls.length) return !1;
						var n = this._getEventFilterUrl(e);
						return !!n && t.denyUrls.some((function(e) {
							return (0, c.zC)(n, e)
						}))
					}, e.prototype._isAllowedUrl = function(e, t) {
						if (!t.allowUrls || !t.allowUrls.length) return !0;
						var n = this._getEventFilterUrl(e);
						return !n || t.allowUrls.some((function(e) {
							return (0, c.zC)(n, e)
						}))
					}, e.prototype._mergeOptions = function(e) {
						return void 0 === e && (e = {}), {
							allowUrls: (0, r.fl)(this._options.whitelistUrls || [], this._options.allowUrls || [], e.whitelistUrls || [], e.allowUrls || []),
							denyUrls: (0, r.fl)(this._options.blacklistUrls || [], this._options.denyUrls || [], e.blacklistUrls || [], e.denyUrls || []),
							ignoreErrors: (0, r.fl)(this._options.ignoreErrors || [], e.ignoreErrors || [], u),
							ignoreInternal: "undefined" === typeof this._options.ignoreInternal || this._options.ignoreInternal
						}
					}, e.prototype._getPossibleEventMessages = function(e) {
						if (e.message) return [e.message];
						if (e.exception) try {
							var t = e.exception.values && e.exception.values[0] || {},
								n = t.type,
								r = void 0 === n ? "" : n,
								i = t.value,
								s = void 0 === i ? "" : i;
							return ["" + s, r + ": " + s]
						} catch (c) {
							return (0, a.c)() && o.k.error("Cannot extract message for event " + (0, l.jH)(e)), []
						}
						return []
					}, e.prototype._getLastValidUrl = function(e) {
						void 0 === e && (e = []);
						for (var t = e.length - 1; t >= 0; t--) {
							var n = e[t];
							if (n && "<anonymous>" !== n.filename && "[native code]" !== n.filename) return n.filename || null
						}
						return null
					}, e.prototype._getEventFilterUrl = function(e) {
						try {
							if (e.stacktrace) return this._getLastValidUrl(e.stacktrace.frames);
							var t;
							try {
								t = e.exception.values[0].stacktrace.frames
							} catch (n) {}
							return t ? this._getLastValidUrl(t) : null
						} catch (r) {
							return (0, a.c)() && o.k.error("Cannot extract url for event " + (0, l.jH)(e)), null
						}
					}, e.id = "InboundFilters", e
				}()
		},
		105: function(e, t, n) {
			"use strict";
			n.d(t, {
				J: function() {
					return r
				}
			});
			var r = "6.17.4"
		},
		9472: function(e, t, n) {
			"use strict";
			n.d(t, {
				Xb: function() {
					return d
				},
				Gd: function() {
					return m
				},
				cu: function() {
					return p
				}
			});
			var r = n(655),
				i = n(2844),
				s = n(1170),
				a = n(2343),
				o = n(2991),
				l = n(1422),
				c = n(6769),
				u = n(8252),
				h = function() {
					function e(e) {
						this.errors = 0, this.sid = (0, i.DM)(), this.duration = 0, this.status = "ok", this.init = !0, this.ignoreDuration = !1;
						var t = (0, s.ph)();
						this.timestamp = t, this.started = t, e && this.update(e)
					}
					return e.prototype.update = function(e) {
						if (void 0 === e && (e = {}), e.user && (!this.ipAddress && e.user.ip_address && (this.ipAddress = e.user.ip_address), this.did || e.did || (this.did = e.user.id || e.user.email || e.user.username)), this.timestamp = e.timestamp || (0, s.ph)(), e.ignoreDuration && (this.ignoreDuration = e.ignoreDuration), e.sid && (this.sid = 32 === e.sid.length ? e.sid : (0, i.DM)()), void 0 !== e.init && (this.init = e.init), !this.did && e.did && (this.did = "" + e.did), "number" === typeof e.started && (this.started = e.started), this.ignoreDuration) this.duration = void 0;
						else if ("number" === typeof e.duration) this.duration = e.duration;
						else {
							var t = this.timestamp - this.started;
							this.duration = t >= 0 ? t : 0
						}
						e.release && (this.release = e.release), e.environment && (this.environment = e.environment), !this.ipAddress && e.ipAddress && (this.ipAddress = e.ipAddress), !this.userAgent && e.userAgent && (this.userAgent = e.userAgent), "number" === typeof e.errors && (this.errors = e.errors), e.status && (this.status = e.status)
					}, e.prototype.close = function(e) {
						e ? this.update({
							status: e
						}) : "ok" === this.status ? this.update({
							status: "exited"
						}) : this.update()
					}, e.prototype.toJSON = function() {
						return (0, u.Jr)({
							sid: "" + this.sid,
							init: this.init,
							started: new Date(1e3 * this.started).toISOString(),
							timestamp: new Date(1e3 * this.timestamp).toISOString(),
							status: this.status,
							errors: this.errors,
							did: "number" === typeof this.did || "string" === typeof this.did ? "" + this.did : void 0,
							duration: this.duration,
							attrs: {
								release: this.release,
								environment: this.environment,
								ip_address: this.ipAddress,
								user_agent: this.userAgent
							}
						})
					}, e
				}(),
				d = function() {
					function e(e, t, n) {
						void 0 === t && (t = new c.s), void 0 === n && (n = 4), this._version = n, this._stack = [{}], this.getStackTop().scope = t, e && this.bindClient(e)
					}
					return e.prototype.isOlderThan = function(e) {
						return this._version < e
					}, e.prototype.bindClient = function(e) {
						this.getStackTop().client = e, e && e.setupIntegrations && e.setupIntegrations()
					}, e.prototype.pushScope = function() {
						var e = c.s.clone(this.getScope());
						return this.getStack().push({
							client: this.getClient(),
							scope: e
						}), e
					}, e.prototype.popScope = function() {
						return !(this.getStack().length <= 1) && !!this.getStack().pop()
					}, e.prototype.withScope = function(e) {
						var t = this.pushScope();
						try {
							e(t)
						} finally {
							this.popScope()
						}
					}, e.prototype.getClient = function() {
						return this.getStackTop().client
					}, e.prototype.getScope = function() {
						return this.getStackTop().scope
					}, e.prototype.getStack = function() {
						return this._stack
					}, e.prototype.getStackTop = function() {
						return this._stack[this._stack.length - 1]
					}, e.prototype.captureException = function(e, t) {
						var n = this._lastEventId = (0, i.DM)(),
							s = t;
						if (!t) {
							var a = void 0;
							try {
								throw new Error("Sentry syntheticException")
							} catch (e) {
								a = e
							}
							s = {
								originalException: e,
								syntheticException: a
							}
						}
						return this._invokeClient("captureException", e, (0, r.pi)((0, r.pi)({}, s), {
							event_id: n
						})), n
					}, e.prototype.captureMessage = function(e, t, n) {
						var s = this._lastEventId = (0, i.DM)(),
							a = n;
						if (!n) {
							var o = void 0;
							try {
								throw new Error(e)
							} catch (l) {
								o = l
							}
							a = {
								originalException: e,
								syntheticException: o
							}
						}
						return this._invokeClient("captureMessage", e, t, (0, r.pi)((0, r.pi)({}, a), {
							event_id: s
						})), s
					}, e.prototype.captureEvent = function(e, t) {
						var n = (0, i.DM)();
						return "transaction" !== e.type && (this._lastEventId = n), this._invokeClient("captureEvent", e, (0, r.pi)((0, r.pi)({}, t), {
							event_id: n
						})), n
					}, e.prototype.lastEventId = function() {
						return this._lastEventId
					}, e.prototype.addBreadcrumb = function(e, t) {
						var n = this.getStackTop(),
							i = n.scope,
							o = n.client;
						if (i && o) {
							var l = o.getOptions && o.getOptions() || {},
								c = l.beforeBreadcrumb,
								u = void 0 === c ? null : c,
								h = l.maxBreadcrumbs,
								d = void 0 === h ? 100 : h;
							if (!(d <= 0)) {
								var p = (0, s.yW)(),
									f = (0, r.pi)({
										timestamp: p
									}, e),
									m = u ? (0, a.C)((function() {
										return u(f, t)
									})) : f;
								null !== m && i.addBreadcrumb(m, d)
							}
						}
					}, e.prototype.setUser = function(e) {
						var t = this.getScope();
						t && t.setUser(e)
					}, e.prototype.setTags = function(e) {
						var t = this.getScope();
						t && t.setTags(e)
					}, e.prototype.setExtras = function(e) {
						var t = this.getScope();
						t && t.setExtras(e)
					}, e.prototype.setTag = function(e, t) {
						var n = this.getScope();
						n && n.setTag(e, t)
					}, e.prototype.setExtra = function(e, t) {
						var n = this.getScope();
						n && n.setExtra(e, t)
					}, e.prototype.setContext = function(e, t) {
						var n = this.getScope();
						n && n.setContext(e, t)
					}, e.prototype.configureScope = function(e) {
						var t = this.getStackTop(),
							n = t.scope,
							r = t.client;
						n && r && e(n)
					}, e.prototype.run = function(e) {
						var t = f(this);
						try {
							e(this)
						} finally {
							f(t)
						}
					}, e.prototype.getIntegration = function(e) {
						var t = this.getClient();
						if (!t) return null;
						try {
							return t.getIntegration(e)
						} catch (n) {
							return a.k.warn("Cannot retrieve integration " + e.id + " from the current Hub"), null
						}
					}, e.prototype.startSpan = function(e) {
						return this._callExtensionMethod("startSpan", e)
					}, e.prototype.startTransaction = function(e, t) {
						return this._callExtensionMethod("startTransaction", e, t)
					}, e.prototype.traceHeaders = function() {
						return this._callExtensionMethod("traceHeaders")
					}, e.prototype.captureSession = function(e) {
						if (void 0 === e && (e = !1), e) return this.endSession();
						this._sendSessionUpdate()
					}, e.prototype.endSession = function() {
						var e = this.getStackTop(),
							t = e && e.scope,
							n = t && t.getSession();
						n && n.close(), this._sendSessionUpdate(), t && t.setSession()
					}, e.prototype.startSession = function(e) {
						var t = this.getStackTop(),
							n = t.scope,
							i = t.client,
							s = i && i.getOptions() || {},
							a = s.release,
							l = s.environment,
							c = ((0, o.R)().navigator || {}).userAgent,
							u = new h((0, r.pi)((0, r.pi)((0, r.pi)({
								release: a,
								environment: l
							}, n && {
								user: n.getUser()
							}), c && {
								userAgent: c
							}), e));
						if (n) {
							var d = n.getSession && n.getSession();
							d && "ok" === d.status && d.update({
								status: "exited"
							}), this.endSession(), n.setSession(u)
						}
						return u
					}, e.prototype._sendSessionUpdate = function() {
						var e = this.getStackTop(),
							t = e.scope,
							n = e.client;
						if (t) {
							var r = t.getSession && t.getSession();
							r && n && n.captureSession && n.captureSession(r)
						}
					}, e.prototype._invokeClient = function(e) {
						for (var t, n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
						var s = this.getStackTop(),
							a = s.scope,
							o = s.client;
						o && o[e] && (t = o)[e].apply(t, (0, r.fl)(n, [a]))
					}, e.prototype._callExtensionMethod = function(e) {
						for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
						var r = p(),
							i = r.__SENTRY__;
						if (i && i.extensions && "function" === typeof i.extensions[e]) return i.extensions[e].apply(this, t);
						a.k.warn("Extension method " + e + " couldn't be found, doing nothing.")
					}, e
				}();

			function p() {
				var e = (0, o.R)();
				return e.__SENTRY__ = e.__SENTRY__ || {
					extensions: {},
					hub: void 0
				}, e
			}

			function f(e) {
				var t = p(),
					n = v(t);
				return y(t, e), n
			}

			function m() {
				var e = p();
				return g(e) && !v(e).isOlderThan(4) || y(e, new d), (0, l.KV)() ? function(e) {
					try {
						var t = p().__SENTRY__,
							n = t && t.extensions && t.extensions.domain && t.extensions.domain.active;
						if (!n) return v(e);
						if (!g(n) || v(n).isOlderThan(4)) {
							var r = v(e).getStackTop();
							y(n, new d(r.client, c.s.clone(r.scope)))
						}
						return v(n)
					} catch (i) {
						return v(e)
					}
				}(e) : v(e)
			}

			function g(e) {
				return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
			}

			function v(e) {
				return e && e.__SENTRY__ && e.__SENTRY__.hub || (e.__SENTRY__ = e.__SENTRY__ || {}, e.__SENTRY__.hub = new d), e.__SENTRY__.hub
			}

			function y(e, t) {
				return !!e && (e.__SENTRY__ = e.__SENTRY__ || {}, e.__SENTRY__.hub = t, !0)
			}
		},
		6769: function(e, t, n) {
			"use strict";
			n.d(t, {
				s: function() {
					return l
				},
				c: function() {
					return u
				}
			});
			var r = n(655),
				i = n(7597),
				s = n(1170),
				a = n(6893),
				o = n(2991),
				l = function() {
					function e() {
						this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
					}
					return e.clone = function(t) {
						var n = new e;
						return t && (n._breadcrumbs = (0, r.fl)(t._breadcrumbs), n._tags = (0, r.pi)({}, t._tags), n._extra = (0, r.pi)({}, t._extra), n._contexts = (0, r.pi)({}, t._contexts), n._user = t._user, n._level = t._level, n._span = t._span, n._session = t._session, n._transactionName = t._transactionName, n._fingerprint = t._fingerprint, n._eventProcessors = (0, r.fl)(t._eventProcessors), n._requestSession = t._requestSession), n
					}, e.prototype.addScopeListener = function(e) {
						this._scopeListeners.push(e)
					}, e.prototype.addEventProcessor = function(e) {
						return this._eventProcessors.push(e), this
					}, e.prototype.setUser = function(e) {
						return this._user = e || {}, this._session && this._session.update({
							user: e
						}), this._notifyScopeListeners(), this
					}, e.prototype.getUser = function() {
						return this._user
					}, e.prototype.getRequestSession = function() {
						return this._requestSession
					}, e.prototype.setRequestSession = function(e) {
						return this._requestSession = e, this
					}, e.prototype.setTags = function(e) {
						return this._tags = (0, r.pi)((0, r.pi)({}, this._tags), e), this._notifyScopeListeners(), this
					}, e.prototype.setTag = function(e, t) {
						var n;
						return this._tags = (0, r.pi)((0, r.pi)({}, this._tags), ((n = {})[e] = t, n)), this._notifyScopeListeners(), this
					}, e.prototype.setExtras = function(e) {
						return this._extra = (0, r.pi)((0, r.pi)({}, this._extra), e), this._notifyScopeListeners(), this
					}, e.prototype.setExtra = function(e, t) {
						var n;
						return this._extra = (0, r.pi)((0, r.pi)({}, this._extra), ((n = {})[e] = t, n)), this._notifyScopeListeners(), this
					}, e.prototype.setFingerprint = function(e) {
						return this._fingerprint = e, this._notifyScopeListeners(), this
					}, e.prototype.setLevel = function(e) {
						return this._level = e, this._notifyScopeListeners(), this
					}, e.prototype.setTransactionName = function(e) {
						return this._transactionName = e, this._notifyScopeListeners(), this
					}, e.prototype.setTransaction = function(e) {
						return this.setTransactionName(e)
					}, e.prototype.setContext = function(e, t) {
						var n;
						return null === t ? delete this._contexts[e] : this._contexts = (0, r.pi)((0, r.pi)({}, this._contexts), ((n = {})[e] = t, n)), this._notifyScopeListeners(), this
					}, e.prototype.setSpan = function(e) {
						return this._span = e, this._notifyScopeListeners(), this
					}, e.prototype.getSpan = function() {
						return this._span
					}, e.prototype.getTransaction = function() {
						var e = this.getSpan();
						return e && e.transaction
					}, e.prototype.setSession = function(e) {
						return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
					}, e.prototype.getSession = function() {
						return this._session
					}, e.prototype.update = function(t) {
						if (!t) return this;
						if ("function" === typeof t) {
							var n = t(this);
							return n instanceof e ? n : this
						}
						return t instanceof e ? (this._tags = (0, r.pi)((0, r.pi)({}, this._tags), t._tags), this._extra = (0, r.pi)((0, r.pi)({}, this._extra), t._extra), this._contexts = (0, r.pi)((0, r.pi)({}, this._contexts), t._contexts), t._user && Object.keys(t._user).length && (this._user = t._user), t._level && (this._level = t._level), t._fingerprint && (this._fingerprint = t._fingerprint), t._requestSession && (this._requestSession = t._requestSession)) : (0, i.PO)(t) && (t = t, this._tags = (0, r.pi)((0, r.pi)({}, this._tags), t.tags), this._extra = (0, r.pi)((0, r.pi)({}, this._extra), t.extra), this._contexts = (0, r.pi)((0, r.pi)({}, this._contexts), t.contexts), t.user && (this._user = t.user), t.level && (this._level = t.level), t.fingerprint && (this._fingerprint = t.fingerprint), t.requestSession && (this._requestSession = t.requestSession)), this
					}, e.prototype.clear = function() {
						return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this
					}, e.prototype.addBreadcrumb = function(e, t) {
						var n = "number" === typeof t ? Math.min(t, 100) : 100;
						if (n <= 0) return this;
						var i = (0, r.pi)({
							timestamp: (0, s.yW)()
						}, e);
						return this._breadcrumbs = (0, r.fl)(this._breadcrumbs, [i]).slice(-n), this._notifyScopeListeners(), this
					}, e.prototype.clearBreadcrumbs = function() {
						return this._breadcrumbs = [], this._notifyScopeListeners(), this
					}, e.prototype.applyToEvent = function(e, t) {
						if (this._extra && Object.keys(this._extra).length && (e.extra = (0, r.pi)((0, r.pi)({}, this._extra), e.extra)), this._tags && Object.keys(this._tags).length && (e.tags = (0, r.pi)((0, r.pi)({}, this._tags), e.tags)), this._user && Object.keys(this._user).length && (e.user = (0, r.pi)((0, r.pi)({}, this._user), e.user)), this._contexts && Object.keys(this._contexts).length && (e.contexts = (0, r.pi)((0, r.pi)({}, this._contexts), e.contexts)), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
							e.contexts = (0, r.pi)({
								trace: this._span.getTraceContext()
							}, e.contexts);
							var n = this._span.transaction && this._span.transaction.name;
							n && (e.tags = (0, r.pi)({
								transaction: n
							}, e.tags))
						}
						return this._applyFingerprint(e), e.breadcrumbs = (0, r.fl)(e.breadcrumbs || [], this._breadcrumbs), e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = this._sdkProcessingMetadata, this._notifyEventProcessors((0, r.fl)(c(), this._eventProcessors), e, t)
					}, e.prototype.setSDKProcessingMetadata = function(e) {
						return this._sdkProcessingMetadata = (0, r.pi)((0, r.pi)({}, this._sdkProcessingMetadata), e), this
					}, e.prototype._notifyEventProcessors = function(e, t, n, s) {
						var o = this;
						return void 0 === s && (s = 0), new a.cW((function(a, l) {
							var c = e[s];
							if (null === t || "function" !== typeof c) a(t);
							else {
								var u = c((0, r.pi)({}, t), n);
								(0, i.J8)(u) ? u.then((function(t) {
									return o._notifyEventProcessors(e, t, n, s + 1).then(a)
								})).then(null, l): o._notifyEventProcessors(e, u, n, s + 1).then(a).then(null, l)
							}
						}))
					}, e.prototype._notifyScopeListeners = function() {
						var e = this;
						this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((function(t) {
							t(e)
						})), this._notifyingListeners = !1)
					}, e.prototype._applyFingerprint = function(e) {
						e.fingerprint = e.fingerprint ? Array.isArray(e.fingerprint) ? e.fingerprint : [e.fingerprint] : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
					}, e
				}();

			function c() {
				var e = (0, o.R)();
				return e.__SENTRY__ = e.__SENTRY__ || {}, e.__SENTRY__.globalEventProcessors = e.__SENTRY__.globalEventProcessors || [], e.__SENTRY__.globalEventProcessors
			}

			function u(e) {
				c().push(e)
			}
		},
		9666: function(e, t, n) {
			"use strict";
			n.d(t, {
				Tb: function() {
					return a
				},
				e: function() {
					return o
				},
				$e: function() {
					return l
				}
			});
			var r = n(655),
				i = n(9472);

			function s(e) {
				for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
				var s = (0, i.Gd)();
				if (s && s[e]) return s[e].apply(s, (0, r.fl)(t));
				throw new Error("No hub defined or " + e + " was not found on the hub, please open a bug report.")
			}

			function a(e, t) {
				var n;
				try {
					throw new Error("Sentry syntheticException")
				} catch (e) {
					n = e
				}
				return s("captureException", e, {
					captureContext: t,
					originalException: e,
					syntheticException: n
				})
			}

			function o(e) {
				s("configureScope", e)
			}

			function l(e) {
				s("withScope", e)
			}
		},
		6257: function(e, t, n) {
			"use strict";
			n.d(t, {
				d: function() {
					return r
				},
				x: function() {
					return i
				}
			});
			var r = "finishReason",
				i = ["heartbeatFailed", "idleTimeout", "documentHidden"]
		},
		2758: function(e, t, n) {
			"use strict";
			n.d(t, {
				ro: function() {
					return g
				},
				lb: function() {
					return m
				}
			});
			var r = n(655),
				i = n(9472),
				s = n(2343),
				a = n(1422),
				o = n(9732),
				l = n(3233);

			function c() {
				var e = (0, l.x1)();
				if (e) {
					var t = "internal_error";
					s.k.log("[Tracing] Transaction: " + t + " -> Global error occured"), e.setStatus(t)
				}
			}
			var u = n(6458),
				h = n(3391);

			function d() {
				var e = this.getScope();
				if (e) {
					var t = e.getSpan();
					if (t) return {
						"sentry-trace": t.toTraceparent()
					}
				}
				return {}
			}

			function p(e, t, n) {
				return (0, l.zu)(t) ? void 0 !== e.sampled ? (e.setMetadata({
					transactionSampling: {
						method: "explicitly_set"
					}
				}), e) : ("function" === typeof t.tracesSampler ? (r = t.tracesSampler(n), e.setMetadata({
					transactionSampling: {
						method: "client_sampler",
						rate: Number(r)
					}
				})) : void 0 !== n.parentSampled ? (r = n.parentSampled, e.setMetadata({
					transactionSampling: {
						method: "inheritance"
					}
				})) : (r = t.tracesSampleRate, e.setMetadata({
					transactionSampling: {
						method: "client_rate",
						rate: Number(r)
					}
				})), function(e) {
					if (isNaN(e) || "number" !== typeof e && "boolean" !== typeof e) return s.k.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(e) + " of type " + JSON.stringify(typeof e) + "."), !1;
					if (e < 0 || e > 1) return s.k.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + e + "."), !1;
					return !0
				}(r) ? r ? (e.sampled = Math.random() < r, e.sampled ? (s.k.log("[Tracing] starting " + e.op + " transaction - " + e.name), e) : (s.k.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(r) + ")"), e)) : (s.k.log("[Tracing] Discarding transaction because " + ("function" === typeof t.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")), e.sampled = !1, e) : (s.k.warn("[Tracing] Discarding transaction because of invalid sample rate."), e.sampled = !1, e)) : (e.sampled = !1, e);
				var r
			}

			function f(e, t) {
				var n = this.getClient(),
					i = n && n.getOptions() || {},
					s = new h.Y(e, this);
				return (s = p(s, i, (0, r.pi)({
					parentSampled: e.parentSampled,
					transactionContext: e
				}, t))).sampled && s.initSpanRecorder(i._experiments && i._experiments.maxSpans), s
			}

			function m(e, t, n, i, s) {
				var a = e.getClient(),
					o = a && a.getOptions() || {},
					l = new u.io(t, e, n, i);
				return (l = p(l, o, (0, r.pi)({
					parentSampled: t.parentSampled,
					transactionContext: t
				}, s))).sampled && l.initSpanRecorder(o._experiments && o._experiments.maxSpans), l
			}

			function g() {
				! function() {
					var e = (0, i.cu)();
					e.__SENTRY__ && (e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}, e.__SENTRY__.extensions.startTransaction || (e.__SENTRY__.extensions.startTransaction = f), e.__SENTRY__.extensions.traceHeaders || (e.__SENTRY__.extensions.traceHeaders = d))
				}(), (0, a.KV)() && function() {
					var t = (0, i.cu)();
					if (t.__SENTRY__) {
						var n = {
								mongodb: function() {
									return new((0, a.l$)(e, "./integrations/node/mongo").Mongo)
								},
								mongoose: function() {
									return new((0, a.l$)(e, "./integrations/node/mongo").Mongo)({
										mongoose: !0
									})
								},
								mysql: function() {
									return new((0, a.l$)(e, "./integrations/node/mysql").Mysql)
								},
								pg: function() {
									return new((0, a.l$)(e, "./integrations/node/postgres").Postgres)
								}
							},
							s = Object.keys(n).filter((function(e) {
								return !!(0, a.$y)(e)
							})).map((function(e) {
								try {
									return n[e]()
								} catch (t) {
									return
								}
							})).filter((function(e) {
								return e
							}));
						s.length > 0 && (t.__SENTRY__.integrations = (0, r.fl)(t.__SENTRY__.integrations || [], s))
					}
				}(), (0, o.o)("error", c), (0, o.o)("unhandledrejection", c)
			}
			e = n.hmd(e)
		},
		6458: function(e, t, n) {
			"use strict";
			n.d(t, {
				nT: function() {
					return c
				},
				io: function() {
					return h
				}
			});
			var r = n(655),
				i = n(1170),
				s = n(2343),
				a = n(6257),
				o = n(5334),
				l = n(3391),
				c = 1e3,
				u = function(e) {
					function t(t, n, r, i) {
						void 0 === r && (r = "");
						var s = e.call(this, i) || this;
						return s._pushActivity = t, s._popActivity = n, s.transactionSpanId = r, s
					}
					return (0, r.ZT)(t, e), t.prototype.add = function(t) {
						var n = this;
						t.spanId !== this.transactionSpanId && (t.finish = function(e) {
							t.endTimestamp = "number" === typeof e ? e : (0, i._I)(), n._popActivity(t.spanId)
						}, void 0 === t.endTimestamp && this._pushActivity(t.spanId)), e.prototype.add.call(this, t)
					}, t
				}(o.gB),
				h = function(e) {
					function t(t, n, r, i) {
						void 0 === r && (r = c), void 0 === i && (i = !1);
						var a = e.call(this, t, n) || this;
						return a._idleHub = n, a._idleTimeout = r, a._onScope = i, a.activities = {}, a._heartbeatCounter = 0, a._finished = !1, a._beforeFinishCallbacks = [], n && i && (d(n), s.k.log("Setting idle transaction on scope. Span ID: " + a.spanId), n.configureScope((function(e) {
							return e.setSpan(a)
						}))), a._initTimeout = setTimeout((function() {
							a._finished || a.finish()
						}), a._idleTimeout), a
					}
					return (0, r.ZT)(t, e), t.prototype.finish = function(t) {
						var n, a, o = this;
						if (void 0 === t && (t = (0, i._I)()), this._finished = !0, this.activities = {}, this.spanRecorder) {
							s.k.log("[Tracing] finishing IdleTransaction", new Date(1e3 * t).toISOString(), this.op);
							try {
								for (var l = (0, r.XA)(this._beforeFinishCallbacks), c = l.next(); !c.done; c = l.next()) {
									(0, c.value)(this, t)
								}
							} catch (u) {
								n = {
									error: u
								}
							} finally {
								try {
									c && !c.done && (a = l.return) && a.call(l)
								} finally {
									if (n) throw n.error
								}
							}
							this.spanRecorder.spans = this.spanRecorder.spans.filter((function(e) {
								if (e.spanId === o.spanId) return !0;
								e.endTimestamp || (e.endTimestamp = t, e.setStatus("cancelled"), s.k.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(e, void 0, 2)));
								var n = e.startTimestamp < t;
								return n || s.k.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(e, void 0, 2)), n
							})), s.k.log("[Tracing] flushing IdleTransaction")
						} else s.k.log("[Tracing] No active IdleTransaction");
						return this._onScope && d(this._idleHub), e.prototype.finish.call(this, t)
					}, t.prototype.registerBeforeFinishCallback = function(e) {
						this._beforeFinishCallbacks.push(e)
					}, t.prototype.initSpanRecorder = function(e) {
						var t = this;
						if (!this.spanRecorder) {
							this.spanRecorder = new u((function(e) {
								t._finished || t._pushActivity(e)
							}), (function(e) {
								t._finished || t._popActivity(e)
							}), this.spanId, e), s.k.log("Starting heartbeat"), this._pingHeartbeat()
						}
						this.spanRecorder.add(this)
					}, t.prototype._pushActivity = function(e) {
						this._initTimeout && (clearTimeout(this._initTimeout), this._initTimeout = void 0), s.k.log("[Tracing] pushActivity: " + e), this.activities[e] = !0, s.k.log("[Tracing] new activities count", Object.keys(this.activities).length)
					}, t.prototype._popActivity = function(e) {
						var t = this;
						if (this.activities[e] && (s.k.log("[Tracing] popActivity " + e), delete this.activities[e], s.k.log("[Tracing] new activities count", Object.keys(this.activities).length)), 0 === Object.keys(this.activities).length) {
							var n = this._idleTimeout,
								r = (0, i._I)() + n / 1e3;
							setTimeout((function() {
								t._finished || (t.setTag(a.d, a.x[1]), t.finish(r))
							}), n)
						}
					}, t.prototype._beat = function() {
						if (!this._finished) {
							var e = Object.keys(this.activities).join("");
							e === this._prevHeartbeatString ? this._heartbeatCounter += 1 : this._heartbeatCounter = 1, this._prevHeartbeatString = e, this._heartbeatCounter >= 3 ? (s.k.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this.setTag(a.d, a.x[0]), this.finish()) : this._pingHeartbeat()
						}
					}, t.prototype._pingHeartbeat = function() {
						var e = this;
						s.k.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter), setTimeout((function() {
							e._beat()
						}), 5e3)
					}, t
				}(l.Y);

			function d(e) {
				if (e) {
					var t = e.getScope();
					if (t) t.getTransaction() && t.setSpan(void 0)
				}
			}
		},
		5334: function(e, t, n) {
			"use strict";
			n.d(t, {
				gB: function() {
					return o
				},
				Dr: function() {
					return l
				}
			});
			var r = n(655),
				i = n(2844),
				s = n(1170),
				a = n(8252),
				o = function() {
					function e(e) {
						void 0 === e && (e = 1e3), this.spans = [], this._maxlen = e
					}
					return e.prototype.add = function(e) {
						this.spans.length > this._maxlen ? e.spanRecorder = void 0 : this.spans.push(e)
					}, e
				}(),
				l = function() {
					function e(e) {
						if (this.traceId = (0, i.DM)(), this.spanId = (0, i.DM)().substring(16), this.startTimestamp = (0, s._I)(), this.tags = {}, this.data = {}, !e) return this;
						e.traceId && (this.traceId = e.traceId), e.spanId && (this.spanId = e.spanId), e.parentSpanId && (this.parentSpanId = e.parentSpanId), "sampled" in e && (this.sampled = e.sampled), e.op && (this.op = e.op), e.description && (this.description = e.description), e.data && (this.data = e.data), e.tags && (this.tags = e.tags), e.status && (this.status = e.status), e.startTimestamp && (this.startTimestamp = e.startTimestamp), e.endTimestamp && (this.endTimestamp = e.endTimestamp)
					}
					return e.prototype.child = function(e) {
						return this.startChild(e)
					}, e.prototype.startChild = function(t) {
						var n = new e((0, r.pi)((0, r.pi)({}, t), {
							parentSpanId: this.spanId,
							sampled: this.sampled,
							traceId: this.traceId
						}));
						return n.spanRecorder = this.spanRecorder, n.spanRecorder && n.spanRecorder.add(n), n.transaction = this.transaction, n
					}, e.prototype.setTag = function(e, t) {
						var n;
						return this.tags = (0, r.pi)((0, r.pi)({}, this.tags), ((n = {})[e] = t, n)), this
					}, e.prototype.setData = function(e, t) {
						var n;
						return this.data = (0, r.pi)((0, r.pi)({}, this.data), ((n = {})[e] = t, n)), this
					}, e.prototype.setStatus = function(e) {
						return this.status = e, this
					}, e.prototype.setHttpStatus = function(e) {
						this.setTag("http.status_code", String(e));
						var t = function(e) {
							if (e < 400 && e >= 100) return "ok";
							if (e >= 400 && e < 500) switch (e) {
								case 401:
									return "unauthenticated";
								case 403:
									return "permission_denied";
								case 404:
									return "not_found";
								case 409:
									return "already_exists";
								case 413:
									return "failed_precondition";
								case 429:
									return "resource_exhausted";
								default:
									return "invalid_argument"
							}
							if (e >= 500 && e < 600) switch (e) {
								case 501:
									return "unimplemented";
								case 503:
									return "unavailable";
								case 504:
									return "deadline_exceeded";
								default:
									return "internal_error"
							}
							return "unknown_error"
						}(e);
						return "unknown_error" !== t && this.setStatus(t), this
					}, e.prototype.isSuccess = function() {
						return "ok" === this.status
					}, e.prototype.finish = function(e) {
						this.endTimestamp = "number" === typeof e ? e : (0, s._I)()
					}, e.prototype.toTraceparent = function() {
						var e = "";
						return void 0 !== this.sampled && (e = this.sampled ? "-1" : "-0"), this.traceId + "-" + this.spanId + e
					}, e.prototype.toContext = function() {
						return (0, a.Jr)({
							data: this.data,
							description: this.description,
							endTimestamp: this.endTimestamp,
							op: this.op,
							parentSpanId: this.parentSpanId,
							sampled: this.sampled,
							spanId: this.spanId,
							startTimestamp: this.startTimestamp,
							status: this.status,
							tags: this.tags,
							traceId: this.traceId
						})
					}, e.prototype.updateWithContext = function(e) {
						var t, n, r, i, s;
						return this.data = null !== (t = e.data) && void 0 !== t ? t : {}, this.description = e.description, this.endTimestamp = e.endTimestamp, this.op = e.op, this.parentSpanId = e.parentSpanId, this.sampled = e.sampled, this.spanId = null !== (n = e.spanId) && void 0 !== n ? n : this.spanId, this.startTimestamp = null !== (r = e.startTimestamp) && void 0 !== r ? r : this.startTimestamp, this.status = e.status, this.tags = null !== (i = e.tags) && void 0 !== i ? i : {}, this.traceId = null !== (s = e.traceId) && void 0 !== s ? s : this.traceId, this
					}, e.prototype.getTraceContext = function() {
						return (0, a.Jr)({
							data: Object.keys(this.data).length > 0 ? this.data : void 0,
							description: this.description,
							op: this.op,
							parent_span_id: this.parentSpanId,
							span_id: this.spanId,
							status: this.status,
							tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
							trace_id: this.traceId
						})
					}, e.prototype.toJSON = function() {
						return (0, a.Jr)({
							data: Object.keys(this.data).length > 0 ? this.data : void 0,
							description: this.description,
							op: this.op,
							parent_span_id: this.parentSpanId,
							span_id: this.spanId,
							start_timestamp: this.startTimestamp,
							status: this.status,
							tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
							timestamp: this.endTimestamp,
							trace_id: this.traceId
						})
					}, e
				}()
		},
		3391: function(e, t, n) {
			"use strict";
			n.d(t, {
				Y: function() {
					return c
				}
			});
			var r = n(655),
				i = n(9472),
				s = n(7597),
				a = n(2343),
				o = n(8252),
				l = n(5334),
				c = function(e) {
					function t(t, n) {
						var r = e.call(this, t) || this;
						return r._measurements = {}, r._hub = (0, i.Gd)(), (0, s.V9)(n, i.Xb) && (r._hub = n), r.name = t.name || "", r.metadata = t.metadata || {}, r._trimEnd = t.trimEnd, r.transaction = r, r
					}
					return (0, r.ZT)(t, e), t.prototype.setName = function(e) {
						this.name = e
					}, t.prototype.initSpanRecorder = function(e) {
						void 0 === e && (e = 1e3), this.spanRecorder || (this.spanRecorder = new l.gB(e)), this.spanRecorder.add(this)
					}, t.prototype.setMeasurements = function(e) {
						this._measurements = (0, r.pi)({}, e)
					}, t.prototype.setMetadata = function(e) {
						this.metadata = (0, r.pi)((0, r.pi)({}, this.metadata), e)
					}, t.prototype.finish = function(t) {
						var n = this;
						if (void 0 === this.endTimestamp) {
							if (this.name || (a.k.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this.name = "<unlabeled transaction>"), e.prototype.finish.call(this, t), !0 === this.sampled) {
								var r = this.spanRecorder ? this.spanRecorder.spans.filter((function(e) {
									return e !== n && e.endTimestamp
								})) : [];
								this._trimEnd && r.length > 0 && (this.endTimestamp = r.reduce((function(e, t) {
									return e.endTimestamp && t.endTimestamp ? e.endTimestamp > t.endTimestamp ? e : t : e
								})).endTimestamp);
								var i = {
									contexts: {
										trace: this.getTraceContext()
									},
									spans: r,
									start_timestamp: this.startTimestamp,
									tags: this.tags,
									timestamp: this.endTimestamp,
									transaction: this.name,
									type: "transaction",
									sdkProcessingMetadata: this.metadata
								};
								return Object.keys(this._measurements).length > 0 && (a.k.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), i.measurements = this._measurements), a.k.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + "."), this._hub.captureEvent(i)
							}
							a.k.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
							var s = this._hub.getClient(),
								o = s && s.getTransport && s.getTransport();
							o && o.recordLostEvent && o.recordLostEvent("sample_rate", "transaction")
						}
					}, t.prototype.toContext = function() {
						var t = e.prototype.toContext.call(this);
						return (0, o.Jr)((0, r.pi)((0, r.pi)({}, t), {
							name: this.name,
							trimEnd: this._trimEnd
						}))
					}, t.prototype.updateWithContext = function(t) {
						var n;
						return e.prototype.updateWithContext.call(this, t), this.name = null !== (n = t.name) && void 0 !== n ? n : "", this._trimEnd = t.trimEnd, this
					}, t
				}(l.Dr)
		},
		3233: function(e, t, n) {
			"use strict";
			n.d(t, {
				zu: function() {
					return s
				},
				qG: function() {
					return a
				},
				x1: function() {
					return o
				},
				XL: function() {
					return l
				},
				WB: function() {
					return c
				}
			});
			var r = n(9472),
				i = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

			function s(e) {
				var t = (0, r.Gd)().getClient(),
					n = e || t && t.getOptions();
				return !!n && ("tracesSampleRate" in n || "tracesSampler" in n)
			}

			function a(e) {
				var t = e.match(i);
				if (t) {
					var n = void 0;
					return "1" === t[3] ? n = !0 : "0" === t[3] && (n = !1), {
						traceId: t[1],
						parentSampled: n,
						parentSpanId: t[2]
					}
				}
			}

			function o(e) {
				var t = (e || (0, r.Gd)()).getScope();
				return t && t.getTransaction()
			}

			function l(e) {
				return e / 1e3
			}

			function c(e) {
				return 1e3 * e
			}
		},
		3819: function(e, t, n) {
			"use strict";
			var r;
			n.d(t, {
					z: function() {
						return r
					},
					a: function() {
						return i
					}
				}),
				function(e) {
					e.Fatal = "fatal", e.Error = "error", e.Warning = "warning", e.Log = "log", e.Info = "info", e.Debug = "debug", e.Critical = "critical"
				}(r || (r = {}));
			var i = ["fatal", "error", "warning", "log", "info", "debug", "critical"]
		},
		8464: function(e, t, n) {
			"use strict";
			n.d(t, {
				R: function() {
					return s
				},
				l: function() {
					return o
				}
			});
			var r = n(2991),
				i = n(7597);

			function s(e, t) {
				try {
					for (var n = e, r = [], i = 0, s = 0, o = " > ".length, l = void 0; n && i++ < 5 && !("html" === (l = a(n, t)) || i > 1 && s + r.length * o + l.length >= 80);) r.push(l), s += l.length, n = n.parentNode;
					return r.reverse().join(" > ")
				} catch (c) {
					return "<unknown>"
				}
			}

			function a(e, t) {
				var n, r, s, a, o, l = e,
					c = [];
				if (!l || !l.tagName) return "";
				c.push(l.tagName.toLowerCase());
				var u = t && t.length ? t.filter((function(e) {
					return l.getAttribute(e)
				})).map((function(e) {
					return [e, l.getAttribute(e)]
				})) : null;
				if (u && u.length) u.forEach((function(e) {
					c.push("[" + e[0] + '="' + e[1] + '"]')
				}));
				else if (l.id && c.push("#" + l.id), (n = l.className) && (0, i.HD)(n))
					for (r = n.split(/\s+/), o = 0; o < r.length; o++) c.push("." + r[o]);
				var h = ["type", "name", "title", "alt"];
				for (o = 0; o < h.length; o++) s = h[o], (a = l.getAttribute(s)) && c.push("[" + s + '="' + a + '"]');
				return c.join("")
			}

			function o() {
				var e = (0, r.R)();
				try {
					return e.document.location.href
				} catch (t) {
					return ""
				}
			}
		},
		292: function(e, t, n) {
			"use strict";
			n.d(t, {
				R: function() {
					return o
				},
				v: function() {
					return c
				}
			});
			var r = n(655),
				i = n(8518),
				s = n(7047),
				a = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;

			function o(e, t) {
				void 0 === t && (t = !1);
				var n = e.host,
					r = e.path,
					i = e.pass,
					s = e.port,
					a = e.projectId;
				return e.protocol + "://" + e.publicKey + (t && i ? ":" + i : "") + "@" + n + (s ? ":" + s : "") + "/" + (r ? r + "/" : r) + a
			}

			function l(e) {
				return "user" in e && !("publicKey" in e) && (e.publicKey = e.user), {
					user: e.publicKey || "",
					protocol: e.protocol,
					publicKey: e.publicKey || "",
					pass: e.pass || "",
					host: e.host,
					port: e.port || "",
					path: e.path || "",
					projectId: e.projectId
				}
			}

			function c(e) {
				var t = "string" === typeof e ? function(e) {
					var t = a.exec(e);
					if (!t) throw new s.b("Invalid Sentry Dsn: " + e);
					var n = (0, r.CR)(t.slice(1), 6),
						i = n[0],
						o = n[1],
						c = n[2],
						u = void 0 === c ? "" : c,
						h = n[3],
						d = n[4],
						p = void 0 === d ? "" : d,
						f = "",
						m = n[5],
						g = m.split("/");
					if (g.length > 1 && (f = g.slice(0, -1).join("/"), m = g.pop()), m) {
						var v = m.match(/^\d+/);
						v && (m = v[0])
					}
					return l({
						host: h,
						pass: u,
						path: f,
						projectId: m,
						port: p,
						protocol: i,
						publicKey: o
					})
				}(e) : l(e);
				return function(e) {
					if ((0, i.c)()) {
						var t = e.port,
							n = e.projectId,
							r = e.protocol;
						if (["protocol", "publicKey", "host", "projectId"].forEach((function(t) {
								if (!e[t]) throw new s.b("Invalid Sentry Dsn: " + t + " missing")
							})), !n.match(/^\d+$/)) throw new s.b("Invalid Sentry Dsn: Invalid projectId " + n);
						if (! function(e) {
								return "http" === e || "https" === e
							}(r)) throw new s.b("Invalid Sentry Dsn: Invalid protocol " + r);
						if (t && isNaN(parseInt(t, 10))) throw new s.b("Invalid Sentry Dsn: Invalid port " + t)
					}
				}(t), t
			}
		},
		8518: function(e, t, n) {
			"use strict";

			function r() {
				return "undefined" !== typeof __SENTRY_NO_DEBUG__ && !__SENTRY_BROWSER_BUNDLE__
			}

			function i() {
				return "undefined" !== typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__
			}
			n.d(t, {
				c: function() {
					return r
				},
				n: function() {
					return i
				}
			})
		},
		7047: function(e, t, n) {
			"use strict";
			n.d(t, {
				b: function() {
					return s
				}
			});
			var r = n(655),
				i = Object.setPrototypeOf || ({
						__proto__: []
					}
					instanceof Array ? function(e, t) {
						return e.__proto__ = t, e
					} : function(e, t) {
						for (var n in t) Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
						return e
					});
			var s = function(e) {
				function t(t) {
					var n = this.constructor,
						r = e.call(this, t) || this;
					return r.message = t, r.name = n.prototype.constructor.name, i(r, n.prototype), r
				}
				return (0, r.ZT)(t, e), t
			}(Error)
		},
		2991: function(e, t, n) {
			"use strict";
			n.d(t, {
				R: function() {
					return s
				}
			});
			var r = n(1422),
				i = {};

			function s() {
				return (0, r.KV)() ? n.g : "undefined" !== typeof window ? window : "undefined" !== typeof self ? self : i
			}
		},
		9732: function(e, t, n) {
			"use strict";
			n.d(t, {
				o: function() {
					return g
				}
			});
			var r, i = n(655),
				s = n(8518),
				a = n(2991),
				o = n(7597),
				l = n(2343),
				c = n(8252),
				u = n(360),
				h = n(8823),
				d = (0, a.R)(),
				p = {},
				f = {};

			function m(e) {
				if (!f[e]) switch (f[e] = !0, e) {
					case "console":
						! function() {
							if (!("console" in d)) return;
							["debug", "info", "warn", "error", "log", "assert"].forEach((function(e) {
								e in d.console && (0, c.hl)(d.console, e, (function(t) {
									return function() {
										for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
										v("console", {
											args: n,
											level: e
										}), t && Function.prototype.apply.call(t, d.console, n)
									}
								}))
							}))
						}();
						break;
					case "dom":
						! function() {
							if (!("document" in d)) return;
							var e = v.bind(null, "dom"),
								t = w(e, !0);
							d.document.addEventListener("click", t, !1), d.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach((function(t) {
								var n = d[t] && d[t].prototype;
								n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && ((0, c.hl)(n, "addEventListener", (function(t) {
									return function(n, r, i) {
										if ("click" === n || "keypress" == n) try {
											var s = this,
												a = s.__sentry_instrumentation_handlers__ = s.__sentry_instrumentation_handlers__ || {},
												o = a[n] = a[n] || {
													refCount: 0
												};
											if (!o.handler) {
												var l = w(e);
												o.handler = l, t.call(this, n, l, i)
											}
											o.refCount += 1
										} catch (c) {}
										return t.call(this, n, r, i)
									}
								})), (0, c.hl)(n, "removeEventListener", (function(e) {
									return function(t, n, r) {
										if ("click" === t || "keypress" == t) try {
											var i = this,
												s = i.__sentry_instrumentation_handlers__ || {},
												a = s[t];
											a && (a.refCount -= 1, a.refCount <= 0 && (e.call(this, t, a.handler, r), a.handler = void 0, delete s[t]), 0 === Object.keys(s).length && delete i.__sentry_instrumentation_handlers__)
										} catch (o) {}
										return e.call(this, t, n, r)
									}
								})))
							}))
						}();
						break;
					case "xhr":
						! function() {
							if (!("XMLHttpRequest" in d)) return;
							var e = XMLHttpRequest.prototype;
							(0, c.hl)(e, "open", (function(e) {
								return function() {
									for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
									var r = this,
										i = t[1],
										s = r.__sentry_xhr__ = {
											method: (0, o.HD)(t[0]) ? t[0].toUpperCase() : t[0],
											url: t[1]
										};
									(0, o.HD)(i) && "POST" === s.method && i.match(/sentry_key/) && (r.__sentry_own_request__ = !0);
									var a = function() {
										if (4 === r.readyState) {
											try {
												s.status_code = r.status
											} catch (e) {}
											v("xhr", {
												args: t,
												endTimestamp: Date.now(),
												startTimestamp: Date.now(),
												xhr: r
											})
										}
									};
									return "onreadystatechange" in r && "function" === typeof r.onreadystatechange ? (0, c.hl)(r, "onreadystatechange", (function(e) {
										return function() {
											for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
											return a(), e.apply(r, t)
										}
									})) : r.addEventListener("readystatechange", a), e.apply(r, t)
								}
							})), (0, c.hl)(e, "send", (function(e) {
								return function() {
									for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
									return this.__sentry_xhr__ && void 0 !== t[0] && (this.__sentry_xhr__.body = t[0]), v("xhr", {
										args: t,
										startTimestamp: Date.now(),
										xhr: this
									}), e.apply(this, t)
								}
							}))
						}();
						break;
					case "fetch":
						! function() {
							if (!(0, h.t$)()) return;
							(0, c.hl)(d, "fetch", (function(e) {
								return function() {
									for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
									var r = {
										args: t,
										fetchData: {
											method: y(t),
											url: x(t)
										},
										startTimestamp: Date.now()
									};
									return v("fetch", (0, i.pi)({}, r)), e.apply(d, t).then((function(e) {
										return v("fetch", (0, i.pi)((0, i.pi)({}, r), {
											endTimestamp: Date.now(),
											response: e
										})), e
									}), (function(e) {
										throw v("fetch", (0, i.pi)((0, i.pi)({}, r), {
											endTimestamp: Date.now(),
											error: e
										})), e
									}))
								}
							}))
						}();
						break;
					case "history":
						! function() {
							if (!(0, h.Bf)()) return;
							var e = d.onpopstate;

							function t(e) {
								return function() {
									for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
									var i = t.length > 2 ? t[2] : void 0;
									if (i) {
										var s = r,
											a = String(i);
										r = a, v("history", {
											from: s,
											to: a
										})
									}
									return e.apply(this, t)
								}
							}
							d.onpopstate = function() {
								for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
								var i = d.location.href,
									s = r;
								if (r = i, v("history", {
										from: s,
										to: i
									}), e) try {
									return e.apply(this, t)
								} catch (a) {}
							}, (0, c.hl)(d.history, "pushState", t), (0, c.hl)(d.history, "replaceState", t)
						}();
						break;
					case "error":
						M = d.onerror, d.onerror = function(e, t, n, r, i) {
							return v("error", {
								column: r,
								error: i,
								line: n,
								msg: e,
								url: t
							}), !!M && M.apply(this, arguments)
						};
						break;
					case "unhandledrejection":
						A = d.onunhandledrejection, d.onunhandledrejection = function(e) {
							return v("unhandledrejection", e), !A || A.apply(this, arguments)
						};
						break;
					default:
						l.k.warn("unknown instrumentation type:", e)
				}
			}

			function g(e, t) {
				p[e] = p[e] || [], p[e].push(t), m(e)
			}

			function v(e, t) {
				var n, r;
				if (e && p[e]) try {
					for (var a = (0, i.XA)(p[e] || []), o = a.next(); !o.done; o = a.next()) {
						var c = o.value;
						try {
							c(t)
						} catch (h) {
							(0, s.c)() && l.k.error("Error while triggering instrumentation handler.\nType: " + e + "\nName: " + (0, u.$)(c) + "\nError: " + h)
						}
					}
				} catch (d) {
					n = {
						error: d
					}
				} finally {
					try {
						o && !o.done && (r = a.return) && r.call(a)
					} finally {
						if (n) throw n.error
					}
				}
			}

			function y(e) {
				return void 0 === e && (e = []), "Request" in d && (0, o.V9)(e[0], Request) && e[0].method ? String(e[0].method).toUpperCase() : e[1] && e[1].method ? String(e[1].method).toUpperCase() : "GET"
			}

			function x(e) {
				return void 0 === e && (e = []), "string" === typeof e[0] ? e[0] : "Request" in d && (0, o.V9)(e[0], Request) ? e[0].url : String(e[0])
			}
			var _, b;

			function w(e, t) {
				return void 0 === t && (t = !1),
					function(n) {
						if (n && b !== n && ! function(e) {
								if ("keypress" !== e.type) return !1;
								try {
									var t = e.target;
									if (!t || !t.tagName) return !0;
									if ("INPUT" === t.tagName || "TEXTAREA" === t.tagName || t.isContentEditable) return !1
								} catch (n) {}
								return !0
							}(n)) {
							var r = "keypress" === n.type ? "input" : n.type;
							(void 0 === _ || function(e, t) {
								if (!e) return !0;
								if (e.type !== t.type) return !0;
								try {
									if (e.target !== t.target) return !0
								} catch (n) {}
								return !1
							}(b, n)) && (e({
								event: n,
								name: r,
								global: t
							}), b = n), clearTimeout(_), _ = d.setTimeout((function() {
								_ = void 0
							}), 1e3)
						}
					}
			}
			var M = null;
			var A = null
		},
		7597: function(e, t, n) {
			"use strict";
			n.d(t, {
				VZ: function() {
					return i
				},
				VW: function() {
					return a
				},
				TX: function() {
					return o
				},
				fm: function() {
					return l
				},
				HD: function() {
					return c
				},
				pt: function() {
					return u
				},
				PO: function() {
					return h
				},
				cO: function() {
					return d
				},
				kK: function() {
					return p
				},
				Kj: function() {
					return f
				},
				J8: function() {
					return m
				},
				Cy: function() {
					return g
				},
				V9: function() {
					return v
				}
			});
			var r = Object.prototype.toString;

			function i(e) {
				switch (r.call(e)) {
					case "[object Error]":
					case "[object Exception]":
					case "[object DOMException]":
						return !0;
					default:
						return v(e, Error)
				}
			}

			function s(e, t) {
				return r.call(e) === "[object " + t + "]"
			}

			function a(e) {
				return s(e, "ErrorEvent")
			}

			function o(e) {
				return s(e, "DOMError")
			}

			function l(e) {
				return s(e, "DOMException")
			}

			function c(e) {
				return s(e, "String")
			}

			function u(e) {
				return null === e || "object" !== typeof e && "function" !== typeof e
			}

			function h(e) {
				return s(e, "Object")
			}

			function d(e) {
				return "undefined" !== typeof Event && v(e, Event)
			}

			function p(e) {
				return "undefined" !== typeof Element && v(e, Element)
			}

			function f(e) {
				return s(e, "RegExp")
			}

			function m(e) {
				return Boolean(e && e.then && "function" === typeof e.then)
			}

			function g(e) {
				return h(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e
			}

			function v(e, t) {
				try {
					return e instanceof t
				} catch (n) {
					return !1
				}
			}
		},
		2343: function(e, t, n) {
			"use strict";
			n.d(t, {
				C: function() {
					return a
				},
				k: function() {
					return l
				}
			});
			var r = n(2991),
				i = (0, r.R)(),
				s = "Sentry Logger ";

			function a(e) {
				var t = (0, r.R)();
				if (!("console" in t)) return e();
				var n = t.console,
					i = {};
				["debug", "info", "warn", "error", "log", "assert"].forEach((function(e) {
					e in t.console && n[e].__sentry_original__ && (i[e] = n[e], n[e] = n[e].__sentry_original__)
				}));
				var s = e();
				return Object.keys(i).forEach((function(e) {
					n[e] = i[e]
				})), s
			}
			var o = function() {
				function e() {
					this._enabled = !1
				}
				return e.prototype.disable = function() {
					this._enabled = !1
				}, e.prototype.enable = function() {
					this._enabled = !0
				}, e.prototype.log = function() {
					for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
					this._enabled && a((function() {
						i.console.log(s + "[Log]: " + e.join(" "))
					}))
				}, e.prototype.warn = function() {
					for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
					this._enabled && a((function() {
						i.console.warn(s + "[Warn]: " + e.join(" "))
					}))
				}, e.prototype.error = function() {
					for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
					this._enabled && a((function() {
						i.console.error(s + "[Error]: " + e.join(" "))
					}))
				}, e
			}();
			i.__SENTRY__ = i.__SENTRY__ || {};
			var l = i.__SENTRY__.logger || (i.__SENTRY__.logger = new o)
		},
		2844: function(e, t, n) {
			"use strict";
			n.d(t, {
				DM: function() {
					return a
				},
				en: function() {
					return o
				},
				jH: function() {
					return c
				},
				Db: function() {
					return u
				},
				EG: function() {
					return h
				},
				JY: function() {
					return d
				},
				rt: function() {
					return p
				},
				YO: function() {
					return f
				}
			});
			var r = n(655),
				i = n(2991),
				s = n(8252);

			function a() {
				var e = (0, i.R)(),
					t = e.crypto || e.msCrypto;
				if (void 0 !== t && t.getRandomValues) {
					var n = new Uint16Array(8);
					t.getRandomValues(n), n[3] = 4095 & n[3] | 16384, n[4] = 16383 & n[4] | 32768;
					var r = function(e) {
						for (var t = e.toString(16); t.length < 4;) t = "0" + t;
						return t
					};
					return r(n[0]) + r(n[1]) + r(n[2]) + r(n[3]) + r(n[4]) + r(n[5]) + r(n[6]) + r(n[7])
				}
				return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
					var t = 16 * Math.random() | 0;
					return ("x" === e ? t : 3 & t | 8).toString(16)
				}))
			}

			function o(e) {
				if (!e) return {};
				var t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
				if (!t) return {};
				var n = t[6] || "",
					r = t[8] || "";
				return {
					host: t[4],
					path: t[5],
					protocol: t[2],
					relative: t[5] + n + r
				}
			}

			function l(e) {
				return e.exception && e.exception.values ? e.exception.values[0] : void 0
			}

			function c(e) {
				var t = e.message,
					n = e.event_id;
				if (t) return t;
				var r = l(e);
				return r ? r.type && r.value ? r.type + ": " + r.value : r.type || r.value || n || "<unknown>" : n || "<unknown>"
			}

			function u(e, t, n) {
				var r = e.exception = e.exception || {},
					i = r.values = r.values || [],
					s = i[0] = i[0] || {};
				s.value || (s.value = t || ""), s.type || (s.type = n || "Error")
			}

			function h(e, t) {
				var n = l(e);
				if (n) {
					var i = n.mechanism;
					if (n.mechanism = (0, r.pi)((0, r.pi)((0, r.pi)({}, {
							type: "generic",
							handled: !0
						}), i), t), t && "data" in t) {
						var s = (0, r.pi)((0, r.pi)({}, i && i.data), t.data);
						n.mechanism.data = s
					}
				}
			}

			function d(e, t) {
				if (!t) return 6e4;
				var n = parseInt("" + t, 10);
				if (!isNaN(n)) return 1e3 * n;
				var r = Date.parse("" + t);
				return isNaN(r) ? 6e4 : r - e
			}

			function p(e) {
				return e.split(/[\?#]/, 1)[0]
			}

			function f(e) {
				if (e && e.__sentry_captured__) return !0;
				try {
					(0, s.xp)(e, "__sentry_captured__", !0)
				} catch (t) {}
				return !1
			}
		},
		1422: function(e, t, n) {
			"use strict";
			n.d(t, {
				KV: function() {
					return s
				},
				l$: function() {
					return a
				},
				$y: function() {
					return o
				}
			});
			var r = n(8518);
			e = n.hmd(e);
			var i = n(4155);

			function s() {
				return !(0, r.n)() && "[object process]" === Object.prototype.toString.call("undefined" !== typeof i ? i : 0)
			}

			function a(e, t) {
				return e.require(t)
			}

			function o(t) {
				var n;
				try {
					n = a(e, t)
				} catch (i) {}
				try {
					var r = a(e, "process").cwd;
					n = a(e, r() + "/node_modules/" + t)
				} catch (i) {}
				return n
			}
		},
		8252: function(e, t, n) {
			"use strict";
			n.d(t, {
				xp: function() {
					return c
				},
				Jr: function() {
					return _
				},
				zf: function() {
					return x
				},
				hl: function() {
					return l
				},
				HK: function() {
					return h
				},
				$Q: function() {
					return u
				},
				Fv: function() {
					return y
				},
				Qy: function() {
					return m
				},
				_j: function() {
					return d
				}
			});
			var r = n(655),
				i = n(8464),
				s = n(7597);
			var a = n(360),
				o = n(7321);

			function l(e, t, n) {
				if (t in e) {
					var r = e[t],
						i = n(r);
					if ("function" === typeof i) try {
						u(i, r)
					} catch (s) {}
					e[t] = i
				}
			}

			function c(e, t, n) {
				Object.defineProperty(e, t, {
					value: n
				})
			}

			function u(e, t) {
				var n = t.prototype || {};
				e.prototype = t.prototype = n, c(e, "__sentry_original__", t)
			}

			function h(e) {
				return e.__sentry_original__
			}

			function d(e) {
				return Object.keys(e).map((function(t) {
					return encodeURIComponent(t) + "=" + encodeURIComponent(e[t])
				})).join("&")
			}

			function p(e) {
				if ((0, s.VZ)(e)) {
					var t = e,
						n = {
							message: t.message,
							name: t.name,
							stack: t.stack
						};
					for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
					return n
				}
				if ((0, s.cO)(e)) {
					var a = e,
						o = {};
					o.type = a.type;
					try {
						o.target = (0, s.kK)(a.target) ? (0, i.R)(a.target) : Object.prototype.toString.call(a.target)
					} catch (c) {
						o.target = "<unknown>"
					}
					try {
						o.currentTarget = (0, s.kK)(a.currentTarget) ? (0, i.R)(a.currentTarget) : Object.prototype.toString.call(a.currentTarget)
					} catch (c) {
						o.currentTarget = "<unknown>"
					}
					for (var l in "undefined" !== typeof CustomEvent && (0, s.V9)(e, CustomEvent) && (o.detail = a.detail), a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
					return o
				}
				return e
			}

			function f(e) {
				return function(e) {
					return ~-encodeURI(e).split(/%..|./).length
				}(JSON.stringify(e))
			}

			function m(e, t, n) {
				void 0 === t && (t = 3), void 0 === n && (n = 102400);
				var r = y(e, t);
				return f(r) > n ? m(e, t - 1, n) : r
			}

			function g(e, t) {
				return "domain" === t && e && "object" === typeof e && e._events ? "[Domain]" : "domainEmitter" === t ? "[DomainEmitter]" : "undefined" !== typeof n.g && e === n.g ? "[Global]" : "undefined" !== typeof window && e === window ? "[Window]" : "undefined" !== typeof document && e === document ? "[Document]" : (0, s.Cy)(e) ? "[SyntheticEvent]" : "number" === typeof e && e !== e ? "[NaN]" : void 0 === e ? "[undefined]" : "function" === typeof e ? "[Function: " + (0, a.$)(e) + "]" : "symbol" === typeof e ? "[" + String(e) + "]" : "bigint" === typeof e ? "[BigInt: " + String(e) + "]" : e
			}

			function v(e, t, n, r) {
				if (void 0 === n && (n = 1 / 0), void 0 === r && (r = function() {
						var e = "function" === typeof WeakSet,
							t = e ? new WeakSet : [];
						return [function(n) {
							if (e) return !!t.has(n) || (t.add(n), !1);
							for (var r = 0; r < t.length; r++)
								if (t[r] === n) return !0;
							return t.push(n), !1
						}, function(n) {
							if (e) t.delete(n);
							else
								for (var r = 0; r < t.length; r++)
									if (t[r] === n) {
										t.splice(r, 1);
										break
									}
						}]
					}()), 0 === n) return function(e) {
					if ("string" === typeof e) return e;
					var t = Object.prototype.toString.call(e);
					if ("[object Object]" === t) return "[Object]";
					if ("[object Array]" === t) return "[Array]";
					var n = g(e);
					return (0, s.pt)(n) ? n : t
				}(t);
				if (null !== t && void 0 !== t && "function" === typeof t.toJSON) return t.toJSON();
				var i = g(t, e);
				if ((0, s.pt)(i)) return i;
				var a = p(t),
					o = Array.isArray(t) ? [] : {};
				if (r[0](t)) return "[Circular ~]";
				for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = v(l, a[l], n - 1, r));
				return r[1](t), o
			}

			function y(e, t) {
				try {
					return JSON.parse(JSON.stringify(e, (function(e, n) {
						return v(e, n, t)
					})))
				} catch (n) {
					return "**non-serializable**"
				}
			}

			function x(e, t) {
				void 0 === t && (t = 40);
				var n = Object.keys(p(e));
				if (n.sort(), !n.length) return "[object has no keys]";
				if (n[0].length >= t) return (0, o.$G)(n[0], t);
				for (var r = n.length; r > 0; r--) {
					var i = n.slice(0, r).join(", ");
					if (!(i.length > t)) return r === n.length ? i : (0, o.$G)(i, t)
				}
				return ""
			}

			function _(e) {
				var t, n;
				if ((0, s.PO)(e)) {
					var i = e,
						a = {};
					try {
						for (var o = (0, r.XA)(Object.keys(i)), l = o.next(); !l.done; l = o.next()) {
							var c = l.value;
							"undefined" !== typeof i[c] && (a[c] = _(i[c]))
						}
					} catch (u) {
						t = {
							error: u
						}
					} finally {
						try {
							l && !l.done && (n = o.return) && n.call(o)
						} finally {
							if (t) throw t.error
						}
					}
					return a
				}
				return Array.isArray(e) ? e.map(_) : e
			}
		},
		360: function(e, t, n) {
			"use strict";
			n.d(t, {
				$: function() {
					return i
				}
			});
			var r = "<anonymous>";

			function i(e) {
				try {
					return e && "function" === typeof e && e.name || r
				} catch (t) {
					return r
				}
			}
		},
		7321: function(e, t, n) {
			"use strict";
			n.d(t, {
				$G: function() {
					return i
				},
				nK: function() {
					return s
				},
				zC: function() {
					return a
				}
			});
			var r = n(7597);

			function i(e, t) {
				return void 0 === t && (t = 0), "string" !== typeof e || 0 === t || e.length <= t ? e : e.substr(0, t) + "..."
			}

			function s(e, t) {
				if (!Array.isArray(e)) return "";
				for (var n = [], r = 0; r < e.length; r++) {
					var i = e[r];
					try {
						n.push(String(i))
					} catch (s) {
						n.push("[value cannot be serialized]")
					}
				}
				return n.join(t)
			}

			function a(e, t) {
				return !!(0, r.HD)(e) && ((0, r.Kj)(t) ? t.test(e) : "string" === typeof t && -1 !== e.indexOf(t))
			}
		},
		8823: function(e, t, n) {
			"use strict";
			n.d(t, {
				Ak: function() {
					return a
				},
				Du: function() {
					return o
				},
				t$: function() {
					return l
				},
				hv: function() {
					return c
				},
				Bf: function() {
					return u
				}
			});
			var r = n(8518),
				i = n(2991),
				s = n(2343);

			function a() {
				if (!("fetch" in (0, i.R)())) return !1;
				try {
					return new Headers, new Request(""), new Response, !0
				} catch (e) {
					return !1
				}
			}

			function o(e) {
				return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
			}

			function l() {
				if (!a()) return !1;
				var e = (0, i.R)();
				if (o(e.fetch)) return !0;
				var t = !1,
					n = e.document;
				if (n && "function" === typeof n.createElement) try {
					var l = n.createElement("iframe");
					l.hidden = !0, n.head.appendChild(l), l.contentWindow && l.contentWindow.fetch && (t = o(l.contentWindow.fetch)), n.head.removeChild(l)
				} catch (c) {
					(0, r.c)() && s.k.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", c)
				}
				return t
			}

			function c() {
				if (!a()) return !1;
				try {
					return new Request("_", {
						referrerPolicy: "origin"
					}), !0
				} catch (e) {
					return !1
				}
			}

			function u() {
				var e = (0, i.R)(),
					t = e.chrome,
					n = t && t.app && t.app.runtime,
					r = "history" in e && !!e.history.pushState && !!e.history.replaceState;
				return !n && r
			}
		},
		6893: function(e, t, n) {
			"use strict";
			n.d(t, {
				WD: function() {
					return i
				},
				$2: function() {
					return s
				},
				cW: function() {
					return a
				}
			});
			var r = n(7597);

			function i(e) {
				return new a((function(t) {
					t(e)
				}))
			}

			function s(e) {
				return new a((function(t, n) {
					n(e)
				}))
			}
			var a = function() {
				function e(e) {
					var t = this;
					this._state = 0, this._handlers = [], this._resolve = function(e) {
						t._setResult(1, e)
					}, this._reject = function(e) {
						t._setResult(2, e)
					}, this._setResult = function(e, n) {
						0 === t._state && ((0, r.J8)(n) ? n.then(t._resolve, t._reject) : (t._state = e, t._value = n, t._executeHandlers()))
					}, this._executeHandlers = function() {
						if (0 !== t._state) {
							var e = t._handlers.slice();
							t._handlers = [], e.forEach((function(e) {
								e[0] || (1 === t._state && e[1](t._value), 2 === t._state && e[2](t._value), e[0] = !0)
							}))
						}
					};
					try {
						e(this._resolve, this._reject)
					} catch (n) {
						this._reject(n)
					}
				}
				return e.prototype.then = function(t, n) {
					var r = this;
					return new e((function(e, i) {
						r._handlers.push([!1, function(n) {
							if (t) try {
								e(t(n))
							} catch (r) {
								i(r)
							} else e(n)
						}, function(t) {
							if (n) try {
								e(n(t))
							} catch (r) {
								i(r)
							} else i(t)
						}]), r._executeHandlers()
					}))
				}, e.prototype.catch = function(e) {
					return this.then((function(e) {
						return e
					}), e)
				}, e.prototype.finally = function(t) {
					var n = this;
					return new e((function(e, r) {
						var i, s;
						return n.then((function(e) {
							s = !1, i = e, t && t()
						}), (function(e) {
							s = !0, i = e, t && t()
						})).then((function() {
							s ? r(i) : e(i)
						}))
					}))
				}, e
			}()
		},
		1170: function(e, t, n) {
			"use strict";
			n.d(t, {
				yW: function() {
					return l
				},
				ph: function() {
					return c
				},
				_I: function() {
					return u
				},
				Z1: function() {
					return h
				}
			});
			var r = n(2991),
				i = n(1422);
			e = n.hmd(e);
			var s = {
				nowSeconds: function() {
					return Date.now() / 1e3
				}
			};
			var a = (0, i.KV)() ? function() {
					try {
						return (0, i.l$)(e, "perf_hooks").performance
					} catch (t) {
						return
					}
				}() : function() {
					var e = (0, r.R)().performance;
					if (e && e.now) return {
						now: function() {
							return e.now()
						},
						timeOrigin: Date.now() - e.now()
					}
				}(),
				o = void 0 === a ? s : {
					nowSeconds: function() {
						return (a.timeOrigin + a.now()) / 1e3
					}
				},
				l = s.nowSeconds.bind(s),
				c = o.nowSeconds.bind(o),
				u = c,
				h = function() {
					var e = (0, r.R)().performance;
					if (e && e.now) {
						var t = 36e5,
							n = e.now(),
							i = Date.now(),
							s = e.timeOrigin ? Math.abs(e.timeOrigin + n - i) : t,
							a = s < t,
							o = e.timing && e.timing.navigationStart,
							l = "number" === typeof o ? Math.abs(o + n - i) : t;
						return a || l < t ? s <= l ? ("timeOrigin", e.timeOrigin) : ("navigationStart", o) : ("dateNow", i)
					}
					"none"
				}()
		},
		9484: function(e, t, n) {
			var r = "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : "undefined" !== typeof self ? self : {};
			r.SENTRY_RELEASE = {
				id: "56c69377063cffbe7a38a532128b62e561df211b"
			}, r.SENTRY_RELEASES = r.SENTRY_RELEASES || {}, r.SENTRY_RELEASES["richard-portfolio@richard-6f"] = {
				id: "56c69377063cffbe7a38a532128b62e561df211b"
			}
		},
		4184: function(e, t) {
			var n;
			! function() {
				"use strict";
				var r = {}.hasOwnProperty;

				function i() {
					for (var e = [], t = 0; t < arguments.length; t++) {
						var n = arguments[t];
						if (n) {
							var s = typeof n;
							if ("string" === s || "number" === s) e.push(n);
							else if (Array.isArray(n)) {
								if (n.length) {
									var a = i.apply(null, n);
									a && e.push(a)
								}
							} else if ("object" === s)
								if (n.toString === Object.prototype.toString)
									for (var o in n) r.call(n, o) && n[o] && e.push(o);
								else e.push(n.toString())
						}
					}
					return e.join(" ")
				}
				e.exports ? (i.default = i, e.exports = i) : void 0 === (n = function() {
					return i
				}.apply(t, [])) || (e.exports = n)
			}()
		},
		296: function(e) {
			function t(e, t, n) {
				var r, i, s, a, o;

				function l() {
					var c = Date.now() - a;
					c < t && c >= 0 ? r = setTimeout(l, t - c) : (r = null, n || (o = e.apply(s, i), s = i = null))
				}
				null == t && (t = 100);
				var c = function() {
					s = this, i = arguments, a = Date.now();
					var c = n && !r;
					return r || (r = setTimeout(l, t)), c && (o = e.apply(s, i), s = i = null), o
				};
				return c.clear = function() {
					r && (clearTimeout(r), r = null)
				}, c.flush = function() {
					r && (o = e.apply(s, i), s = i = null, clearTimeout(r), r = null)
				}, c
			}
			t.debounce = t, e.exports = t
		},
		4063: function(e) {
			"use strict";
			e.exports = function e(t, n) {
				if (t === n) return !0;
				if (t && n && "object" == typeof t && "object" == typeof n) {
					if (t.constructor !== n.constructor) return !1;
					var r, i, s;
					if (Array.isArray(t)) {
						if ((r = t.length) != n.length) return !1;
						for (i = r; 0 !== i--;)
							if (!e(t[i], n[i])) return !1;
						return !0
					}
					if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
					if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
					if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
					if ((r = (s = Object.keys(t)).length) !== Object.keys(n).length) return !1;
					for (i = r; 0 !== i--;)
						if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1;
					for (i = r; 0 !== i--;) {
						var a = s[i];
						if (!e(t[a], n[a])) return !1
					}
					return !0
				}
				return t !== t && n !== n
			}
		},
		6337: function() {
			! function() {
				"use strict";
				if ("object" === typeof window)
					if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
						get: function() {
							return this.intersectionRatio > 0
						}
					});
					else {
						var e = function(e) {
								for (var t = window.document, n = i(t); n;) n = i(t = n.ownerDocument);
								return t
							}(),
							t = [],
							n = null,
							r = null;
						a.prototype.THROTTLE_TIMEOUT = 100, a.prototype.POLL_INTERVAL = null, a.prototype.USE_MUTATION_OBSERVER = !0, a._setupCrossOriginUpdater = function() {
							return n || (n = function(e, n) {
								r = e && n ? d(e, n) : {
									top: 0,
									bottom: 0,
									left: 0,
									right: 0,
									width: 0,
									height: 0
								}, t.forEach((function(e) {
									e._checkForIntersections()
								}))
							}), n
						}, a._resetCrossOriginUpdater = function() {
							n = null, r = null
						}, a.prototype.observe = function(e) {
							if (!this._observationTargets.some((function(t) {
									return t.element == e
								}))) {
								if (!e || 1 != e.nodeType) throw new Error("target must be an Element");
								this._registerInstance(), this._observationTargets.push({
									element: e,
									entry: null
								}), this._monitorIntersections(e.ownerDocument), this._checkForIntersections()
							}
						}, a.prototype.unobserve = function(e) {
							this._observationTargets = this._observationTargets.filter((function(t) {
								return t.element != e
							})), this._unmonitorIntersections(e.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance()
						}, a.prototype.disconnect = function() {
							this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance()
						}, a.prototype.takeRecords = function() {
							var e = this._queuedEntries.slice();
							return this._queuedEntries = [], e
						}, a.prototype._initThresholds = function(e) {
							var t = e || [0];
							return Array.isArray(t) || (t = [t]), t.sort().filter((function(e, t, n) {
								if ("number" != typeof e || isNaN(e) || e < 0 || e > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
								return e !== n[t - 1]
							}))
						}, a.prototype._parseRootMargin = function(e) {
							var t = (e || "0px").split(/\s+/).map((function(e) {
								var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
								if (!t) throw new Error("rootMargin must be specified in pixels or percent");
								return {
									value: parseFloat(t[1]),
									unit: t[2]
								}
							}));
							return t[1] = t[1] || t[0], t[2] = t[2] || t[0], t[3] = t[3] || t[1], t
						}, a.prototype._monitorIntersections = function(t) {
							var n = t.defaultView;
							if (n && -1 == this._monitoringDocuments.indexOf(t)) {
								var r = this._checkForIntersections,
									s = null,
									a = null;
								this.POLL_INTERVAL ? s = n.setInterval(r, this.POLL_INTERVAL) : (o(n, "resize", r, !0), o(t, "scroll", r, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in n && (a = new n.MutationObserver(r)).observe(t, {
									attributes: !0,
									childList: !0,
									characterData: !0,
									subtree: !0
								})), this._monitoringDocuments.push(t), this._monitoringUnsubscribes.push((function() {
									var e = t.defaultView;
									e && (s && e.clearInterval(s), l(e, "resize", r, !0)), l(t, "scroll", r, !0), a && a.disconnect()
								}));
								var c = this.root && (this.root.ownerDocument || this.root) || e;
								if (t != c) {
									var u = i(t);
									u && this._monitorIntersections(u.ownerDocument)
								}
							}
						}, a.prototype._unmonitorIntersections = function(t) {
							var n = this._monitoringDocuments.indexOf(t);
							if (-1 != n) {
								var r = this.root && (this.root.ownerDocument || this.root) || e;
								if (!this._observationTargets.some((function(e) {
										var n = e.element.ownerDocument;
										if (n == t) return !0;
										for (; n && n != r;) {
											var s = i(n);
											if ((n = s && s.ownerDocument) == t) return !0
										}
										return !1
									}))) {
									var s = this._monitoringUnsubscribes[n];
									if (this._monitoringDocuments.splice(n, 1), this._monitoringUnsubscribes.splice(n, 1), s(), t != r) {
										var a = i(t);
										a && this._unmonitorIntersections(a.ownerDocument)
									}
								}
							}
						}, a.prototype._unmonitorAllIntersections = function() {
							var e = this._monitoringUnsubscribes.slice(0);
							this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
							for (var t = 0; t < e.length; t++) e[t]()
						}, a.prototype._checkForIntersections = function() {
							if (this.root || !n || r) {
								var e = this._rootIsInDom(),
									t = e ? this._getRootRect() : {
										top: 0,
										bottom: 0,
										left: 0,
										right: 0,
										width: 0,
										height: 0
									};
								this._observationTargets.forEach((function(r) {
									var i = r.element,
										a = u(i),
										o = this._rootContainsTarget(i),
										l = r.entry,
										c = e && o && this._computeTargetAndRootIntersection(i, a, t),
										h = null;
									this._rootContainsTarget(i) ? n && !this.root || (h = t) : h = {
										top: 0,
										bottom: 0,
										left: 0,
										right: 0,
										width: 0,
										height: 0
									};
									var d = r.entry = new s({
										time: window.performance && performance.now && performance.now(),
										target: i,
										boundingClientRect: a,
										rootBounds: h,
										intersectionRect: c
									});
									l ? e && o ? this._hasCrossedThreshold(l, d) && this._queuedEntries.push(d) : l && l.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d)
								}), this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
							}
						}, a.prototype._computeTargetAndRootIntersection = function(t, i, s) {
							if ("none" != window.getComputedStyle(t).display) {
								for (var a = i, o = f(t), l = !1; !l && o;) {
									var h = null,
										p = 1 == o.nodeType ? window.getComputedStyle(o) : {};
									if ("none" == p.display) return null;
									if (o == this.root || 9 == o.nodeType)
										if (l = !0, o == this.root || o == e) n && !this.root ? !r || 0 == r.width && 0 == r.height ? (o = null, h = null, a = null) : h = r : h = s;
										else {
											var m = f(o),
												g = m && u(m),
												v = m && this._computeTargetAndRootIntersection(m, g, s);
											g && v ? (o = m, h = d(g, v)) : (o = null, a = null)
										}
									else {
										var y = o.ownerDocument;
										o != y.body && o != y.documentElement && "visible" != p.overflow && (h = u(o))
									}
									if (h && (a = c(h, a)), !a) break;
									o = o && f(o)
								}
								return a
							}
						}, a.prototype._getRootRect = function() {
							var t;
							if (this.root && !m(this.root)) t = u(this.root);
							else {
								var n = m(this.root) ? this.root : e,
									r = n.documentElement,
									i = n.body;
								t = {
									top: 0,
									left: 0,
									right: r.clientWidth || i.clientWidth,
									width: r.clientWidth || i.clientWidth,
									bottom: r.clientHeight || i.clientHeight,
									height: r.clientHeight || i.clientHeight
								}
							}
							return this._expandRectByRootMargin(t)
						}, a.prototype._expandRectByRootMargin = function(e) {
							var t = this._rootMarginValues.map((function(t, n) {
									return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100
								})),
								n = {
									top: e.top - t[0],
									right: e.right + t[1],
									bottom: e.bottom + t[2],
									left: e.left - t[3]
								};
							return n.width = n.right - n.left, n.height = n.bottom - n.top, n
						}, a.prototype._hasCrossedThreshold = function(e, t) {
							var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1,
								r = t.isIntersecting ? t.intersectionRatio || 0 : -1;
							if (n !== r)
								for (var i = 0; i < this.thresholds.length; i++) {
									var s = this.thresholds[i];
									if (s == n || s == r || s < n !== s < r) return !0
								}
						}, a.prototype._rootIsInDom = function() {
							return !this.root || p(e, this.root)
						}, a.prototype._rootContainsTarget = function(t) {
							var n = this.root && (this.root.ownerDocument || this.root) || e;
							return p(n, t) && (!this.root || n == t.ownerDocument)
						}, a.prototype._registerInstance = function() {
							t.indexOf(this) < 0 && t.push(this)
						}, a.prototype._unregisterInstance = function() {
							var e = t.indexOf(this); - 1 != e && t.splice(e, 1)
						}, window.IntersectionObserver = a, window.IntersectionObserverEntry = s
					}
				function i(e) {
					try {
						return e.defaultView && e.defaultView.frameElement || null
					} catch (t) {
						return null
					}
				}

				function s(e) {
					this.time = e.time, this.target = e.target, this.rootBounds = h(e.rootBounds), this.boundingClientRect = h(e.boundingClientRect), this.intersectionRect = h(e.intersectionRect || {
						top: 0,
						bottom: 0,
						left: 0,
						right: 0,
						width: 0,
						height: 0
					}), this.isIntersecting = !!e.intersectionRect;
					var t = this.boundingClientRect,
						n = t.width * t.height,
						r = this.intersectionRect,
						i = r.width * r.height;
					this.intersectionRatio = n ? Number((i / n).toFixed(4)) : this.isIntersecting ? 1 : 0
				}

				function a(e, t) {
					var n = t || {};
					if ("function" != typeof e) throw new Error("callback must be a function");
					if (n.root && 1 != n.root.nodeType && 9 != n.root.nodeType) throw new Error("root must be a Document or Element");
					this._checkForIntersections = function(e, t) {
						var n = null;
						return function() {
							n || (n = setTimeout((function() {
								e(), n = null
							}), t))
						}
					}(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = e, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(n.rootMargin), this.thresholds = this._initThresholds(n.threshold), this.root = n.root || null, this.rootMargin = this._rootMarginValues.map((function(e) {
						return e.value + e.unit
					})).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = []
				}

				function o(e, t, n, r) {
					"function" == typeof e.addEventListener ? e.addEventListener(t, n, r || !1) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n)
				}

				function l(e, t, n, r) {
					"function" == typeof e.removeEventListener ? e.removeEventListener(t, n, r || !1) : "function" == typeof e.detatchEvent && e.detatchEvent("on" + t, n)
				}

				function c(e, t) {
					var n = Math.max(e.top, t.top),
						r = Math.min(e.bottom, t.bottom),
						i = Math.max(e.left, t.left),
						s = Math.min(e.right, t.right),
						a = s - i,
						o = r - n;
					return a >= 0 && o >= 0 && {
						top: n,
						bottom: r,
						left: i,
						right: s,
						width: a,
						height: o
					} || null
				}

				function u(e) {
					var t;
					try {
						t = e.getBoundingClientRect()
					} catch (n) {}
					return t ? (t.width && t.height || (t = {
						top: t.top,
						right: t.right,
						bottom: t.bottom,
						left: t.left,
						width: t.right - t.left,
						height: t.bottom - t.top
					}), t) : {
						top: 0,
						bottom: 0,
						left: 0,
						right: 0,
						width: 0,
						height: 0
					}
				}

				function h(e) {
					return !e || "x" in e ? e : {
						top: e.top,
						y: e.top,
						bottom: e.bottom,
						left: e.left,
						x: e.left,
						right: e.right,
						width: e.width,
						height: e.height
					}
				}

				function d(e, t) {
					var n = t.top - e.top,
						r = t.left - e.left;
					return {
						top: n,
						left: r,
						height: t.height,
						width: t.width,
						bottom: n + t.height,
						right: r + t.width
					}
				}

				function p(e, t) {
					for (var n = t; n;) {
						if (n == e) return !0;
						n = f(n)
					}
					return !1
				}

				function f(t) {
					var n = t.parentNode;
					return 9 == t.nodeType && t != e ? i(t) : (n && n.assignedSlot && (n = n.assignedSlot.parentNode), n && 11 == n.nodeType && n.host ? n.host : n)
				}

				function m(e) {
					return e && 9 === e.nodeType
				}
			}()
		},
		6363: function(e, t, n) {
			(window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
				return n(6448)
			}])
		},
		8418: function(e, t, n) {
			"use strict";

			function r(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e
				}(e) || function(e, t) {
					var n = [],
						r = !0,
						i = !1,
						s = void 0;
					try {
						for (var a, o = e[Symbol.iterator](); !(r = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
					} catch (l) {
						i = !0, s = l
					} finally {
						try {
							r || null == o.return || o.return()
						} finally {
							if (i) throw s
						}
					}
					return n
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance")
				}()
			}
			t.default = void 0;
			var i, s = (i = n(7294)) && i.__esModule ? i : {
					default: i
				},
				a = n(6273),
				o = n(387),
				l = n(7190);
			var c = {};

			function u(e, t, n, r) {
				if (e && a.isLocalURL(t)) {
					e.prefetch(t, n, r).catch((function(e) {
						0
					}));
					var i = r && "undefined" !== typeof r.locale ? r.locale : e && e.locale;
					c[t + "%" + n + (i ? "%" + i : "")] = !0
				}
			}
			var h = function(e) {
				var t, n = !1 !== e.prefetch,
					i = o.useRouter(),
					h = s.default.useMemo((function() {
						var t = r(a.resolveHref(i, e.href, !0), 2),
							n = t[0],
							s = t[1];
						return {
							href: n,
							as: e.as ? a.resolveHref(i, e.as) : s || n
						}
					}), [i, e.href, e.as]),
					d = h.href,
					p = h.as,
					f = e.children,
					m = e.replace,
					g = e.shallow,
					v = e.scroll,
					y = e.locale;
				"string" === typeof f && (f = s.default.createElement("a", null, f));
				var x = (t = s.default.Children.only(f)) && "object" === typeof t && t.ref,
					_ = r(l.useIntersection({
						rootMargin: "200px"
					}), 2),
					b = _[0],
					w = _[1],
					M = s.default.useCallback((function(e) {
						b(e), x && ("function" === typeof x ? x(e) : "object" === typeof x && (x.current = e))
					}), [x, b]);
				s.default.useEffect((function() {
					var e = w && n && a.isLocalURL(d),
						t = "undefined" !== typeof y ? y : i && i.locale,
						r = c[d + "%" + p + (t ? "%" + t : "")];
					e && !r && u(i, d, p, {
						locale: t
					})
				}), [p, d, w, y, n, i]);
				var A = {
					ref: M,
					onClick: function(e) {
						t.props && "function" === typeof t.props.onClick && t.props.onClick(e), e.defaultPrevented || function(e, t, n, r, i, s, o, l) {
							("A" !== e.currentTarget.nodeName || ! function(e) {
								var t = e.currentTarget.target;
								return t && "_self" !== t || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.nativeEvent && 2 === e.nativeEvent.which
							}(e) && a.isLocalURL(n)) && (e.preventDefault(), null == o && r.indexOf("#") >= 0 && (o = !1), t[i ? "replace" : "push"](n, r, {
								shallow: s,
								locale: l,
								scroll: o
							}))
						}(e, i, d, p, m, g, v, y)
					},
					onMouseEnter: function(e) {
						t.props && "function" === typeof t.props.onMouseEnter && t.props.onMouseEnter(e), a.isLocalURL(d) && u(i, d, p, {
							priority: !0
						})
					}
				};
				if (e.passHref || "a" === t.type && !("href" in t.props)) {
					var S = "undefined" !== typeof y ? y : i && i.locale,
						E = i && i.isLocaleDomain && a.getDomainLocale(p, S, i && i.locales, i && i.domainLocales);
					A.href = E || a.addBasePath(a.addLocale(p, S, i && i.defaultLocale))
				}
				return s.default.cloneElement(t, A)
			};
			t.default = h
		},
		7190: function(e, t, n) {
			"use strict";

			function r(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e
				}(e) || function(e, t) {
					var n = [],
						r = !0,
						i = !1,
						s = void 0;
					try {
						for (var a, o = e[Symbol.iterator](); !(r = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
					} catch (l) {
						i = !0, s = l
					} finally {
						try {
							r || null == o.return || o.return()
						} finally {
							if (i) throw s
						}
					}
					return n
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance")
				}()
			}
			Object.defineProperty(t, "__esModule", {
				value: !0
			}), t.useIntersection = function(e) {
				var t = e.rootMargin,
					n = e.disabled || !a,
					l = i.useRef(),
					c = r(i.useState(!1), 2),
					u = c[0],
					h = c[1],
					d = i.useCallback((function(e) {
						l.current && (l.current(), l.current = void 0), n || u || e && e.tagName && (l.current = function(e, t, n) {
							var r = function(e) {
									var t = e.rootMargin || "",
										n = o.get(t);
									if (n) return n;
									var r = new Map,
										i = new IntersectionObserver((function(e) {
											e.forEach((function(e) {
												var t = r.get(e.target),
													n = e.isIntersecting || e.intersectionRatio > 0;
												t && n && t(n)
											}))
										}), e);
									return o.set(t, n = {
										id: t,
										observer: i,
										elements: r
									}), n
								}(n),
								i = r.id,
								s = r.observer,
								a = r.elements;
							return a.set(e, t), s.observe(e),
								function() {
									a.delete(e), s.unobserve(e), 0 === a.size && (s.disconnect(), o.delete(i))
								}
						}(e, (function(e) {
							return e && h(e)
						}), {
							rootMargin: t
						}))
					}), [n, t, u]);
				return i.useEffect((function() {
					if (!a && !u) {
						var e = s.requestIdleCallback((function() {
							return h(!0)
						}));
						return function() {
							return s.cancelIdleCallback(e)
						}
					}
				}), [u]), [d, u]
			};
			var i = n(7294),
				s = n(9311),
				a = "undefined" !== typeof IntersectionObserver;
			var o = new Map
		},
		6448: function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, {
				default: function() {
					return de
				}
			});
			n(6337), n(5112), n(9221);
			var r = n(5893),
				i = n(7294),
				s = n(1163),
				a = n(9008),
				o = n(4298),
				l = n(3366),
				c = n(7462);
			var u = n(5068),
				h = n(220);

			function d(e, t) {
				var n = Object.create(null);
				return e && i.Children.map(e, (function(e) {
					return e
				})).forEach((function(e) {
					n[e.key] = function(e) {
						return t && (0, i.isValidElement)(e) ? t(e) : e
					}(e)
				})), n
			}

			function p(e, t, n) {
				return null != n[t] ? n[t] : e.props[t]
			}

			function f(e, t, n) {
				var r = d(e.children),
					s = function(e, t) {
						function n(n) {
							return n in t ? t[n] : e[n]
						}
						e = e || {}, t = t || {};
						var r, i = Object.create(null),
							s = [];
						for (var a in e) a in t ? s.length && (i[a] = s, s = []) : s.push(a);
						var o = {};
						for (var l in t) {
							if (i[l])
								for (r = 0; r < i[l].length; r++) {
									var c = i[l][r];
									o[i[l][r]] = n(c)
								}
							o[l] = n(l)
						}
						for (r = 0; r < s.length; r++) o[s[r]] = n(s[r]);
						return o
					}(t, r);
				return Object.keys(s).forEach((function(a) {
					var o = s[a];
					if ((0, i.isValidElement)(o)) {
						var l = a in t,
							c = a in r,
							u = t[a],
							h = (0, i.isValidElement)(u) && !u.props.in;
						!c || l && !h ? c || !l || h ? c && l && (0, i.isValidElement)(u) && (s[a] = (0, i.cloneElement)(o, {
							onExited: n.bind(null, o),
							in: u.props.in,
							exit: p(o, "exit", e),
							enter: p(o, "enter", e)
						})) : s[a] = (0, i.cloneElement)(o, {
							in: !1
						}) : s[a] = (0, i.cloneElement)(o, {
							onExited: n.bind(null, o),
							in: !0,
							exit: p(o, "exit", e),
							enter: p(o, "enter", e)
						})
					}
				})), s
			}
			var m = Object.values || function(e) {
					return Object.keys(e).map((function(t) {
						return e[t]
					}))
				},
				g = function(e) {
					function t(t, n) {
						var r, i = (r = e.call(this, t, n) || this).handleExited.bind(function(e) {
							if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return e
						}(r));
						return r.state = {
							contextValue: {
								isMounting: !0
							},
							handleExited: i,
							firstRender: !0
						}, r
					}(0, u.Z)(t, e);
					var n = t.prototype;
					return n.componentDidMount = function() {
						this.mounted = !0, this.setState({
							contextValue: {
								isMounting: !1
							}
						})
					}, n.componentWillUnmount = function() {
						this.mounted = !1
					}, t.getDerivedStateFromProps = function(e, t) {
						var n, r, s = t.children,
							a = t.handleExited;
						return {
							children: t.firstRender ? (n = e, r = a, d(n.children, (function(e) {
								return (0, i.cloneElement)(e, {
									onExited: r.bind(null, e),
									in: !0,
									appear: p(e, "appear", n),
									enter: p(e, "enter", n),
									exit: p(e, "exit", n)
								})
							}))) : f(e, s, a),
							firstRender: !1
						}
					}, n.handleExited = function(e, t) {
						var n = d(this.props.children);
						e.key in n || (e.props.onExited && e.props.onExited(t), this.mounted && this.setState((function(t) {
							var n = (0, c.Z)({}, t.children);
							return delete n[e.key], {
								children: n
							}
						})))
					}, n.render = function() {
						var e = this.props,
							t = e.component,
							n = e.childFactory,
							r = (0, l.Z)(e, ["component", "childFactory"]),
							s = this.state.contextValue,
							a = m(this.state.children).map(n);
						return delete r.appear, delete r.enter, delete r.exit, null === t ? i.createElement(h.Z.Provider, {
							value: s
						}, a) : i.createElement(h.Z.Provider, {
							value: s
						}, i.createElement(t, r, a))
					}, t
				}(i.Component);
			g.propTypes = {}, g.defaultProps = {
				component: "div",
				childFactory: function(e) {
					return e
				}
			};
			var v = g,
				y = n(8885),
				x = n(4184),
				_ = n.n(x),
				b = n(2336),
				w = n(8520),
				M = n.n(w);

			function A(e, t, n, r, i, s, a) {
				try {
					var o = e[s](a),
						l = o.value
				} catch (c) {
					return void n(c)
				}
				o.done ? t(l) : Promise.resolve(l).then(r, i)
			}
			var S = function(e) {
					var t, n = (0, i.useState)(0),
						r = n[0],
						s = n[1],
						a = (0, i.useState)(0),
						o = a[0],
						l = a[1],
						c = (0, i.useRef)({}),
						u = (0, i.useMemo)((function() {
							return e.flat().length
						}), [e]),
						h = (0, i.useMemo)((function() {
							var e = Math.floor(o / u * 100);
							return 0 === e || 100 === e ? e : e - 2 + Math.round(4 * Math.random())
						}), [o, u]),
						d = (t = M().mark((function t() {
							var n;
							return M().wrap((function(t) {
								for (;;) switch (t.prev = t.next) {
									case 0:
										return n = e[r], t.next = 3, p(n);
									case 3:
										l(o + n.length), r < e.length - 1 && s(r + 1);
									case 5:
									case "end":
										return t.stop()
								}
							}), t)
						})), function() {
							var e = this,
								n = arguments;
							return new Promise((function(r, i) {
								var s = t.apply(e, n);

								function a(e) {
									A(s, r, i, a, o, "next", e)
								}

								function o(e) {
									A(s, r, i, a, o, "throw", e)
								}
								a(void 0)
							}))
						}),
						p = function(e) {
							return new Promise((function(t) {
								var n = 0,
									r = function() {
										++n === e.length && t()
									};
								e.forEach((function(e) {
									var t, n = new Image(0, 0);
									n.onload = r, n.onerror = r, n.src = e, null === (t = c.current.element) || void 0 === t || t.appendChild(n)
								}))
							}))
						};
					return (0, i.useEffect)((function() {
						setTimeout((function() {
							return d()
						}), 0 === r ? 500 : 1450)
					}), [r]), (0, i.useEffect)((function() {
						var e = document.createElement("div");
						c.current.element = e, e.style.height = "0px", e.style.overflow = "hidden", e.style.position = "fixed", e.style.zIndex = "-1000", document.body.appendChild(e)
					}), []), (0, i.useEffect)((function() {
						100 === h && c.current.element && document.body.removeChild(c.current.element)
					}), [h]), h
				},
				E = ["/images/hero-cover.jpg", "/images/cruuunchify-cover.jpg", "/images/intelia-cover.jpg", "/images/home-about-cover.jpg", "/images/about-cover.jpg", "/images/about-details.jpg", "/images/pension-app-cover.jpg", "/images/controller-cover.jpg", "/images/dashboard-cover.jpg"],
				T = ["/images/cruuunchify-01.jpg", "/images/cruuunchify-02.jpg", "/images/intelia-01.jpg", "/images/intelia-02.jpg", "/images/pension-app-01.jpg", "/images/pension-app-02.jpg", "/images/controller-01.jpg", "/images/controller-02.jpg", "/images/dashboard-01.jpg", "/images/dashboard-02.jpg"],
				C = ["assets/DualSense.glb", "assets/football.glb", "assets/XM4.glb"],
				B = n(5160),
				R = n(8626);

			function L(e) {
				return function(e) {
					if (Array.isArray(e)) {
						for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
						return n
					}
				}(e) || function(e) {
					if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
				}(e) || function() {
					throw new TypeError("Invalid attempt to spread non-iterable instance")
				}()
			}
			var I, P, D = function(e) {
					return "  ".concat(e).slice(-3)
				},
				F = n(7115),
				O = n.n(F);

			function N(e, t, n) {
				return t in e ? Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = n, e
			}

			function H(e) {
				return function(e) {
					if (Array.isArray(e)) {
						for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
						return n
					}
				}(e) || function(e) {
					if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
				}(e) || function() {
					throw new TypeError("Invalid attempt to spread non-iterable instance")
				}()
			}
			var k = function(e) {
					var t = e.onComplete,
						n = (0, s.useRouter)(),
						a = (0, i.useState)(H("/404" === n.pathname ? ["/images/lost.gif"] : []).concat(H(E)))[0],
						o = (0, i.useState)(!1),
						l = o[0],
						c = o[1],
						u = (0, i.useState)(!1),
						h = u[0],
						d = u[1],
						p = (0, i.useState)(function(e) {
							var t = 2 + Math.ceil(2 * Math.random()),
								n = 6 + Math.ceil(3 * Math.random()),
								r = Math.floor(t / 10 * e.length),
								i = Math.floor(n / 10 * e.length);
							return [L(e.slice(0, r)), L(e.slice(r, i)), L(e.slice(i, e.length))]
						}(a))[0],
						f = (0, i.useState)((new Date).getFullYear())[0],
						m = (0, i.useState)(!1),
						g = m[0],
						v = m[1],
						y = (0, i.useState)("  0"),
						x = y[0],
						w = y[1],
						M = (0, i.useState)(!1),
						A = M[0],
						F = M[1],
						k = S(p),
						G = (0, i.useMemo)((function() {
							var e = (0, B.t)() ? "".concat(window.innerHeight, "px") : "100vh";
							return "calc(".concat(k / 100, " * (-").concat(e, " + ").concat(116, "px + 0.875em))")
						}), [k]),
						U = (0, i.useMemo)((function() {
							return D(k)
						}), [k]),
						z = function() {
							T.forEach((function(e) {
								(new Image).src = e
							})), R.L.preload(C)
						};
					return (0, i.useEffect)((function() {
						0 !== k && (v(!0), setTimeout((function() {
							w(D(k)), v(!1), 100 === k && (t(!0), d(!0))
						}), 1400), 100 === k && (z(), setTimeout((function() {
							c(!0)
						}), 4400)))
					}), [k]), (0, i.useEffect)((function() {
						F(!(0, B.t)())
					}), []), l ? null : (0, r.jsxs)("section", {
						className: _()(O().loader, N({}, O().wipeOut, h)),
						children: [(0, r.jsxs)("h3", {
							className: O().appDescription,
							children: ["Richard Ekwonye ", (0, r.jsx)("br", {}), " Portfolio \xa9", f]
						}), (0, r.jsx)("div", {
							className: _()(O().progress, N({}, O().fullContainer, A)),
							children: (0, r.jsxs)("div", {
								className: O().progressBlock,
								style: {
									transform: "translate3d(0, ".concat(G, ", 0)")
								},
								"aria-hidden": "true",
								children: [(0, r.jsx)(b.Z, {
									className: _()(O().progressValue, (I = {}, N(I, O().flipVal, g), N(I, O().singleTop, 0 === k), N(I, O().maxTop, 100 === k), I)),
									text: x,
									isStatic: !0
								}), (0, r.jsx)(b.Z, {
									className: _()(O().progressValue, (P = {}, N(P, O().flipVal, g), N(P, O().maxVal, 100 === k), P)),
									text: U,
									isStatic: !0
								})]
							})
						})]
					})
				},
				G = n(1664),
				U = n(6743),
				z = n(9346),
				V = n(3935),
				W = n(8595),
				j = n(3289),
				J = n.n(j);

			function X(e, t, n) {
				return t in e ? Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = n, e
			}
			var q = function(e) {
					var t = e.activePath,
						n = e.onClose,
						s = (0, i.useState)(!1),
						a = s[0],
						o = s[1],
						l = function(e) {
							t === e && o(!0)
						};
					return (0, i.useEffect)((function() {
						return document.body.style.overflow = "hidden",
							function() {
								document.body.style.overflow = ""
							}
					}), []), (0, V.createPortal)((0, r.jsxs)("section", {
						className: J().mobileMenu,
						children: [(0, r.jsx)("header", {
							children: (0, r.jsxs)(W.Z, {
								className: J().headerRow,
								animationDelay: .4,
								animateIntoView: !1,
								children: [(0, r.jsx)(G.default, {
									href: "/",
									scroll: !1,
									children: (0, r.jsx)("a", {
										children: "Richard Ekwonye"
									})
								}), (0, r.jsx)("span", {
									onClick: n,
									children: "Close"
								})]
							})
						}), (0, r.jsxs)("div", {
							className: J().menuContent,
							children: [(0, r.jsxs)("ul", {
								className: _()(J().navLinks, X({}, J().activeLinkUnderlinePassive, !a)),
								children: [(0, r.jsx)("li", {
									children: (0, r.jsx)(G.default, {
										href: "/",
										scroll: !1,
										children: (0, r.jsx)("a", {
											className: _()(X({}, J().activeNavLink, "/" === t)),
											children: (0, r.jsx)(b.Z, {
												text: "Home",
												className: J().navItem,
												animationDelay: .1,
												animateIntoView: !1,
												snapOnAnimationEnd: function() {
													return l("/")
												}
											})
										})
									})
								}), K.map((function(e, n) {
									var i = e.link,
										s = e.label;
									return (0, r.jsx)("li", {
										children: (0, r.jsx)(G.default, {
											href: i,
											scroll: !1,
											children: (0, r.jsx)("a", {
												className: _()(X({}, J().activeNavLink, t === i)),
												children: (0, r.jsx)(b.Z, {
													text: s,
													className: J().navItem,
													animationDelay: .1,
													animateIntoView: !1,
													snapOnAnimationEnd: function() {
														return l(i)
													}
												})
											})
										})
									}, n)
								})), (0, r.jsx)("li", {})]
							}), (0, r.jsx)(W.Z, {
								className: J().currentRole,
								animationDelay: .4,
								animateIntoView: !1,
								children: (0, r.jsxs)("p", {
									children: ["Currently Frontend ", (0, r.jsx)("br", {}), " Engineer at Wise"]
								})
							}), (0, r.jsx)(W.Z, {
								className: J().location,
								animationDelay: .4,
								animateIntoView: !1,
								children: (0, r.jsxs)("p", {
									children: ["Based in London ", (0, r.jsx)("br", {}), " United Kingdom"]
								})
							})]
						})]
					}), document.body)
				},
				K = [{
					link: "/work",
					label: "Work"
				}, {
					link: "/about",
					label: "About"
				}, {
					link: "/contact",
					label: "Contact"
				}],
				Y = n(2862),
				Q = n.n(Y);

			function Z(e, t, n) {
				return t in e ? Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = n, e
			}
			var $ = function() {
					var e = (0, i.useRef)(null),
						t = (0, i.useRef)(null),
						n = (0, s.useRouter)(),
						a = (0, i.useState)((0, B.t)())[0],
						o = (0, i.useState)(n.pathname)[0],
						l = (0, i.useState)(!1),
						c = l[0],
						u = l[1];
					return (0, r.jsx)("header", {
						className: _()(Q().header, Z({}, Q().stickyHeader, a)),
						children: (0, r.jsxs)(z.ZP, {
							inverseElementRefs: [e, t],
							children: [(0, r.jsxs)("div", {
								className: Q().headerGrid,
								children: [(0, r.jsx)("div", {
									ref: e,
									className: Q().title,
									children: (0, r.jsx)(G.default, {
										href: "/",
										scroll: !1,
										children: (0, r.jsx)("a", {
											children: "Richard Ekwonye"
										})
									})
								}), (0, r.jsx)("div", {
									className: Q().currentRole,
									children: (0, r.jsxs)("p", {
										children: ["Currently Frontend ", (0, r.jsx)("br", {}), " Engineer at Wise"]
									})
								}), (0, r.jsx)("div", {
									className: Q().location,
									children: (0, r.jsxs)("p", {
										children: ["Based in London ", (0, r.jsx)("br", {}), " United Kingdom"]
									})
								}), (0, r.jsxs)("div", {
									ref: t,
									className: Q().navArea,
									children: [(0, r.jsx)("nav", {
										className: Q().lgNav,
										children: K.map((function(e, t) {
											var n = e.link,
												s = e.label;
											return (0, r.jsxs)(i.Fragment, {
												children: [(0, r.jsx)(G.default, {
													href: n,
													scroll: !1,
													children: (0, r.jsx)("a", {
														className: _()(Q().navLink, Z({}, Q().active, o === n)),
														children: s
													})
												}), t !== K.length - 1 && ", "]
											}, t)
										}))
									}), (0, r.jsx)("nav", {
										className: Q().mobileNav,
										children: (0, r.jsx)("span", {
											className: Q().mobileMenu,
											onClick: function() {
												return u(!0)
											},
											children: "Menu"
										})
									})]
								})]
							}), (0, r.jsx)(U.Z, {
								in: c,
								timeout: 700,
								classNames: {
									exitActive: Q().mobileMenuExit
								},
								unmountOnExit: !0,
								children: (0, r.jsx)(q, {
									activePath: o,
									onClose: function() {
										return u(!1)
									}
								})
							})]
						})
					})
				},
				ee = n(6439),
				te = n.n(ee),
				ne = function() {
					return (0, r.jsx)("footer", {
						className: te().footer,
						children: (0, r.jsx)(z.ZP, {
							children: (0, r.jsxs)(W.Z, {
								className: te().footerGrid,
								children: [(0, r.jsxs)("div", {
									className: te().title,
									children: ["Richard Ekwonye ", (0, r.jsx)("br", {}), " Creative developer"]
								}), (0, r.jsxs)("div", {
									className: te().socialLinks,
									children: [(0, r.jsx)("a", {
										href: "https://twitter.com/ekwonye",
										rel: "noreferrer",
										target: "_blank",
										children: "Twitter"
									}), ",", " ", (0, r.jsx)("a", {
										href: "https://www.instagram.com/ekwonyenoob",
										rel: "noreferrer",
										target: "_blank",
										children: "Instagram"
									}), ",", " ", (0, r.jsx)("a", {
										href: "https://github.com/ekwonye-richard",
										rel: "noreferrer",
										target: "_blank",
										children: "Github"
									})]
								}), (0, r.jsxs)("div", {
									className: te().team,
									children: [(0, r.jsx)("div", {
										children: "Development Richard Ekwonye"
									}), (0, r.jsxs)("div", {
										children: ["Design", " ", (0, r.jsx)("a", {
											href: "https://www.gilhuybrecht.com",
											rel: "noreferrer",
											target: "_blank",
											children: "Gil Huybrecht"
										})]
									})]
								})]
							})
						})
					})
				},
				re = n(8959),
				ie = n.n(re);
			var se = function(e) {
					var t, n, i, s = e.children,
						a = e.state,
						o = "entered" === a,
						l = "exiting" === a;
					return (0, r.jsx)(r.Fragment, {
						children: (0, r.jsx)("div", {
							className: _()(ie().layout, (t = {}, n = ie().exiting, i = l, n in t ? Object.defineProperty(t, n, {
								value: i,
								enumerable: !0,
								configurable: !0,
								writable: !0
							}) : t[n] = i, t)),
							children: (o || l) && (0, r.jsxs)(r.Fragment, {
								children: [(0, r.jsx)($, {}), (0, r.jsx)("main", {
									className: ie().main,
									children: s
								}), (0, r.jsx)(ne, {})]
							})
						})
					})
				},
				ae = function() {
					return (0, V.createPortal)((0, r.jsx)("div", {
						className: ie().layoutWipe
					}), document.body)
				};

			function oe(e, t, n) {
				return t in e ? Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = n, e
			}

			function le(e) {
				for (var t = 1; t < arguments.length; t++) {
					var n = null != arguments[t] ? arguments[t] : {},
						r = Object.keys(n);
					"function" === typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
						return Object.getOwnPropertyDescriptor(n, e).enumerable
					})))), r.forEach((function(t) {
						oe(e, t, n[t])
					}))
				}
				return e
			}

			function ce(e) {
				return function(e) {
					if (Array.isArray(e)) {
						for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
						return n
					}
				}(e) || function(e) {
					if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
				}(e) || function() {
					throw new TypeError("Invalid attempt to spread non-iterable instance")
				}()
			}
			var ue, he = "G-Y4HDN4GTXS";
			ue = 1050, s.default.events.on("beforeHistoryChange", (function() {
				var e = ce(document.querySelectorAll("link[rel=stylesheet], style:not([media=x])")).map((function(e) {
						return e.cloneNode(!0)
					})),
					t = !0,
					n = !1,
					r = void 0;
				try {
					for (var i, a = e[Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
						var o = i.value;
						o.removeAttribute("data-n-p"), o.removeAttribute("data-n-href"), document.head.appendChild(o)
					}
				} catch (c) {
					n = !0, r = c
				} finally {
					try {
						t || null == a.return || a.return()
					} finally {
						if (n) throw r
					}
				}
				var l = function() {
					s.default.events.off("routeChangeComplete", l), window.setTimeout((function() {
						var t = !0,
							n = !1,
							r = void 0;
						try {
							for (var i, s = e[Symbol.iterator](); !(t = (i = s.next()).done); t = !0) {
								var a = i.value;
								document.head.removeChild(a)
							}
						} catch (c) {
							n = !0, r = c
						} finally {
							try {
								t || null == s.return || s.return()
							} finally {
								if (n) throw r
							}
						}
					}), ue)
				};
				s.default.events.on("routeChangeComplete", l)
			}));
			var de = function(e) {
				var t = e.Component,
					n = e.pageProps,
					l = (0, s.useRouter)(),
					c = (0, i.useState)(!1),
					u = c[0],
					h = c[1],
					d = (0, i.useState)(l.pathname)[0],
					p = (0, i.useState)(!1),
					f = p[0],
					m = p[1];
				return (0, i.useEffect)((function() {
					f || l.pathname === d || m(!0)
				}), [l]), (0, i.useEffect)((function() {
					(0, z.ou)(), "/404" === l.pathname ? l.push(l.pathname) : l.push(l.asPath)
				}), []), (0, i.useEffect)((function() {
					var e = function(e) {
						! function(e) {
							window.gtag("config", "G-Y4HDN4GTXS", {
								page_path: e
							})
						}(e)
					};
					return l.events.on("routeChangeComplete", e),
						function() {
							l.events.off("routeChangeComplete", e)
						}
				}), [l.events]), (0, r.jsxs)(r.Fragment, {
					children: [(0, r.jsxs)(a.default, {
						children: [(0, r.jsx)("title", {
							children: "Richard Ekwonye"
						}), (0, r.jsx)("meta", {
							name: "description",
							content: "Creative developer passionate about building appealing and interactive web experiences."
						}), (0, r.jsx)("meta", {
							property: "twitter:card",
							content: "summary_large_image"
						}), (0, r.jsx)("meta", {
							property: "twitter:url",
							content: "https://www.richardekwonye.com/"
						}), (0, r.jsx)("meta", {
							property: "twitter:title",
							content: "Richard Ekwonye"
						}), (0, r.jsx)("meta", {
							property: "twitter:description",
							content: "Creative developer passionate about building appealing and interactive web experiences."
						}), (0, r.jsx)("meta", {
							property: "twitter:image",
							content: "https://www.richardekwonye.com/images/app-cover.png"
						}), (0, r.jsx)("meta", {
							property: "og:type",
							content: "website"
						}), (0, r.jsx)("meta", {
							property: "og:url",
							content: "https://www.richardekwonye.com/"
						}), (0, r.jsx)("meta", {
							property: "og:title",
							content: "Richard Ekwonye"
						}), (0, r.jsx)("meta", {
							property: "og:description",
							content: "Creative developer building appealing and interactive web experiences."
						}), (0, r.jsx)("meta", {
							property: "og:image",
							content: "https://www.richardekwonye.com/images/app-cover.png"
						}), (0, r.jsx)("link", {
							rel: "icon",
							href: "/favicon.ico"
						}), (0, r.jsx)("link", {
							rel: "apple-touch-icon",
							sizes: "180x180",
							href: "/apple-touch-icon.png"
						}), (0, r.jsx)("link", {
							rel: "icon",
							type: "image/png",
							sizes: "32x32",
							href: "/favicon-32x32.png"
						}), (0, r.jsx)("link", {
							rel: "icon",
							type: "image/png",
							sizes: "16x16",
							href: "/favicon-16x16.png"
						}), (0, r.jsx)("meta", {
							name: "theme-color",
							content: "#e1dfdd"
						})]
					}), (0, r.jsx)(o.default, {
						strategy: "afterInteractive",
						src: "https://www.googletagmanager.com/gtag/js?id=".concat(he)
					}), (0, r.jsx)(o.default, {
						id: "gtag-init",
						strategy: "afterInteractive",
						dangerouslySetInnerHTML: {
							__html: "\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', '".concat(he, "', {\n              page_path: window.location.pathname,\n            });\n          ")
						}
					}), (0, r.jsx)(k, {
						onComplete: h
					}), f && (0, r.jsx)(ae, {}, l.pathname), u && (0, r.jsx)(v, {
						children: (0, r.jsx)(y.ZP, {
							timeout: {
								enter: 1050,
								exit: 1030
							},
							onEntered: function() {
								return window.scrollTo(0, 0)
							},
							children: function(e) {
								return (0, r.jsx)(se, {
									state: e,
									children: (0, r.jsx)(t, le({}, n))
								})
							}
						}, l.pathname)
					})]
				})
			}
		},
		9831: function(e, t, n) {
			"use strict";
			var r = {};
			n.r(r), n.d(r, {
				FunctionToString: function() {
					return a.c
				},
				InboundFilters: function() {
					return o.Q
				}
			});
			var i = {};
			n.r(i), n.d(i, {
				Breadcrumbs: function() {
					return h.O
				},
				Dedupe: function() {
					return f.I
				},
				GlobalHandlers: function() {
					return c.d
				},
				LinkedErrors: function() {
					return d.iP
				},
				TryCatch: function() {
					return u.p
				},
				UserAgent: function() {
					return p.Z
				}
			});
			var s = n(655),
				a = n(9116),
				o = n(2422),
				l = n(2991),
				c = n(2136),
				u = n(3692),
				h = n(1861),
				d = n(1634),
				p = n(3931),
				f = n(9730),
				m = {},
				g = (0, l.R)();
			g.Sentry && g.Sentry.Integrations && (m = g.Sentry.Integrations);
			var v = (0, s.pi)((0, s.pi)((0, s.pi)({}, m), r), i),
				y = n(105),
				x = n(1802);
			var _ = n(9666),
				b = n(2758),
				w = n(2343),
				M = n(6458),
				A = n(3233),
				S = n(6257),
				E = (0, l.R)();
			var T = n(1422),
				C = n(1170),
				B = n(8464),
				R = function(e, t, n) {
					var r;
					return function(i) {
						t.value >= 0 && (i || n) && (t.delta = t.value - (r || 0), (t.delta || void 0 === r) && (r = t.value, e(t)))
					}
				},
				L = function(e, t) {
					return {
						name: e,
						value: null !== t && void 0 !== t ? t : -1,
						delta: 0,
						entries: [],
						id: "v2-" + Date.now() + "-" + (Math.floor(8999999999999 * Math.random()) + 1e12)
					}
				},
				I = function(e, t) {
					try {
						if (PerformanceObserver.supportedEntryTypes.includes(e)) {
							if ("first-input" === e && !("PerformanceEventTiming" in self)) return;
							var n = new PerformanceObserver((function(e) {
								return e.getEntries().map(t)
							}));
							return n.observe({
								type: e,
								buffered: !0
							}), n
						}
					} catch (r) {}
				},
				P = function(e, t) {
					var n = function(r) {
						"pagehide" !== r.type && "hidden" !== (0, l.R)().document.visibilityState || (e(r), t && (removeEventListener("visibilitychange", n, !0), removeEventListener("pagehide", n, !0)))
					};
					addEventListener("visibilitychange", n, !0), addEventListener("pagehide", n, !0)
				},
				D = -1,
				F = function() {
					return D < 0 && (D = "hidden" === (0, l.R)().document.visibilityState ? 0 : 1 / 0, P((function(e) {
						var t = e.timeStamp;
						D = t
					}), !0)), {
						get firstHiddenTime() {
							return D
						}
					}
				},
				O = {},
				N = (0, l.R)(),
				H = function() {
					function e(e) {
						void 0 === e && (e = !1), this._reportAllChanges = e, this._measurements = {}, this._performanceCursor = 0, !(0, T.KV)() && N && N.performance && N.document && (N.performance.mark && N.performance.mark("sentry-tracing-init"), this._trackCLS(), this._trackLCP(), this._trackFID())
					}
					return e.prototype.addPerformanceEntries = function(e) {
						var t = this;
						if (N && N.performance && N.performance.getEntries && C.Z1) {
							w.k.log("[Tracing] Adding & adjusting spans using Performance API");
							var n, r, i = (0, A.XL)(C.Z1);
							if (N.performance.getEntries().slice(this._performanceCursor).forEach((function(s) {
									var a = (0, A.XL)(s.startTime),
										o = (0, A.XL)(s.duration);
									if (!("navigation" === e.op && i + a < e.startTimestamp)) switch (s.entryType) {
										case "navigation":
											! function(e, t, n) {
												["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((function(r) {
														k(e, t, r, n)
													})), k(e, t, "secureConnection", n, "TLS/SSL", "connectEnd"), k(e, t, "fetch", n, "cache", "domainLookupStart"), k(e, t, "domainLookup", n, "DNS"),
													function(e, t, n) {
														G(e, {
															op: "browser",
															description: "request",
															startTimestamp: n + (0, A.XL)(t.requestStart),
															endTimestamp: n + (0, A.XL)(t.responseEnd)
														}), G(e, {
															op: "browser",
															description: "response",
															startTimestamp: n + (0, A.XL)(t.responseStart),
															endTimestamp: n + (0, A.XL)(t.responseEnd)
														})
													}(e, t, n)
											}(e, s, i), n = i + (0, A.XL)(s.responseStart), r = i + (0, A.XL)(s.requestStart);
											break;
										case "mark":
										case "paint":
										case "measure":
											var l = function(e, t, n, r, i) {
													var s = i + n,
														a = s + r;
													return G(e, {
														description: t.name,
														endTimestamp: a,
														op: t.entryType,
														startTimestamp: s
													}), s
												}(e, s, a, o, i),
												c = F(),
												u = s.startTime < c.firstHiddenTime;
											"first-paint" === s.name && u && (w.k.log("[Measurements] Adding FP"), t._measurements.fp = {
												value: s.startTime
											}, t._measurements["mark.fp"] = {
												value: l
											}), "first-contentful-paint" === s.name && u && (w.k.log("[Measurements] Adding FCP"), t._measurements.fcp = {
												value: s.startTime
											}, t._measurements["mark.fcp"] = {
												value: l
											});
											break;
										case "resource":
											var h = s.name.replace(N.location.origin, "");
											! function(e, t, n, r, i, s) {
												if ("xmlhttprequest" === t.initiatorType || "fetch" === t.initiatorType) return;
												var a = {};
												"transferSize" in t && (a["Transfer Size"] = t.transferSize);
												"encodedBodySize" in t && (a["Encoded Body Size"] = t.encodedBodySize);
												"decodedBodySize" in t && (a["Decoded Body Size"] = t.decodedBodySize);
												var o = s + r;
												G(e, {
													description: n,
													endTimestamp: o + i,
													op: t.initiatorType ? "resource." + t.initiatorType : "resource",
													startTimestamp: o,
													data: a
												})
											}(e, s, h, a, o, i)
									}
								})), this._performanceCursor = Math.max(performance.getEntries().length - 1, 0), this._trackNavigator(e), "pageload" === e.op) {
								var s = (0, A.XL)(C.Z1);
								"number" === typeof n && (w.k.log("[Measurements] Adding TTFB"), this._measurements.ttfb = {
										value: 1e3 * (n - e.startTimestamp)
									}, "number" === typeof r && r <= n && (this._measurements["ttfb.requestTime"] = {
										value: 1e3 * (n - r)
									})), ["fcp", "fp", "lcp"].forEach((function(n) {
										if (t._measurements[n] && !(s >= e.startTimestamp)) {
											var r = t._measurements[n].value,
												i = s + (0, A.XL)(r),
												a = Math.abs(1e3 * (i - e.startTimestamp)),
												o = a - r;
											w.k.log("[Measurements] Normalized " + n + " from " + r + " to " + a + " (" + o + ")"), t._measurements[n].value = a
										}
									})), this._measurements["mark.fid"] && this._measurements.fid && G(e, {
										description: "first input delay",
										endTimestamp: this._measurements["mark.fid"].value + (0, A.XL)(this._measurements.fid.value),
										op: "web.vitals",
										startTimestamp: this._measurements["mark.fid"].value
									}), "fcp" in this._measurements || delete this._measurements.cls, e.setMeasurements(this._measurements),
									function(e, t, n) {
										t && (w.k.log("[Measurements] Adding LCP Data"), t.element && e.setTag("lcp.element", (0, B.R)(t.element)), t.id && e.setTag("lcp.id", t.id), t.url && e.setTag("lcp.url", t.url.trim().slice(0, 200)), e.setTag("lcp.size", t.size));
										n && n.sources && (w.k.log("[Measurements] Adding CLS Data"), n.sources.forEach((function(t, n) {
											return e.setTag("cls.source." + (n + 1), (0, B.R)(t.node))
										})))
									}(e, this._lcpEntry, this._clsEntry), e.setTag("sentry_reportAllChanges", this._reportAllChanges)
							}
						}
					}, e.prototype._trackNavigator = function(e) {
						var t = N.navigator;
						if (t) {
							var n = t.connection;
							n && (n.effectiveType && e.setTag("effectiveConnectionType", n.effectiveType), n.type && e.setTag("connectionType", n.type), U(n.rtt) && (this._measurements["connection.rtt"] = {
								value: n.rtt
							}), U(n.downlink) && (this._measurements["connection.downlink"] = {
								value: n.downlink
							})), U(t.deviceMemory) && e.setTag("deviceMemory", String(t.deviceMemory)), U(t.hardwareConcurrency) && e.setTag("hardwareConcurrency", String(t.hardwareConcurrency))
						}
					}, e.prototype._trackCLS = function() {
						var e = this;
						! function(e, t) {
							var n, r = L("CLS", 0),
								i = 0,
								s = [],
								a = function(e) {
									if (e && !e.hadRecentInput) {
										var t = s[0],
											a = s[s.length - 1];
										i && 0 !== s.length && e.startTime - a.startTime < 1e3 && e.startTime - t.startTime < 5e3 ? (i += e.value, s.push(e)) : (i = e.value, s = [e]), i > r.value && (r.value = i, r.entries = s, n && n())
									}
								},
								o = I("layout-shift", a);
							o && (n = R(e, r, t), P((function() {
								o.takeRecords().map(a), n(!0)
							})))
						}((function(t) {
							var n = t.entries.pop();
							n && (w.k.log("[Measurements] Adding CLS"), e._measurements.cls = {
								value: t.value
							}, e._clsEntry = n)
						}))
					}, e.prototype._trackLCP = function() {
						var e = this;
						! function(e, t) {
							var n, r = F(),
								i = L("LCP"),
								s = function(e) {
									var t = e.startTime;
									t < r.firstHiddenTime && (i.value = t, i.entries.push(e)), n && n()
								},
								a = I("largest-contentful-paint", s);
							if (a) {
								n = R(e, i, t);
								var o = function() {
									O[i.id] || (a.takeRecords().map(s), a.disconnect(), O[i.id] = !0, n(!0))
								};
								["keydown", "click"].forEach((function(e) {
									addEventListener(e, o, {
										once: !0,
										capture: !0
									})
								})), P(o, !0)
							}
						}((function(t) {
							var n = t.entries.pop();
							if (n) {
								var r = (0, A.XL)(C.Z1),
									i = (0, A.XL)(n.startTime);
								w.k.log("[Measurements] Adding LCP"), e._measurements.lcp = {
									value: t.value
								}, e._measurements["mark.lcp"] = {
									value: r + i
								}, e._lcpEntry = n
							}
						}), this._reportAllChanges)
					}, e.prototype._trackFID = function() {
						var e = this;
						! function(e, t) {
							var n, r = F(),
								i = L("FID"),
								s = function(e) {
									n && e.startTime < r.firstHiddenTime && (i.value = e.processingStart - e.startTime, i.entries.push(e), n(!0))
								},
								a = I("first-input", s);
							a && (n = R(e, i, t), P((function() {
								a.takeRecords().map(s), a.disconnect()
							}), !0))
						}((function(t) {
							var n = t.entries.pop();
							if (n) {
								var r = (0, A.XL)(C.Z1),
									i = (0, A.XL)(n.startTime);
								w.k.log("[Measurements] Adding FID"), e._measurements.fid = {
									value: t.value
								}, e._measurements["mark.fid"] = {
									value: r + i
								}
							}
						}))
					}, e
				}();

			function k(e, t, n, r, i, s) {
				var a = s ? t[s] : t[n + "End"],
					o = t[n + "Start"];
				o && a && G(e, {
					op: "browser",
					description: null !== i && void 0 !== i ? i : n,
					startTimestamp: r + (0, A.XL)(o),
					endTimestamp: r + (0, A.XL)(a)
				})
			}

			function G(e, t) {
				var n = t.startTimestamp,
					r = (0, s._T)(t, ["startTimestamp"]);
				return n && e.startTimestamp > n && (e.startTimestamp = n), e.startChild((0, s.pi)({
					startTimestamp: n
				}, r))
			}

			function U(e) {
				return "number" === typeof e && isFinite(e)
			}
			var z = n(7321),
				V = n(9732),
				W = n(7597),
				j = {
					traceFetch: !0,
					traceXHR: !0,
					tracingOrigins: ["localhost", /^\//]
				};

			function J(e) {
				var t = (0, s.pi)((0, s.pi)({}, j), e),
					n = t.traceFetch,
					r = t.traceXHR,
					i = t.tracingOrigins,
					a = t.shouldCreateSpanForRequest,
					o = {},
					l = function(e) {
						if (o[e]) return o[e];
						var t = i;
						return o[e] = t.some((function(t) {
							return (0, z.zC)(e, t)
						})) && !(0, z.zC)(e, "sentry_key"), o[e]
					},
					c = l;
				"function" === typeof a && (c = function(e) {
					return l(e) && a(e)
				});
				var u = {};
				n && (0, V.o)("fetch", (function(e) {
					! function(e, t, n) {
						if (!(0, A.zu)() || !e.fetchData || !t(e.fetchData.url)) return;
						if (e.endTimestamp) {
							var r = e.fetchData.__span;
							if (!r) return;
							return void((a = n[r]) && (e.response ? a.setHttpStatus(e.response.status) : e.error && a.setStatus("internal_error"), a.finish(), delete n[r]))
						}
						var i = (0, A.x1)();
						if (i) {
							var a = i.startChild({
								data: (0, s.pi)((0, s.pi)({}, e.fetchData), {
									type: "fetch"
								}),
								description: e.fetchData.method + " " + e.fetchData.url,
								op: "http.client"
							});
							e.fetchData.__span = a.spanId, n[a.spanId] = a;
							var o = e.args[0] = e.args[0],
								l = e.args[1] = e.args[1] || {},
								c = l.headers;
							(0, W.V9)(o, Request) && (c = o.headers), c ? "function" === typeof c.append ? c.append("sentry-trace", a.toTraceparent()) : c = Array.isArray(c) ? (0, s.fl)(c, [
								["sentry-trace", a.toTraceparent()]
							]) : (0, s.pi)((0, s.pi)({}, c), {
								"sentry-trace": a.toTraceparent()
							}) : c = {
								"sentry-trace": a.toTraceparent()
							}, l.headers = c
						}
					}(e, c, u)
				})), r && (0, V.o)("xhr", (function(e) {
					! function(e, t, n) {
						if (!(0, A.zu)() || e.xhr && e.xhr.__sentry_own_request__ || !(e.xhr && e.xhr.__sentry_xhr__ && t(e.xhr.__sentry_xhr__.url))) return;
						var r = e.xhr.__sentry_xhr__;
						if (e.endTimestamp) {
							var i = e.xhr.__sentry_xhr_span_id__;
							if (!i) return;
							return void((o = n[i]) && (o.setHttpStatus(r.status_code), o.finish(), delete n[i]))
						}
						var a = (0, A.x1)();
						if (a) {
							var o = a.startChild({
								data: (0, s.pi)((0, s.pi)({}, r.data), {
									type: "xhr",
									method: r.method,
									url: r.url
								}),
								description: r.method + " " + r.url,
								op: "http.client"
							});
							if (e.xhr.__sentry_xhr_span_id__ = o.spanId, n[e.xhr.__sentry_xhr_span_id__] = o, e.xhr.setRequestHeader) try {
								e.xhr.setRequestHeader("sentry-trace", o.toTraceparent())
							} catch (l) {}
						}
					}(e, c, u)
				}))
			}
			var X = (0, l.R)();
			var q = (0, s.pi)({
					idleTimeout: M.nT,
					markBackgroundTransactions: !0,
					maxTransactionDuration: 600,
					routingInstrumentation: function(e, t, n) {
						if (void 0 === t && (t = !0), void 0 === n && (n = !0), X && X.location) {
							var r, i = X.location.href;
							t && (r = e({
								name: X.location.pathname,
								op: "pageload"
							})), n && (0, V.o)("history", (function(t) {
								var n = t.to,
									s = t.from;
								void 0 === s && i && -1 !== i.indexOf(n) ? i = void 0 : s !== n && (i = void 0, r && (w.k.log("[Tracing] Finishing current transaction with op: " + r.op), r.finish()), r = e({
									name: X.location.pathname,
									op: "navigation"
								}))
							}))
						} else w.k.warn("Could not initialize routing instrumentation due to invalid location")
					},
					startTransactionOnLocationChange: !0,
					startTransactionOnPageLoad: !0
				}, j),
				K = function() {
					function e(t) {
						this.name = e.id, this._emitOptionsWarning = !1, this._configuredIdleTimeout = void 0;
						var n = j.tracingOrigins;
						t && (this._configuredIdleTimeout = t.idleTimeout, t.tracingOrigins && Array.isArray(t.tracingOrigins) && 0 !== t.tracingOrigins.length ? n = t.tracingOrigins : this._emitOptionsWarning = !0), this.options = (0, s.pi)((0, s.pi)((0, s.pi)({}, q), t), {
							tracingOrigins: n
						});
						var r = this.options._metricOptions;
						this._metrics = new H(r && r._reportAllChanges)
					}
					return e.prototype.setupOnce = function(e, t) {
						var n = this;
						this._getCurrentHub = t, this._emitOptionsWarning && (w.k.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace."), w.k.warn("[Tracing] We added a reasonable default for you: " + j.tracingOrigins));
						var r = this.options,
							i = r.routingInstrumentation,
							s = r.startTransactionOnLocationChange,
							a = r.startTransactionOnPageLoad,
							o = r.markBackgroundTransactions,
							l = r.traceFetch,
							c = r.traceXHR,
							u = r.tracingOrigins,
							h = r.shouldCreateSpanForRequest;
						i((function(e) {
							return n._createRouteTransaction(e)
						}), a, s), o && (E && E.document ? E.document.addEventListener("visibilitychange", (function() {
							var e = (0, A.x1)();
							if (E.document.hidden && e) {
								var t = "cancelled";
								w.k.log("[Tracing] Transaction: cancelled -> since tab moved to the background, op: " + e.op), e.status || e.setStatus(t), e.setTag("visibilitychange", "document.hidden"), e.setTag(S.d, S.x[2]), e.finish()
							}
						})) : w.k.warn("[Tracing] Could not set up background tab detection due to lack of global document")), J({
							traceFetch: l,
							traceXHR: c,
							tracingOrigins: u,
							shouldCreateSpanForRequest: h
						})
					}, e.prototype._createRouteTransaction = function(e) {
						var t = this;
						if (this._getCurrentHub) {
							var n = this.options,
								r = n.beforeNavigate,
								i = n.idleTimeout,
								a = n.maxTransactionDuration,
								o = "pageload" === e.op ? function() {
									var e = function(e) {
										var t = (0, l.R)().document.querySelector("meta[name=" + e + "]");
										return t ? t.getAttribute("content") : null
									}("sentry-trace");
									if (e) return (0, A.qG)(e);
									return
								}() : void 0,
								c = (0, s.pi)((0, s.pi)((0, s.pi)({}, e), o), {
									trimEnd: !0
								}),
								u = "function" === typeof r ? r(c) : c,
								h = void 0 === u ? (0, s.pi)((0, s.pi)({}, c), {
									sampled: !1
								}) : u;
							!1 === h.sampled && w.k.log("[Tracing] Will not send " + h.op + " transaction because of beforeNavigate."), w.k.log("[Tracing] Starting " + h.op + " transaction on scope");
							var d = this._getCurrentHub(),
								p = (0, l.R)().location,
								f = (0, b.lb)(d, h, i, !0, {
									location: p
								});
							return f.registerBeforeFinishCallback((function(e, n) {
								t._metrics.addPerformanceEntries(e),
									function(e, t, n) {
										var r = n - t.startTimestamp;
										n && (r > e || r < 0) && (t.setStatus("deadline_exceeded"), t.setTag("maxTransactionDurationExceeded", "true"))
									}((0, A.WB)(a), e, n)
							})), f.setTag("idleTimeout", this._configuredIdleTimeout), f
						}
						w.k.warn("[Tracing] Did not create " + e.op + " transaction because _getCurrentHub is invalid.")
					}, e.id = "BrowserTracing", e
				}();
			(0, b.ro)();
			var Y = n(2844),
				Q = n(8252),
				Z = n(1163),
				$ = (0, l.R)(),
				ee = {
					"routing.instrumentation": "next-router"
				},
				te = void 0,
				ne = void 0,
				re = void 0;

			function ie(e, t, n) {
				void 0 === t && (t = !0), void 0 === n && (n = !0), re = e, Z.default.ready((function() {
					if (t && (ne = null !== Z.default.route ? (0, Y.rt)(Z.default.route) : $.location.pathname, te = e({
							name: ne,
							op: "pageload",
							tags: ee
						})), n) {
						var r = Object.getPrototypeOf(Z.default.router);
						(0, Q.hl)(r, "changeState", se)
					}
				}))
			}

			function se(e) {
				return function(t, n, r, i) {
					for (var a = [], o = 4; o < arguments.length; o++) a[o - 4] = arguments[o];
					var l = (0, Y.rt)(n);
					if (void 0 !== re && ne !== l) {
						te && te.finish();
						var c = (0, s.pi)((0, s.pi)((0, s.pi)({}, ee), {
							method: t
						}), i);
						ne && (c.from = ne), te = re({
							name: ne = l,
							op: "navigation",
							tags: c
						})
					}
					return e.call.apply(e, (0, s.fl)([this, t, n, r, i], a))
				}
			}

			function ae(e, t, n) {
				var r = t.match(/([a-z]+)\.(.*)/i);
				null === r ? e[t] = n : ae(e[r[1]], r[2], n)
			}

			function oe(e, t, n) {
				return void 0 === n && (n = {}), Array.isArray(t) ? le(e, t, n) : function(e, t, n) {
					return function(r) {
						var i = t(r);
						return le(e, i, n)
					}
				}(e, t, n)
			}

			function le(e, t, n) {
				for (var r = !1, i = 0; i < t.length; i++) {
					t[i].name === e.name && (r = !0);
					var a = n[t[i].name];
					a && ae(t[i], a.keyPath, a.value)
				}
				return r ? t : (0, s.fl)(t, [e])
			}(0, s.pi)((0, s.pi)({}, v), {
				BrowserTracing: K
			});
			var ce = new K({
				tracingOrigins: (0, s.fl)(j.tracingOrigins, [/^(api\/)/]),
				routingInstrumentation: ie
			});
			! function(e) {
				! function(e, t) {
					e._metadata = e._metadata || {}, e._metadata.sdk = e._metadata.sdk || {
						name: "sentry.javascript.nextjs",
						packages: t.map((function(e) {
							return {
								name: "npm:@sentry/" + e,
								version: y.J
							}
						})),
						version: y.J
					}
				}(e, ["nextjs", "react"]), e.environment = e.environment || "production";
				var t = void 0 === e.tracesSampleRate && void 0 === e.tracesSampler ? e.integrations : function(e) {
					return e ? oe(ce, e, {
						BrowserTracing: {
							keyPath: "options.routingInstrumentation",
							value: ie
						}
					}) : [ce]
				}(e.integrations);
				! function(e) {
					e._metadata = e._metadata || {}, e._metadata.sdk = e._metadata.sdk || {
						name: "sentry.javascript.react",
						packages: [{
							name: "npm:@sentry/react",
							version: y.J
						}],
						version: y.J
					}, (0, x.S1)(e)
				}((0, s.pi)((0, s.pi)({}, e), {
					integrations: t
				})), (0, _.e)((function(e) {
					e.setTag("runtime", "browser"), e.addEventProcessor((function(e) {
						return "transaction" === e.type && "/404" === e.transaction ? null : e
					}))
				}))
			}({
				dsn: n(4155).env.SENTRY_DSN || "https://fd3fb4fdfbea449c90e60893c18823a2@o335756.ingest.sentry.io/6188458" || "https://fd3fb4fdfbea449c90e60893c18823a2@o335756.ingest.sentry.io/6188458",
				tracesSampleRate: 1
			})
		},
		2336: function(e, t, n) {
			"use strict";
			n.d(t, {
				Z: function() {
					return u
				}
			});
			var r = n(5893),
				i = n(7294),
				s = n(4184),
				a = n.n(s);

			function o(e) {
				return function(e) {
					if (Array.isArray(e)) {
						for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
						return n
					}
				}(e) || function(e) {
					if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
				}(e) || function() {
					throw new TypeError("Invalid attempt to spread non-iterable instance")
				}()
			}
			var l = n(6187),
				c = n.n(l);
			var u = function(e) {
				var t = e.text,
					n = e.className,
					s = e.isStatic,
					l = e.animationDelay,
					u = e.animateIntoView,
					h = void 0 === u || u,
					d = e.snapOnAnimationEnd,
					p = e.intersectionThreshold,
					f = e.intersectionRootMargin,
					m = e.withoutSrText,
					g = e.srText,
					v = (0, i.useState)(!1),
					y = v[0],
					x = v[1],
					_ = (0, i.useMemo)((function() {
						return t.split("")
					}), [t]),
					b = (0, i.useRef)(null),
					w = function() {
						x(!0)
					};
				return (0, i.useEffect)((function() {
					s || function(e) {
						var t = e.containerRef,
							n = e.staticReset,
							r = e.animationDelay,
							i = void 0 === r ? 0 : r,
							s = e.animateIntoView,
							a = e.snapOnAnimationEnd,
							l = e.intersectionThreshold,
							c = void 0 === l ? .2 : l,
							u = e.intersectionRootMargin,
							h = t.current,
							d = o(h.children);
						d.shift();
						var p = d.pop(),
							f = d[0],
							m = f.offsetHeight,
							g = !1,
							v = function() {
								m !== f.offsetHeight && g && (m = f.offsetHeight, d.forEach((function(e, t) {
									var n = e,
										r = p.children[t];
									r.style.height = "".concat(n.offsetHeight, "px");
									var i = n.getBoundingClientRect().left - h.getBoundingClientRect().left;
									r.style.left = "".concat(i, "px")
								})))
							};
						window.addEventListener("resize", v);
						var y = new IntersectionObserver((function(e) {
								e.forEach((function(e) {
									e.isIntersecting || x()
								}))
							})),
							x = function() {
								window.removeEventListener("resize", v), window.removeEventListener("resize", x), y.unobserve(h), n()
							},
							_ = function() {
								d.forEach((function(e, t) {
									var n = e,
										r = document.createElement("span");
									r.innerHTML = n.innerHTML, r.style.animationDelay = "".concat(i + .07 * t, "s"), r.style.height = "".concat(n.offsetHeight, "px");
									var s = n.getBoundingClientRect().left - h.getBoundingClientRect().left;
									r.style.left = "".concat(s, "px"), a && t === d.length - 3 && (r.onanimationend = a), t === d.length - 1 && (r.onanimationend = function() {
										y.observe(h), window.addEventListener("resize", x)
									}), p.appendChild(r)
								})), g = !0
							};
						if (s) {
							var b = new IntersectionObserver((function(e) {
								e.forEach((function(e) {
									e.isIntersecting && (_(), b.unobserve(h))
								}))
							}), {
								threshold: c,
								rootMargin: u
							});
							b.observe(h)
						} else _()
					}({
						containerRef: b,
						staticReset: w,
						animationDelay: l,
						animateIntoView: h,
						snapOnAnimationEnd: d,
						intersectionThreshold: p,
						intersectionRootMargin: f
					})
				}), []), (0, r.jsx)("span", {
					ref: b,
					className: a()(c().bigText, n),
					children: s ? _.map((function(e, t) {
						return (0, r.jsx)("span", {
							children: e
						}, t)
					})) : (0, r.jsxs)(r.Fragment, {
						children: [(0, r.jsx)("span", {
							className: c().srText,
							children: !m && (g || t)
						}), _.map((function(e, t) {
							return (0, r.jsx)("span", {
								className: a()((n = {}, i = c().passive, s = !y, i in n ? Object.defineProperty(n, i, {
									value: s,
									enumerable: !0,
									configurable: !0,
									writable: !0
								}) : n[i] = s, n)),
								"aria-hidden": "true",
								children: e
							}, t);
							var n, i, s
						})), !y && (0, r.jsx)("span", {
							className: c().animatedChars,
							"aria-hidden": "true"
						})]
					})
				})
			}
		},
		8595: function(e, t, n) {
			"use strict";
			n.d(t, {
				Z: function() {
					return c
				}
			});
			var r = n(5893),
				i = n(7294),
				s = n(4184),
				a = n.n(s),
				o = n(7144),
				l = n.n(o);
			var c = function(e) {
				var t, n, s, o = e.className,
					c = e.animationDelay,
					u = void 0 === c ? .3 : c,
					h = e.animateIntoView,
					d = void 0 === h || h,
					p = e.children,
					f = (0, i.useState)(!u && !d),
					m = f[0],
					g = f[1],
					v = (0, i.useRef)(null),
					y = function() {
						setTimeout((function() {
							g(!0)
						}), 1e3 * u)
					};
				return (0, i.useEffect)((function() {
					d ? function() {
						var e = v.current,
							t = new IntersectionObserver((function(n) {
								n.forEach((function(n) {
									n.isIntersecting && (t.unobserve(e), u ? y() : g(!0))
								}))
							}), {
								threshold: .2
							});
						t.observe(e)
					}() : u && y()
				}), []), (0, r.jsx)("div", {
					ref: v,
					className: a()(l().fadeIn, o, (t = {}, n = l().passive, s = !m, n in t ? Object.defineProperty(t, n, {
						value: s,
						enumerable: !0,
						configurable: !0,
						writable: !0
					}) : t[n] = s, t)),
					children: p
				})
			}
		},
		9346: function(e, t, n) {
			"use strict";
			n.d(t, {
				r7: function() {
					return x
				},
				ZP: function() {
					return g
				},
				pN: function() {
					return u
				},
				ou: function() {
					return c
				}
			});
			var r = n(5893),
				i = n(7294),
				s = n(4184),
				a = n.n(s),
				o = n(5160),
				l = !1,
				c = function() {
					if (!(0, o.t)()) {
						var e, t = function() {
							var t = document.activeElement;
							if (t && t !== document.body) {
								var n = window.innerHeight,
									r = t.clientHeight,
									i = document.documentElement.scrollTop,
									s = i + t.getBoundingClientRect().top,
									a = i < s && i + n > s,
									o = a && i + n < s + r,
									c = o ? s + r - n : s - n / 2;
								!o && a || (l = !0, window.scrollTo(0, c), clearTimeout(e), e = setTimeout((function() {
									l = !1
								}), 1e3))
							}
						};
						window.addEventListener("keydown", (function(e) {
							"Tab" === e.key && setTimeout(t)
						}))
					}
				},
				u = function(e) {
					var t = e.elementRef,
						n = e.ancestorRef,
						r = e.top,
						i = void 0 === r ? 0 : r;
					if (!(0, o.t)()) {
						var s = t.current,
							a = s.parentElement,
							l = n.current,
							c = !0;
						s.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
						var u = document.createElement("div");
						u.style.position = "absolute", a.insertBefore(u, s);
						var h = function() {
							if (c) {
								var e = u.getBoundingClientRect().top - i,
									t = l.offsetHeight + l.getBoundingClientRect().top < s.offsetHeight + i;
								if (!t && e < 0) {
									var n = -e.toFixed(4);
									s.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,".concat(n, ",0,1)")
								}
								if (e > 0 && (s.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"), t) {
									var r = l.offsetHeight - (s.offsetHeight + 0);
									s.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,".concat(r, ",0,1)")
								}
								requestAnimationFrame(h)
							}
						};
						new IntersectionObserver((function(e) {
							e.forEach((function(e) {
								e.isIntersecting ? (s.style.willChange = "transform", c = !0, requestAnimationFrame(h)) : (s.style.willChange = "", c = !1)
							}))
						}), {
							rootMargin: "500px"
						}).observe(l)
					}
				},
				h = n(8730),
				d = n.n(h);

			function p(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e
				}(e) || function(e, t) {
					var n = [],
						r = !0,
						i = !1,
						s = void 0;
					try {
						for (var a, o = e[Symbol.iterator](); !(r = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
					} catch (l) {
						i = !0, s = l
					} finally {
						try {
							r || null == o.return || o.return()
						} finally {
							if (i) throw s
						}
					}
					return n
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance")
				}()
			}
			var f, m, g = function(e) {
				var t = e.children,
					n = e.className,
					s = e.inverseElementRefs,
					c = (0, i.useRef)(null);
				return (0, i.useEffect)((function() {
					return p(function(e, t) {
						var n, r = e.current,
							i = r.parentElement,
							s = t ? t.map((function(e) {
								return e.current
							})) : null,
							a = !1,
							c = function() {
								a = !0
							};
						if ((0, o.t)()) return r.style.position = "static", [c];
						var u, h = !0,
							d = function() {
								var e = r.offsetHeight;
								u !== e && (i.style.height = "".concat(e, "px"), u = e)
							};
						d();
						var p = i.getBoundingClientRect().top,
							f = p,
							m = p;
						new IntersectionObserver((function(e) {
							e.forEach((function(e) {
								e.isIntersecting ? (clearTimeout(n), r.style.willChange = "transform", h = !0) : n = setTimeout((function() {
									r.style.willChange = "", h = !1
								}), 1e3)
							}))
						}), {
							rootMargin: "500px"
						}).observe(i);
						var g = function() {
							if (!a) {
								if (d(), m = i.getBoundingClientRect().top, f += .15 * (m - f), l || h) {
									var e = f.toFixed(4);
									r.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,".concat(e, ",0,1)"), s && s.forEach((function(t) {
										t.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,".concat(-e, ",0,1)")
									}))
								}
								requestAnimationFrame(g)
							}
						};
						return g(), [c]
					}(c, s), 1)[0]
				}), []), (0, r.jsx)("div", {
					ref: c,
					className: a()(d().smoothArea, n),
					children: t
				})
			};

			function v(e, t, n) {
				return t in e ? Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : e[t] = n, e
			}

			function y(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e
				}(e) || function(e, t) {
					var n = [],
						r = !0,
						i = !1,
						s = void 0;
					try {
						for (var a, o = e[Symbol.iterator](); !(r = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
					} catch (l) {
						i = !0, s = l
					} finally {
						try {
							r || null == o.return || o.return()
						} finally {
							if (i) throw s
						}
					}
					return n
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance")
				}()
			}
			var x = function(e) {
				var t = e.src,
					n = e.alt,
					s = void 0 === n ? "" : n,
					o = e.className,
					l = e.containerClassName,
					c = e.scaleUpOnHover,
					u = e.scaleUp,
					h = e.animateIn,
					p = e.animationDelay,
					g = e.multiplier,
					x = void 0 === g ? .2 : g,
					_ = (0, i.useState)(!p),
					b = _[0],
					w = _[1],
					M = (0, i.useRef)(null),
					A = (0, i.useRef)(null),
					S = function(e, t) {
						if (M.current) {
							var n = -(.2 * M.current.offsetHeight + t);
							e.style.transform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,".concat(n, ",0,1)")
						}
					};
				return (0, i.useEffect)((function() {
					return p && setTimeout((function() {
						w(!0)
					}), 1e3 * p), y(function(e) {
						var t, n = e.elementRef,
							r = e.multiplier,
							i = e.ease,
							s = e.onAnimate,
							a = e.willChange,
							o = void 0 === a ? "" : a,
							l = n.current,
							c = l.parentElement,
							u = !0,
							h = !1,
							d = function() {
								return (c.getBoundingClientRect().top - .5 * window.innerHeight) * r
							},
							p = d(),
							f = p,
							m = p;
						new IntersectionObserver((function(e) {
							e.forEach((function(e) {
								e.isIntersecting ? (clearTimeout(t), l.style.willChange = o, u = !0) : t = setTimeout((function() {
									l.style.willChange = "", u = !1
								}), 1e3)
							}))
						}), {
							rootMargin: "500px"
						}).observe(c);
						var g = function() {
							h || (m = d(), f += (m - f) * i, u && s(l, parseFloat(f.toFixed(4))), requestAnimationFrame(g))
						};
						return g(), [function() {
							h = !0
						}]
					}({
						onAnimate: S,
						elementRef: A,
						multiplier: x,
						ease: .4,
						willChange: "transform"
					}), 1)[0]
				}), []), (0, r.jsx)("div", {
					ref: M,
					className: a()(d().parallaxImageContainer, l, (f = {}, v(f, d().animateIn, h), v(f, d().passive, h && !b), v(f, d().scalableOnHover, c), f)),
					children: (0, r.jsx)("div", {
						className: a()(d().parallaxImageWrapper, (m = {}, v(m, d().scalable, c || "boolean" === typeof u), v(m, d().scaleUp, u), m)),
						children: (0, r.jsx)("img", {
							ref: A,
							src: t,
							alt: s,
							className: a()(d().parallaxImage, o)
						})
					})
				})
			}
		},
		5160: function(e, t, n) {
			"use strict";
			n.d(t, {
				t: function() {
					return r
				}
			});
			var r = function() {
				return "undefined" !== typeof navigator && /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent)
			}
		},
		6187: function(e) {
			e.exports = {
				bigText: "BigText_bigText__ahAK1",
				srText: "BigText_srText__T51Fh",
				animatedChars: "BigText_animatedChars__n0Rpk",
				"chars-in": "BigText_chars-in__e_wCk",
				passive: "BigText_passive__LhGeX"
			}
		},
		7144: function(e) {
			e.exports = {
				fadeIn: "FadeIn_fadeIn__Zp7M1",
				passive: "FadeIn_passive__IEqxh",
				"fade-in": "FadeIn_fade-in__jK7Un"
			}
		},
		6439: function(e) {
			e.exports = {
				footer: "Footer_footer__Q5T55",
				footerGrid: "Footer_footerGrid__J3zUe",
				title: "Footer_title__o3sfG",
				socialLinks: "Footer_socialLinks__VDbnR",
				team: "Footer_team__HsB_D"
			}
		},
		2862: function(e) {
			e.exports = {
				header: "Header_header__NLhag",
				stickyHeader: "Header_stickyHeader__noVsD",
				headerGrid: "Header_headerGrid__HyyCu",
				"header-in": "Header_header-in__5TUbK",
				title: "Header_title__Bl0RP",
				currentRole: "Header_currentRole__R_by_",
				location: "Header_location__1lzeH",
				navArea: "Header_navArea__nJ_j1",
				lgNav: "Header_lgNav__9gB6B",
				mobileNav: "Header_mobileNav__VyyIQ",
				navLink: "Header_navLink__zAeDp",
				active: "Header_active__SBcCE",
				mobileMenuExit: "Header_mobileMenuExit__Z2ttZ"
			}
		},
		8959: function(e) {
			e.exports = {
				layout: "Layout_layout__vMu_3",
				exiting: "Layout_exiting__6xp4X",
				main: "Layout_main__evUHx",
				layoutWipe: "Layout_layoutWipe__ug3vy",
				"layout-wipe": "Layout_layout-wipe__8TG6j"
			}
		},
		7115: function(e) {
			e.exports = {
				loader: "Loader_loader__UZRX9",
				wipeOut: "Loader_wipeOut__wnCsi",
				appDescription: "Loader_appDescription__kJZn3",
				progress: "Loader_progress__iFE3k",
				fullContainer: "Loader_fullContainer__EO_Yj",
				progressBlock: "Loader_progressBlock__DSKUg",
				progressValue: "Loader_progressValue__wUPcz",
				flipVal: "Loader_flipVal__COewA",
				singleTop: "Loader_singleTop__zYuuL",
				maxTop: "Loader_maxTop__o99fA",
				maxVal: "Loader_maxVal__R7Y_V"
			}
		},
		3289: function(e) {
			e.exports = {
				mobileMenu: "MobileMenu_mobileMenu__relFC",
				"mask-in": "MobileMenu_mask-in__KPJo_",
				headerRow: "MobileMenu_headerRow__mBBXd",
				menuContent: "MobileMenu_menuContent__Qx4Ta",
				navLinks: "MobileMenu_navLinks__h2AmD",
				activeLinkUnderlinePassive: "MobileMenu_activeLinkUnderlinePassive__ipFDM",
				activeNavLink: "MobileMenu_activeNavLink__qOJ6v",
				navItem: "MobileMenu_navItem__z6SOc",
				currentRole: "MobileMenu_currentRole__nkQxy",
				location: "MobileMenu_location__fSI9L"
			}
		},
		8730: function(e) {
			e.exports = {
				smoothArea: "SmoothArea_smoothArea__HIKzB",
				parallaxImageContainer: "SmoothArea_parallaxImageContainer__wgKbS",
				animateIn: "SmoothArea_animateIn__Bsrav",
				passive: "SmoothArea_passive__HMOga",
				"mask-in": "SmoothArea_mask-in__mJrCL",
				parallaxImageWrapper: "SmoothArea_parallaxImageWrapper__E9hBu",
				"scale-in": "SmoothArea_scale-in__E8b40",
				parallaxImage: "SmoothArea_parallaxImage__eAQc_",
				scalableOnHover: "SmoothArea_scalableOnHover__koh07",
				scalable: "SmoothArea_scalable__66_k8",
				scaleUp: "SmoothArea_scaleUp__RXwxx"
			}
		},
		5112: function() {},
		9221: function() {},
		9008: function(e, t, n) {
			e.exports = n(5443)
		},
		1664: function(e, t, n) {
			e.exports = n(8418)
		},
		1163: function(e, t, n) {
			e.exports = n(387)
		},
		4298: function(e, t, n) {
			e.exports = n(699)
		},
		7287: function(e, t, n) {
			(e = n.nmd(e)).exports = function(t) {
				var r = {},
					i = n(6086),
					s = n(7294),
					a = n(3840);

				function o(e) {
					for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
					return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
				}
				var l = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
					c = 60103,
					u = 60106,
					h = 60107,
					d = 60108,
					p = 60114,
					f = 60109,
					m = 60110,
					g = 60112,
					v = 60113,
					y = 60120,
					x = 60115,
					_ = 60116,
					b = 60121,
					w = 60129,
					M = 60130,
					A = 60131;
				if ("function" === typeof Symbol && Symbol.for) {
					var S = Symbol.for;
					c = S("react.element"), u = S("react.portal"), h = S("react.fragment"), d = S("react.strict_mode"), p = S("react.profiler"), f = S("react.provider"), m = S("react.context"), g = S("react.forward_ref"), v = S("react.suspense"), y = S("react.suspense_list"), x = S("react.memo"), _ = S("react.lazy"), b = S("react.block"), S("react.scope"), w = S("react.debug_trace_mode"), M = S("react.offscreen"), A = S("react.legacy_hidden")
				}
				var E = "function" === typeof Symbol && Symbol.iterator;

				function T(e) {
					return null === e || "object" !== typeof e ? null : "function" === typeof(e = E && e[E] || e["@@iterator"]) ? e : null
				}

				function C(e) {
					if (null == e) return null;
					if ("function" === typeof e) return e.displayName || e.name || null;
					if ("string" === typeof e) return e;
					switch (e) {
						case h:
							return "Fragment";
						case u:
							return "Portal";
						case p:
							return "Profiler";
						case d:
							return "StrictMode";
						case v:
							return "Suspense";
						case y:
							return "SuspenseList"
					}
					if ("object" === typeof e) switch (e.$$typeof) {
						case m:
							return (e.displayName || "Context") + ".Consumer";
						case f:
							return (e._context.displayName || "Context") + ".Provider";
						case g:
							var t = e.render;
							return t = t.displayName || t.name || "", e.displayName || ("" !== t ? "ForwardRef(" + t + ")" : "ForwardRef");
						case x:
							return C(e.type);
						case b:
							return C(e._render);
						case _:
							t = e._payload, e = e._init;
							try {
								return C(e(t))
							} catch (n) {}
					}
					return null
				}

				function B(e) {
					var t = e,
						n = e;
					if (e.alternate)
						for (; t.return;) t = t.return;
					else {
						e = t;
						do {
							0 !== (1026 & (t = e).flags) && (n = t.return), e = t.return
						} while (e)
					}
					return 3 === t.tag ? n : null
				}

				function R(e) {
					if (B(e) !== e) throw Error(o(188))
				}

				function L(e) {
					var t = e.alternate;
					if (!t) {
						if (null === (t = B(e))) throw Error(o(188));
						return t !== e ? null : e
					}
					for (var n = e, r = t;;) {
						var i = n.return;
						if (null === i) break;
						var s = i.alternate;
						if (null === s) {
							if (null !== (r = i.return)) {
								n = r;
								continue
							}
							break
						}
						if (i.child === s.child) {
							for (s = i.child; s;) {
								if (s === n) return R(i), e;
								if (s === r) return R(i), t;
								s = s.sibling
							}
							throw Error(o(188))
						}
						if (n.return !== r.return) n = i, r = s;
						else {
							for (var a = !1, l = i.child; l;) {
								if (l === n) {
									a = !0, n = i, r = s;
									break
								}
								if (l === r) {
									a = !0, r = i, n = s;
									break
								}
								l = l.sibling
							}
							if (!a) {
								for (l = s.child; l;) {
									if (l === n) {
										a = !0, n = s, r = i;
										break
									}
									if (l === r) {
										a = !0, r = s, n = i;
										break
									}
									l = l.sibling
								}
								if (!a) throw Error(o(189))
							}
						}
						if (n.alternate !== r) throw Error(o(190))
					}
					if (3 !== n.tag) throw Error(o(188));
					return n.stateNode.current === n ? e : t
				}

				function I(e) {
					if (!(e = L(e))) return null;
					for (var t = e;;) {
						if (5 === t.tag || 6 === t.tag) return t;
						if (t.child) t.child.return = t, t = t.child;
						else {
							if (t === e) break;
							for (; !t.sibling;) {
								if (!t.return || t.return === e) return null;
								t = t.return
							}
							t.sibling.return = t.return, t = t.sibling
						}
					}
					return null
				}

				function P(e, t) {
					for (var n = e.alternate; null !== t;) {
						if (t === e || t === n) return !0;
						t = t.return
					}
					return !1
				}
				var D, F = t.getPublicInstance,
					O = t.getRootHostContext,
					N = t.getChildHostContext,
					H = t.prepareForCommit,
					k = t.resetAfterCommit,
					G = t.createInstance,
					U = t.appendInitialChild,
					z = t.finalizeInitialChildren,
					V = t.prepareUpdate,
					W = t.shouldSetTextContent,
					j = t.createTextInstance,
					J = t.scheduleTimeout,
					X = t.cancelTimeout,
					q = t.noTimeout,
					K = t.isPrimaryRenderer,
					Y = t.supportsMutation,
					Q = t.supportsPersistence,
					Z = t.supportsHydration,
					$ = t.getInstanceFromNode,
					ee = t.makeOpaqueHydratingObject,
					te = t.makeClientId,
					ne = t.beforeActiveInstanceBlur,
					re = t.afterActiveInstanceBlur,
					ie = t.preparePortalMount,
					se = t.supportsTestSelectors,
					ae = t.findFiberRoot,
					oe = t.getBoundingRect,
					le = t.getTextContent,
					ce = t.isHiddenSubtree,
					ue = t.matchAccessibilityRole,
					he = t.setFocusIfFocusable,
					de = t.setupIntersectionObserver,
					pe = t.appendChild,
					fe = t.appendChildToContainer,
					me = t.commitTextUpdate,
					ge = t.commitMount,
					ve = t.commitUpdate,
					ye = t.insertBefore,
					xe = t.insertInContainerBefore,
					_e = t.removeChild,
					be = t.removeChildFromContainer,
					we = t.resetTextContent,
					Me = t.hideInstance,
					Ae = t.hideTextInstance,
					Se = t.unhideInstance,
					Ee = t.unhideTextInstance,
					Te = t.clearContainer,
					Ce = t.cloneInstance,
					Be = t.createContainerChildSet,
					Re = t.appendChildToContainerChildSet,
					Le = t.finalizeContainerChildren,
					Ie = t.replaceContainerChildren,
					Pe = t.cloneHiddenInstance,
					De = t.cloneHiddenTextInstance,
					Fe = t.canHydrateInstance,
					Oe = t.canHydrateTextInstance,
					Ne = t.isSuspenseInstancePending,
					He = t.isSuspenseInstanceFallback,
					ke = t.getNextHydratableSibling,
					Ge = t.getFirstHydratableChild,
					Ue = t.hydrateInstance,
					ze = t.hydrateTextInstance,
					Ve = t.getNextHydratableInstanceAfterSuspenseInstance,
					We = t.commitHydratedContainer,
					je = t.commitHydratedSuspenseInstance;

				function Je(e) {
					if (void 0 === D) try {
						throw Error()
					} catch (n) {
						var t = n.stack.trim().match(/\n( *(at )?)/);
						D = t && t[1] || ""
					}
					return "\n" + D + e
				}
				var Xe = !1;

				function qe(e, t) {
					if (!e || Xe) return "";
					Xe = !0;
					var n = Error.prepareStackTrace;
					Error.prepareStackTrace = void 0;
					try {
						if (t)
							if (t = function() {
									throw Error()
								}, Object.defineProperty(t.prototype, "props", {
									set: function() {
										throw Error()
									}
								}), "object" === typeof Reflect && Reflect.construct) {
								try {
									Reflect.construct(t, [])
								} catch (l) {
									var r = l
								}
								Reflect.construct(e, [], t)
							} else {
								try {
									t.call()
								} catch (l) {
									r = l
								}
								e.call(t.prototype)
							}
						else {
							try {
								throw Error()
							} catch (l) {
								r = l
							}
							e()
						}
					} catch (l) {
						if (l && r && "string" === typeof l.stack) {
							for (var i = l.stack.split("\n"), s = r.stack.split("\n"), a = i.length - 1, o = s.length - 1; 1 <= a && 0 <= o && i[a] !== s[o];) o--;
							for (; 1 <= a && 0 <= o; a--, o--)
								if (i[a] !== s[o]) {
									if (1 !== a || 1 !== o)
										do {
											if (a--, 0 > --o || i[a] !== s[o]) return "\n" + i[a].replace(" at new ", " at ")
										} while (1 <= a && 0 <= o);
									break
								}
						}
					} finally {
						Xe = !1, Error.prepareStackTrace = n
					}
					return (e = e ? e.displayName || e.name : "") ? Je(e) : ""
				}
				var Ke = [],
					Ye = -1;

				function Qe(e) {
					return {
						current: e
					}
				}

				function Ze(e) {
					0 > Ye || (e.current = Ke[Ye], Ke[Ye] = null, Ye--)
				}

				function $e(e, t) {
					Ye++, Ke[Ye] = e.current, e.current = t
				}
				var et = {},
					tt = Qe(et),
					nt = Qe(!1),
					rt = et;

				function it(e, t) {
					var n = e.type.contextTypes;
					if (!n) return et;
					var r = e.stateNode;
					if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
					var i, s = {};
					for (i in n) s[i] = t[i];
					return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s
				}

				function st(e) {
					return null !== (e = e.childContextTypes) && void 0 !== e
				}

				function at() {
					Ze(nt), Ze(tt)
				}

				function ot(e, t, n) {
					if (tt.current !== et) throw Error(o(168));
					$e(tt, t), $e(nt, n)
				}

				function lt(e, t, n) {
					var r = e.stateNode;
					if (e = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
					for (var s in r = r.getChildContext())
						if (!(s in e)) throw Error(o(108, C(t) || "Unknown", s));
					return i({}, n, r)
				}

				function ct(e) {
					return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || et, rt = tt.current, $e(tt, e), $e(nt, nt.current), !0
				}

				function ut(e, t, n) {
					var r = e.stateNode;
					if (!r) throw Error(o(169));
					n ? (e = lt(e, t, rt), r.__reactInternalMemoizedMergedChildContext = e, Ze(nt), Ze(tt), $e(tt, e)) : Ze(nt), $e(nt, n)
				}
				var ht = null,
					dt = null;
				(0, a.unstable_now)();
				var pt = 0,
					ft = 8;

				function mt(e) {
					if (0 !== (1 & e)) return ft = 15, 1;
					if (0 !== (2 & e)) return ft = 14, 2;
					if (0 !== (4 & e)) return ft = 13, 4;
					var t = 24 & e;
					return 0 !== t ? (ft = 12, t) : 0 !== (32 & e) ? (ft = 11, 32) : 0 !== (t = 192 & e) ? (ft = 10, t) : 0 !== (256 & e) ? (ft = 9, 256) : 0 !== (t = 3584 & e) ? (ft = 8, t) : 0 !== (4096 & e) ? (ft = 7, 4096) : 0 !== (t = 4186112 & e) ? (ft = 6, t) : 0 !== (t = 62914560 & e) ? (ft = 5, t) : 67108864 & e ? (ft = 4, 67108864) : 0 !== (134217728 & e) ? (ft = 3, 134217728) : 0 !== (t = 805306368 & e) ? (ft = 2, t) : 0 !== (1073741824 & e) ? (ft = 1, 1073741824) : (ft = 8, e)
				}

				function gt(e, t) {
					var n = e.pendingLanes;
					if (0 === n) return ft = 0;
					var r = 0,
						i = 0,
						s = e.expiredLanes,
						a = e.suspendedLanes,
						o = e.pingedLanes;
					if (0 !== s) r = s, i = ft = 15;
					else if (0 !== (s = 134217727 & n)) {
						var l = s & ~a;
						0 !== l ? (r = mt(l), i = ft) : 0 !== (o &= s) && (r = mt(o), i = ft)
					} else 0 !== (s = n & ~a) ? (r = mt(s), i = ft) : 0 !== o && (r = mt(o), i = ft);
					if (0 === r) return 0;
					if (r = n & ((0 > (r = 31 - wt(r)) ? 0 : 1 << r) << 1) - 1, 0 !== t && t !== r && 0 === (t & a)) {
						if (mt(t), i <= ft) return t;
						ft = i
					}
					if (0 !== (t = e.entangledLanes))
						for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - wt(t)), r |= e[n], t &= ~i;
					return r
				}

				function vt(e) {
					return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
				}

				function yt(e, t) {
					switch (e) {
						case 15:
							return 1;
						case 14:
							return 2;
						case 12:
							return 0 === (e = xt(24 & ~t)) ? yt(10, t) : e;
						case 10:
							return 0 === (e = xt(192 & ~t)) ? yt(8, t) : e;
						case 8:
							return 0 === (e = xt(3584 & ~t)) && (0 === (e = xt(4186112 & ~t)) && (e = 512)), e;
						case 2:
							return 0 === (t = xt(805306368 & ~t)) && (t = 268435456), t
					}
					throw Error(o(358, e))
				}

				function xt(e) {
					return e & -e
				}

				function _t(e) {
					for (var t = [], n = 0; 31 > n; n++) t.push(e);
					return t
				}

				function bt(e, t, n) {
					e.pendingLanes |= t;
					var r = t - 1;
					e.suspendedLanes &= r, e.pingedLanes &= r, (e = e.eventTimes)[t = 31 - wt(t)] = n
				}
				var wt = Math.clz32 ? Math.clz32 : function(e) {
						return 0 === e ? 32 : 31 - (Mt(e) / At | 0) | 0
					},
					Mt = Math.log,
					At = Math.LN2;
				var St = a.unstable_runWithPriority,
					Et = a.unstable_scheduleCallback,
					Tt = a.unstable_cancelCallback,
					Ct = a.unstable_shouldYield,
					Bt = a.unstable_requestPaint,
					Rt = a.unstable_now,
					Lt = a.unstable_getCurrentPriorityLevel,
					It = a.unstable_ImmediatePriority,
					Pt = a.unstable_UserBlockingPriority,
					Dt = a.unstable_NormalPriority,
					Ft = a.unstable_LowPriority,
					Ot = a.unstable_IdlePriority,
					Nt = {},
					Ht = void 0 !== Bt ? Bt : function() {},
					kt = null,
					Gt = null,
					Ut = !1,
					zt = Rt(),
					Vt = 1e4 > zt ? Rt : function() {
						return Rt() - zt
					};

				function Wt() {
					switch (Lt()) {
						case It:
							return 99;
						case Pt:
							return 98;
						case Dt:
							return 97;
						case Ft:
							return 96;
						case Ot:
							return 95;
						default:
							throw Error(o(332))
					}
				}

				function jt(e) {
					switch (e) {
						case 99:
							return It;
						case 98:
							return Pt;
						case 97:
							return Dt;
						case 96:
							return Ft;
						case 95:
							return Ot;
						default:
							throw Error(o(332))
					}
				}

				function Jt(e, t) {
					return e = jt(e), St(e, t)
				}

				function Xt(e, t, n) {
					return e = jt(e), Et(e, t, n)
				}

				function qt() {
					if (null !== Gt) {
						var e = Gt;
						Gt = null, Tt(e)
					}
					Kt()
				}

				function Kt() {
					if (!Ut && null !== kt) {
						Ut = !0;
						var e = 0;
						try {
							var t = kt;
							Jt(99, (function() {
								for (; e < t.length; e++) {
									var n = t[e];
									do {
										n = n(!0)
									} while (null !== n)
								}
							})), kt = null
						} catch (n) {
							throw null !== kt && (kt = kt.slice(e + 1)), Et(It, qt), n
						} finally {
							Ut = !1
						}
					}
				}
				var Yt = l.ReactCurrentBatchConfig;
				var Qt = "function" === typeof Object.is ? Object.is : function(e, t) {
						return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
					},
					Zt = Object.prototype.hasOwnProperty;

				function $t(e, t) {
					if (Qt(e, t)) return !0;
					if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
					var n = Object.keys(e),
						r = Object.keys(t);
					if (n.length !== r.length) return !1;
					for (r = 0; r < n.length; r++)
						if (!Zt.call(t, n[r]) || !Qt(e[n[r]], t[n[r]])) return !1;
					return !0
				}

				function en(e) {
					switch (e.tag) {
						case 5:
							return Je(e.type);
						case 16:
							return Je("Lazy");
						case 13:
							return Je("Suspense");
						case 19:
							return Je("SuspenseList");
						case 0:
						case 2:
						case 15:
							return e = qe(e.type, !1);
						case 11:
							return e = qe(e.type.render, !1);
						case 22:
							return e = qe(e.type._render, !1);
						case 1:
							return e = qe(e.type, !0);
						default:
							return ""
					}
				}

				function tn(e, t) {
					if (e && e.defaultProps) {
						for (var n in t = i({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
						return t
					}
					return t
				}
				var nn = Qe(null),
					rn = null,
					sn = null,
					an = null;

				function on() {
					an = sn = rn = null
				}

				function ln(e, t) {
					e = e.type._context, K ? ($e(nn, e._currentValue), e._currentValue = t) : ($e(nn, e._currentValue2), e._currentValue2 = t)
				}

				function cn(e) {
					var t = nn.current;
					Ze(nn), e = e.type._context, K ? e._currentValue = t : e._currentValue2 = t
				}

				function un(e, t) {
					for (; null !== e;) {
						var n = e.alternate;
						if ((e.childLanes & t) === t) {
							if (null === n || (n.childLanes & t) === t) break;
							n.childLanes |= t
						} else e.childLanes |= t, null !== n && (n.childLanes |= t);
						e = e.return
					}
				}

				function hn(e, t) {
					rn = e, an = sn = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (zr = !0), e.firstContext = null)
				}

				function dn(e, t) {
					if (an !== e && !1 !== t && 0 !== t)
						if ("number" === typeof t && 1073741823 !== t || (an = e, t = 1073741823), t = {
								context: e,
								observedBits: t,
								next: null
							}, null === sn) {
							if (null === rn) throw Error(o(308));
							sn = t, rn.dependencies = {
								lanes: 0,
								firstContext: t,
								responders: null
							}
						} else sn = sn.next = t;
					return K ? e._currentValue : e._currentValue2
				}
				var pn = !1;

				function fn(e) {
					e.updateQueue = {
						baseState: e.memoizedState,
						firstBaseUpdate: null,
						lastBaseUpdate: null,
						shared: {
							pending: null
						},
						effects: null
					}
				}

				function mn(e, t) {
					e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
						baseState: e.baseState,
						firstBaseUpdate: e.firstBaseUpdate,
						lastBaseUpdate: e.lastBaseUpdate,
						shared: e.shared,
						effects: e.effects
					})
				}

				function gn(e, t) {
					return {
						eventTime: e,
						lane: t,
						tag: 0,
						payload: null,
						callback: null,
						next: null
					}
				}

				function vn(e, t) {
					if (null !== (e = e.updateQueue)) {
						var n = (e = e.shared).pending;
						null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
					}
				}

				function yn(e, t) {
					var n = e.updateQueue,
						r = e.alternate;
					if (null !== r && n === (r = r.updateQueue)) {
						var i = null,
							s = null;
						if (null !== (n = n.firstBaseUpdate)) {
							do {
								var a = {
									eventTime: n.eventTime,
									lane: n.lane,
									tag: n.tag,
									payload: n.payload,
									callback: n.callback,
									next: null
								};
								null === s ? i = s = a : s = s.next = a, n = n.next
							} while (null !== n);
							null === s ? i = s = t : s = s.next = t
						} else i = s = t;
						return n = {
							baseState: r.baseState,
							firstBaseUpdate: i,
							lastBaseUpdate: s,
							shared: r.shared,
							effects: r.effects
						}, void(e.updateQueue = n)
					}
					null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
				}

				function xn(e, t, n, r) {
					var s = e.updateQueue;
					pn = !1;
					var a = s.firstBaseUpdate,
						o = s.lastBaseUpdate,
						l = s.shared.pending;
					if (null !== l) {
						s.shared.pending = null;
						var c = l,
							u = c.next;
						c.next = null, null === o ? a = u : o.next = u, o = c;
						var h = e.alternate;
						if (null !== h) {
							var d = (h = h.updateQueue).lastBaseUpdate;
							d !== o && (null === d ? h.firstBaseUpdate = u : d.next = u, h.lastBaseUpdate = c)
						}
					}
					if (null !== a) {
						for (d = s.baseState, o = 0, h = u = c = null;;) {
							l = a.lane;
							var p = a.eventTime;
							if ((r & l) === l) {
								null !== h && (h = h.next = {
									eventTime: p,
									lane: 0,
									tag: a.tag,
									payload: a.payload,
									callback: a.callback,
									next: null
								});
								e: {
									var f = e,
										m = a;
									switch (l = t, p = n, m.tag) {
										case 1:
											if ("function" === typeof(f = m.payload)) {
												d = f.call(p, d, l);
												break e
											}
											d = f;
											break e;
										case 3:
											f.flags = -4097 & f.flags | 64;
										case 0:
											if (null === (l = "function" === typeof(f = m.payload) ? f.call(p, d, l) : f) || void 0 === l) break e;
											d = i({}, d, l);
											break e;
										case 2:
											pn = !0
									}
								}
								null !== a.callback && (e.flags |= 32, null === (l = s.effects) ? s.effects = [a] : l.push(a))
							} else p = {
								eventTime: p,
								lane: l,
								tag: a.tag,
								payload: a.payload,
								callback: a.callback,
								next: null
							}, null === h ? (u = h = p, c = d) : h = h.next = p, o |= l;
							if (null === (a = a.next)) {
								if (null === (l = s.shared.pending)) break;
								a = l.next, l.next = null, s.lastBaseUpdate = l, s.shared.pending = null
							}
						}
						null === h && (c = d), s.baseState = c, s.firstBaseUpdate = u, s.lastBaseUpdate = h, hs |= o, e.lanes = o, e.memoizedState = d
					}
				}

				function _n(e, t, n) {
					if (e = t.effects, t.effects = null, null !== e)
						for (t = 0; t < e.length; t++) {
							var r = e[t],
								i = r.callback;
							if (null !== i) {
								if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i));
								i.call(r)
							}
						}
				}
				var bn = (new s.Component).refs;

				function wn(e, t, n, r) {
					n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : i({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
				}
				var Mn = {
					isMounted: function(e) {
						return !!(e = e._reactInternals) && B(e) === e
					},
					enqueueSetState: function(e, t, n) {
						e = e._reactInternals;
						var r = Os(),
							i = Ns(e),
							s = gn(r, i);
						s.payload = t, void 0 !== n && null !== n && (s.callback = n), vn(e, s), Hs(e, i, r)
					},
					enqueueReplaceState: function(e, t, n) {
						e = e._reactInternals;
						var r = Os(),
							i = Ns(e),
							s = gn(r, i);
						s.tag = 1, s.payload = t, void 0 !== n && null !== n && (s.callback = n), vn(e, s), Hs(e, i, r)
					},
					enqueueForceUpdate: function(e, t) {
						e = e._reactInternals;
						var n = Os(),
							r = Ns(e),
							i = gn(n, r);
						i.tag = 2, void 0 !== t && null !== t && (i.callback = t), vn(e, i), Hs(e, r, n)
					}
				};

				function An(e, t, n, r, i, s, a) {
					return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, a) : !t.prototype || !t.prototype.isPureReactComponent || (!$t(n, r) || !$t(i, s))
				}

				function Sn(e, t, n) {
					var r = !1,
						i = et,
						s = t.contextType;
					return "object" === typeof s && null !== s ? s = dn(s) : (i = st(t) ? rt : tt.current, s = (r = null !== (r = t.contextTypes) && void 0 !== r) ? it(e, i) : et), t = new t(n, s), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Mn, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t
				}

				function En(e, t, n, r) {
					e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Mn.enqueueReplaceState(t, t.state, null)
				}

				function Tn(e, t, n, r) {
					var i = e.stateNode;
					i.props = n, i.state = e.memoizedState, i.refs = bn, fn(e);
					var s = t.contextType;
					"object" === typeof s && null !== s ? i.context = dn(s) : (s = st(t) ? rt : tt.current, i.context = it(e, s)), xn(e, n, i, r), i.state = e.memoizedState, "function" === typeof(s = t.getDerivedStateFromProps) && (wn(e, t, s, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Mn.enqueueReplaceState(i, i.state, null), xn(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4)
				}
				var Cn = Array.isArray;

				function Bn(e, t, n) {
					if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
						if (n._owner) {
							if (n = n._owner) {
								if (1 !== n.tag) throw Error(o(309));
								var r = n.stateNode
							}
							if (!r) throw Error(o(147, e));
							var i = "" + e;
							return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === i ? t.ref : ((t = function(e) {
								var t = r.refs;
								t === bn && (t = r.refs = {}), null === e ? delete t[i] : t[i] = e
							})._stringRef = i, t)
						}
						if ("string" !== typeof e) throw Error(o(284));
						if (!n._owner) throw Error(o(290, e))
					}
					return e
				}

				function Rn(e, t) {
					if ("textarea" !== e.type) throw Error(o(31, "[object Object]" === Object.prototype.toString.call(t) ? "object with keys {" + Object.keys(t).join(", ") + "}" : t))
				}

				function Ln(e) {
					function t(t, n) {
						if (e) {
							var r = t.lastEffect;
							null !== r ? (r.nextEffect = n, t.lastEffect = n) : t.firstEffect = t.lastEffect = n, n.nextEffect = null, n.flags = 8
						}
					}

					function n(n, r) {
						if (!e) return null;
						for (; null !== r;) t(n, r), r = r.sibling;
						return null
					}

					function r(e, t) {
						for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
						return e
					}

					function i(e, t) {
						return (e = Ma(e, t)).index = 0, e.sibling = null, e
					}

					function s(t, n, r) {
						return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags = 2, n) : r : (t.flags = 2, n) : n
					}

					function a(t) {
						return e && null === t.alternate && (t.flags = 2), t
					}

					function l(e, t, n, r) {
						return null === t || 6 !== t.tag ? ((t = Ta(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
					}

					function d(e, t, n, r) {
						return null !== t && t.elementType === n.type ? ((r = i(t, n.props)).ref = Bn(e, t, n), r.return = e, r) : ((r = Aa(n.type, n.key, n.props, null, e.mode, r)).ref = Bn(e, t, n), r.return = e, r)
					}

					function p(e, t, n, r) {
						return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Ca(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
					}

					function f(e, t, n, r, s) {
						return null === t || 7 !== t.tag ? ((t = Sa(n, e.mode, r, s)).return = e, t) : ((t = i(t, n)).return = e, t)
					}

					function m(e, t, n) {
						if ("string" === typeof t || "number" === typeof t) return (t = Ta("" + t, e.mode, n)).return = e, t;
						if ("object" === typeof t && null !== t) {
							switch (t.$$typeof) {
								case c:
									return (n = Aa(t.type, t.key, t.props, null, e.mode, n)).ref = Bn(e, null, t), n.return = e, n;
								case u:
									return (t = Ca(t, e.mode, n)).return = e, t
							}
							if (Cn(t) || T(t)) return (t = Sa(t, e.mode, n, null)).return = e, t;
							Rn(e, t)
						}
						return null
					}

					function g(e, t, n, r) {
						var i = null !== t ? t.key : null;
						if ("string" === typeof n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r);
						if ("object" === typeof n && null !== n) {
							switch (n.$$typeof) {
								case c:
									return n.key === i ? n.type === h ? f(e, t, n.props.children, r, i) : d(e, t, n, r) : null;
								case u:
									return n.key === i ? p(e, t, n, r) : null
							}
							if (Cn(n) || T(n)) return null !== i ? null : f(e, t, n, r, null);
							Rn(e, n)
						}
						return null
					}

					function v(e, t, n, r, i) {
						if ("string" === typeof r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i);
						if ("object" === typeof r && null !== r) {
							switch (r.$$typeof) {
								case c:
									return e = e.get(null === r.key ? n : r.key) || null, r.type === h ? f(t, e, r.props.children, i, r.key) : d(t, e, r, i);
								case u:
									return p(t, e = e.get(null === r.key ? n : r.key) || null, r, i)
							}
							if (Cn(r) || T(r)) return f(t, e = e.get(n) || null, r, i, null);
							Rn(t, r)
						}
						return null
					}

					function y(i, a, o, l) {
						for (var c = null, u = null, h = a, d = a = 0, p = null; null !== h && d < o.length; d++) {
							h.index > d ? (p = h, h = null) : p = h.sibling;
							var f = g(i, h, o[d], l);
							if (null === f) {
								null === h && (h = p);
								break
							}
							e && h && null === f.alternate && t(i, h), a = s(f, a, d), null === u ? c = f : u.sibling = f, u = f, h = p
						}
						if (d === o.length) return n(i, h), c;
						if (null === h) {
							for (; d < o.length; d++) null !== (h = m(i, o[d], l)) && (a = s(h, a, d), null === u ? c = h : u.sibling = h, u = h);
							return c
						}
						for (h = r(i, h); d < o.length; d++) null !== (p = v(h, i, d, o[d], l)) && (e && null !== p.alternate && h.delete(null === p.key ? d : p.key), a = s(p, a, d), null === u ? c = p : u.sibling = p, u = p);
						return e && h.forEach((function(e) {
							return t(i, e)
						})), c
					}

					function x(i, a, l, c) {
						var u = T(l);
						if ("function" !== typeof u) throw Error(o(150));
						if (null == (l = u.call(l))) throw Error(o(151));
						for (var h = u = null, d = a, p = a = 0, f = null, y = l.next(); null !== d && !y.done; p++, y = l.next()) {
							d.index > p ? (f = d, d = null) : f = d.sibling;
							var x = g(i, d, y.value, c);
							if (null === x) {
								null === d && (d = f);
								break
							}
							e && d && null === x.alternate && t(i, d), a = s(x, a, p), null === h ? u = x : h.sibling = x, h = x, d = f
						}
						if (y.done) return n(i, d), u;
						if (null === d) {
							for (; !y.done; p++, y = l.next()) null !== (y = m(i, y.value, c)) && (a = s(y, a, p), null === h ? u = y : h.sibling = y, h = y);
							return u
						}
						for (d = r(i, d); !y.done; p++, y = l.next()) null !== (y = v(d, i, p, y.value, c)) && (e && null !== y.alternate && d.delete(null === y.key ? p : y.key), a = s(y, a, p), null === h ? u = y : h.sibling = y, h = y);
						return e && d.forEach((function(e) {
							return t(i, e)
						})), u
					}
					return function(e, r, s, l) {
						var d = "object" === typeof s && null !== s && s.type === h && null === s.key;
						d && (s = s.props.children);
						var p = "object" === typeof s && null !== s;
						if (p) switch (s.$$typeof) {
							case c:
								e: {
									for (p = s.key, d = r; null !== d;) {
										if (d.key === p) {
											switch (d.tag) {
												case 7:
													if (s.type === h) {
														n(e, d.sibling), (r = i(d, s.props.children)).return = e, e = r;
														break e
													}
													break;
												default:
													if (d.elementType === s.type) {
														n(e, d.sibling), (r = i(d, s.props)).ref = Bn(e, d, s), r.return = e, e = r;
														break e
													}
											}
											n(e, d);
											break
										}
										t(e, d), d = d.sibling
									}
									s.type === h ? ((r = Sa(s.props.children, e.mode, l, s.key)).return = e, e = r) : ((l = Aa(s.type, s.key, s.props, null, e.mode, l)).ref = Bn(e, r, s), l.return = e, e = l)
								}
								return a(e);
							case u:
								e: {
									for (d = s.key; null !== r;) {
										if (r.key === d) {
											if (4 === r.tag && r.stateNode.containerInfo === s.containerInfo && r.stateNode.implementation === s.implementation) {
												n(e, r.sibling), (r = i(r, s.children || [])).return = e, e = r;
												break e
											}
											n(e, r);
											break
										}
										t(e, r), r = r.sibling
									}(r = Ca(s, e.mode, l)).return = e,
									e = r
								}
								return a(e)
						}
						if ("string" === typeof s || "number" === typeof s) return s = "" + s, null !== r && 6 === r.tag ? (n(e, r.sibling), (r = i(r, s)).return = e, e = r) : (n(e, r), (r = Ta(s, e.mode, l)).return = e, e = r), a(e);
						if (Cn(s)) return y(e, r, s, l);
						if (T(s)) return x(e, r, s, l);
						if (p && Rn(e, s), "undefined" === typeof s && !d) switch (e.tag) {
							case 1:
							case 22:
							case 0:
							case 11:
							case 15:
								throw Error(o(152, C(e.type) || "Component"))
						}
						return n(e, r)
					}
				}
				var In = Ln(!0),
					Pn = Ln(!1),
					Dn = {},
					Fn = Qe(Dn),
					On = Qe(Dn),
					Nn = Qe(Dn);

				function Hn(e) {
					if (e === Dn) throw Error(o(174));
					return e
				}

				function kn(e, t) {
					$e(Nn, t), $e(On, e), $e(Fn, Dn), e = O(t), Ze(Fn), $e(Fn, e)
				}

				function Gn() {
					Ze(Fn), Ze(On), Ze(Nn)
				}

				function Un(e) {
					var t = Hn(Nn.current),
						n = Hn(Fn.current);
					n !== (t = N(n, e.type, t)) && ($e(On, e), $e(Fn, t))
				}

				function zn(e) {
					On.current === e && (Ze(Fn), Ze(On))
				}
				var Vn = Qe(0);

				function Wn(e) {
					for (var t = e; null !== t;) {
						if (13 === t.tag) {
							var n = t.memoizedState;
							if (null !== n && (null === (n = n.dehydrated) || Ne(n) || He(n))) return t
						} else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
							if (0 !== (64 & t.flags)) return t
						} else if (null !== t.child) {
							t.child.return = t, t = t.child;
							continue
						}
						if (t === e) break;
						for (; null === t.sibling;) {
							if (null === t.return || t.return === e) return null;
							t = t.return
						}
						t.sibling.return = t.return, t = t.sibling
					}
					return null
				}
				var jn = null,
					Jn = null,
					Xn = !1;

				function qn(e, t) {
					var n = ba(5, null, null, 0);
					n.elementType = "DELETED", n.type = "DELETED", n.stateNode = t, n.return = e, n.flags = 8, null !== e.lastEffect ? (e.lastEffect.nextEffect = n, e.lastEffect = n) : e.firstEffect = e.lastEffect = n
				}

				function Kn(e, t) {
					switch (e.tag) {
						case 5:
							return null !== (t = Fe(t, e.type, e.pendingProps)) && (e.stateNode = t, !0);
						case 6:
							return null !== (t = Oe(t, e.pendingProps)) && (e.stateNode = t, !0);
						case 13:
						default:
							return !1
					}
				}

				function Yn(e) {
					if (Xn) {
						var t = Jn;
						if (t) {
							var n = t;
							if (!Kn(e, t)) {
								if (!(t = ke(n)) || !Kn(e, t)) return e.flags = -1025 & e.flags | 2, Xn = !1, void(jn = e);
								qn(jn, n)
							}
							jn = e, Jn = Ge(t)
						} else e.flags = -1025 & e.flags | 2, Xn = !1, jn = e
					}
				}

				function Qn(e) {
					for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
					jn = e
				}

				function Zn(e) {
					if (!Z || e !== jn) return !1;
					if (!Xn) return Qn(e), Xn = !0, !1;
					var t = e.type;
					if (5 !== e.tag || "head" !== t && "body" !== t && !W(t, e.memoizedProps))
						for (t = Jn; t;) qn(e, t), t = ke(t);
					if (Qn(e), 13 === e.tag) {
						if (!Z) throw Error(o(316));
						if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
						Jn = Ve(e)
					} else Jn = jn ? ke(e.stateNode) : null;
					return !0
				}

				function $n() {
					Z && (Jn = jn = null, Xn = !1)
				}
				var er = [];

				function tr() {
					for (var e = 0; e < er.length; e++) {
						var t = er[e];
						K ? t._workInProgressVersionPrimary = null : t._workInProgressVersionSecondary = null
					}
					er.length = 0
				}
				var nr = l.ReactCurrentDispatcher,
					rr = l.ReactCurrentBatchConfig,
					ir = 0,
					sr = null,
					ar = null,
					or = null,
					lr = !1,
					cr = !1;

				function ur() {
					throw Error(o(321))
				}

				function hr(e, t) {
					if (null === t) return !1;
					for (var n = 0; n < t.length && n < e.length; n++)
						if (!Qt(e[n], t[n])) return !1;
					return !0
				}

				function dr(e, t, n, r, i, s) {
					if (ir = s, sr = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, nr.current = null === e || null === e.memoizedState ? Hr : kr, e = n(r, i), cr) {
						s = 0;
						do {
							if (cr = !1, !(25 > s)) throw Error(o(301));
							s += 1, or = ar = null, t.updateQueue = null, nr.current = Gr, e = n(r, i)
						} while (cr)
					}
					if (nr.current = Nr, t = null !== ar && null !== ar.next, ir = 0, or = ar = sr = null, lr = !1, t) throw Error(o(300));
					return e
				}

				function pr() {
					var e = {
						memoizedState: null,
						baseState: null,
						baseQueue: null,
						queue: null,
						next: null
					};
					return null === or ? sr.memoizedState = or = e : or = or.next = e, or
				}

				function fr() {
					if (null === ar) {
						var e = sr.alternate;
						e = null !== e ? e.memoizedState : null
					} else e = ar.next;
					var t = null === or ? sr.memoizedState : or.next;
					if (null !== t) or = t, ar = e;
					else {
						if (null === e) throw Error(o(310));
						e = {
							memoizedState: (ar = e).memoizedState,
							baseState: ar.baseState,
							baseQueue: ar.baseQueue,
							queue: ar.queue,
							next: null
						}, null === or ? sr.memoizedState = or = e : or = or.next = e
					}
					return or
				}

				function mr(e, t) {
					return "function" === typeof t ? t(e) : t
				}

				function gr(e) {
					var t = fr(),
						n = t.queue;
					if (null === n) throw Error(o(311));
					n.lastRenderedReducer = e;
					var r = ar,
						i = r.baseQueue,
						s = n.pending;
					if (null !== s) {
						if (null !== i) {
							var a = i.next;
							i.next = s.next, s.next = a
						}
						r.baseQueue = i = s, n.pending = null
					}
					if (null !== i) {
						i = i.next, r = r.baseState;
						var l = a = s = null,
							c = i;
						do {
							var u = c.lane;
							if ((ir & u) === u) null !== l && (l = l.next = {
								lane: 0,
								action: c.action,
								eagerReducer: c.eagerReducer,
								eagerState: c.eagerState,
								next: null
							}), r = c.eagerReducer === e ? c.eagerState : e(r, c.action);
							else {
								var h = {
									lane: u,
									action: c.action,
									eagerReducer: c.eagerReducer,
									eagerState: c.eagerState,
									next: null
								};
								null === l ? (a = l = h, s = r) : l = l.next = h, sr.lanes |= u, hs |= u
							}
							c = c.next
						} while (null !== c && c !== i);
						null === l ? s = r : l.next = a, Qt(r, t.memoizedState) || (zr = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r
					}
					return [t.memoizedState, n.dispatch]
				}

				function vr(e) {
					var t = fr(),
						n = t.queue;
					if (null === n) throw Error(o(311));
					n.lastRenderedReducer = e;
					var r = n.dispatch,
						i = n.pending,
						s = t.memoizedState;
					if (null !== i) {
						n.pending = null;
						var a = i = i.next;
						do {
							s = e(s, a.action), a = a.next
						} while (a !== i);
						Qt(s, t.memoizedState) || (zr = !0), t.memoizedState = s, null === t.baseQueue && (t.baseState = s), n.lastRenderedState = s
					}
					return [s, r]
				}

				function yr(e, t, n) {
					var r = t._getVersion;
					r = r(t._source);
					var i = K ? t._workInProgressVersionPrimary : t._workInProgressVersionSecondary;
					if (null !== i ? e = i === r : (e = e.mutableReadLanes, (e = (ir & e) === e) && (K ? t._workInProgressVersionPrimary = r : t._workInProgressVersionSecondary = r, er.push(t))), e) return n(t._source);
					throw er.push(t), Error(o(350))
				}

				function xr(e, t, n, r) {
					var i = rs;
					if (null === i) throw Error(o(349));
					var s = t._getVersion,
						a = s(t._source),
						l = nr.current,
						c = l.useState((function() {
							return yr(i, t, n)
						})),
						u = c[1],
						h = c[0];
					c = or;
					var d = e.memoizedState,
						p = d.refs,
						f = p.getSnapshot,
						m = d.source;
					d = d.subscribe;
					var g = sr;
					return e.memoizedState = {
						refs: p,
						source: t,
						subscribe: r
					}, l.useEffect((function() {
						p.getSnapshot = n, p.setSnapshot = u;
						var e = s(t._source);
						if (!Qt(a, e)) {
							e = n(t._source), Qt(h, e) || (u(e), e = Ns(g), i.mutableReadLanes |= e & i.pendingLanes), e = i.mutableReadLanes, i.entangledLanes |= e;
							for (var r = i.entanglements, o = e; 0 < o;) {
								var l = 31 - wt(o),
									c = 1 << l;
								r[l] |= e, o &= ~c
							}
						}
					}), [n, t, r]), l.useEffect((function() {
						return r(t._source, (function() {
							var e = p.getSnapshot,
								n = p.setSnapshot;
							try {
								n(e(t._source));
								var r = Ns(g);
								i.mutableReadLanes |= r & i.pendingLanes
							} catch (s) {
								n((function() {
									throw s
								}))
							}
						}))
					}), [t, r]), Qt(f, n) && Qt(m, t) && Qt(d, r) || ((e = {
						pending: null,
						dispatch: null,
						lastRenderedReducer: mr,
						lastRenderedState: h
					}).dispatch = u = Or.bind(null, sr, e), c.queue = e, c.baseQueue = null, h = yr(i, t, n), c.memoizedState = c.baseState = h), h
				}

				function _r(e, t, n) {
					return xr(fr(), e, t, n)
				}

				function br(e) {
					var t = pr();
					return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = (e = t.queue = {
						pending: null,
						dispatch: null,
						lastRenderedReducer: mr,
						lastRenderedState: e
					}).dispatch = Or.bind(null, sr, e), [t.memoizedState, e]
				}

				function wr(e, t, n, r) {
					return e = {
						tag: e,
						create: t,
						destroy: n,
						deps: r,
						next: null
					}, null === (t = sr.updateQueue) ? (t = {
						lastEffect: null
					}, sr.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
				}

				function Mr(e) {
					return e = {
						current: e
					}, pr().memoizedState = e
				}

				function Ar() {
					return fr().memoizedState
				}

				function Sr(e, t, n, r) {
					var i = pr();
					sr.flags |= e, i.memoizedState = wr(1 | t, n, void 0, void 0 === r ? null : r)
				}

				function Er(e, t, n, r) {
					var i = fr();
					r = void 0 === r ? null : r;
					var s = void 0;
					if (null !== ar) {
						var a = ar.memoizedState;
						if (s = a.destroy, null !== r && hr(r, a.deps)) return void wr(t, n, s, r)
					}
					sr.flags |= e, i.memoizedState = wr(1 | t, n, s, r)
				}

				function Tr(e, t) {
					return Sr(516, 4, e, t)
				}

				function Cr(e, t) {
					return Er(516, 4, e, t)
				}

				function Br(e, t) {
					return Er(4, 2, e, t)
				}

				function Rr(e, t) {
					return "function" === typeof t ? (e = e(), t(e), function() {
						t(null)
					}) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
						t.current = null
					}) : void 0
				}

				function Lr(e, t, n) {
					return n = null !== n && void 0 !== n ? n.concat([e]) : null, Er(4, 2, Rr.bind(null, t, e), n)
				}

				function Ir() {}

				function Pr(e, t) {
					var n = fr();
					t = void 0 === t ? null : t;
					var r = n.memoizedState;
					return null !== r && null !== t && hr(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
				}

				function Dr(e, t) {
					var n = fr();
					t = void 0 === t ? null : t;
					var r = n.memoizedState;
					return null !== r && null !== t && hr(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
				}

				function Fr(e, t) {
					var n = Wt();
					Jt(98 > n ? 98 : n, (function() {
						e(!0)
					})), Jt(97 < n ? 97 : n, (function() {
						var n = rr.transition;
						rr.transition = 1;
						try {
							e(!1), t()
						} finally {
							rr.transition = n
						}
					}))
				}

				function Or(e, t, n) {
					var r = Os(),
						i = Ns(e),
						s = {
							lane: i,
							action: n,
							eagerReducer: null,
							eagerState: null,
							next: null
						},
						a = t.pending;
					if (null === a ? s.next = s : (s.next = a.next, a.next = s), t.pending = s, a = e.alternate, e === sr || null !== a && a === sr) cr = lr = !0;
					else {
						if (0 === e.lanes && (null === a || 0 === a.lanes) && null !== (a = t.lastRenderedReducer)) try {
							var o = t.lastRenderedState,
								l = a(o, n);
							if (s.eagerReducer = a, s.eagerState = l, Qt(l, o)) return
						} catch (c) {}
						Hs(e, i, r)
					}
				}
				var Nr = {
						readContext: dn,
						useCallback: ur,
						useContext: ur,
						useEffect: ur,
						useImperativeHandle: ur,
						useLayoutEffect: ur,
						useMemo: ur,
						useReducer: ur,
						useRef: ur,
						useState: ur,
						useDebugValue: ur,
						useDeferredValue: ur,
						useTransition: ur,
						useMutableSource: ur,
						useOpaqueIdentifier: ur,
						unstable_isNewReconciler: !1
					},
					Hr = {
						readContext: dn,
						useCallback: function(e, t) {
							return pr().memoizedState = [e, void 0 === t ? null : t], e
						},
						useContext: dn,
						useEffect: Tr,
						useImperativeHandle: function(e, t, n) {
							return n = null !== n && void 0 !== n ? n.concat([e]) : null, Sr(4, 2, Rr.bind(null, t, e), n)
						},
						useLayoutEffect: function(e, t) {
							return Sr(4, 2, e, t)
						},
						useMemo: function(e, t) {
							var n = pr();
							return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
						},
						useReducer: function(e, t, n) {
							var r = pr();
							return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = (e = r.queue = {
								pending: null,
								dispatch: null,
								lastRenderedReducer: e,
								lastRenderedState: t
							}).dispatch = Or.bind(null, sr, e), [r.memoizedState, e]
						},
						useRef: Mr,
						useState: br,
						useDebugValue: Ir,
						useDeferredValue: function(e) {
							var t = br(e),
								n = t[0],
								r = t[1];
							return Tr((function() {
								var t = rr.transition;
								rr.transition = 1;
								try {
									r(e)
								} finally {
									rr.transition = t
								}
							}), [e]), n
						},
						useTransition: function() {
							var e = br(!1),
								t = e[0];
							return Mr(e = Fr.bind(null, e[1])), [e, t]
						},
						useMutableSource: function(e, t, n) {
							var r = pr();
							return r.memoizedState = {
								refs: {
									getSnapshot: t,
									setSnapshot: null
								},
								source: e,
								subscribe: n
							}, xr(r, e, t, n)
						},
						useOpaqueIdentifier: function() {
							if (Xn) {
								var e = !1,
									t = ee((function() {
										throw e || (e = !0, n(te())), Error(o(355))
									})),
									n = br(t)[1];
								return 0 === (2 & sr.mode) && (sr.flags |= 516, wr(5, (function() {
									n(te())
								}), void 0, null)), t
							}
							return br(t = te()), t
						},
						unstable_isNewReconciler: !1
					},
					kr = {
						readContext: dn,
						useCallback: Pr,
						useContext: dn,
						useEffect: Cr,
						useImperativeHandle: Lr,
						useLayoutEffect: Br,
						useMemo: Dr,
						useReducer: gr,
						useRef: Ar,
						useState: function() {
							return gr(mr)
						},
						useDebugValue: Ir,
						useDeferredValue: function(e) {
							var t = gr(mr),
								n = t[0],
								r = t[1];
							return Cr((function() {
								var t = rr.transition;
								rr.transition = 1;
								try {
									r(e)
								} finally {
									rr.transition = t
								}
							}), [e]), n
						},
						useTransition: function() {
							var e = gr(mr)[0];
							return [Ar().current, e]
						},
						useMutableSource: _r,
						useOpaqueIdentifier: function() {
							return gr(mr)[0]
						},
						unstable_isNewReconciler: !1
					},
					Gr = {
						readContext: dn,
						useCallback: Pr,
						useContext: dn,
						useEffect: Cr,
						useImperativeHandle: Lr,
						useLayoutEffect: Br,
						useMemo: Dr,
						useReducer: vr,
						useRef: Ar,
						useState: function() {
							return vr(mr)
						},
						useDebugValue: Ir,
						useDeferredValue: function(e) {
							var t = vr(mr),
								n = t[0],
								r = t[1];
							return Cr((function() {
								var t = rr.transition;
								rr.transition = 1;
								try {
									r(e)
								} finally {
									rr.transition = t
								}
							}), [e]), n
						},
						useTransition: function() {
							var e = vr(mr)[0];
							return [Ar().current, e]
						},
						useMutableSource: _r,
						useOpaqueIdentifier: function() {
							return vr(mr)[0]
						},
						unstable_isNewReconciler: !1
					},
					Ur = l.ReactCurrentOwner,
					zr = !1;

				function Vr(e, t, n, r) {
					t.child = null === e ? Pn(t, null, n, r) : In(t, e.child, n, r)
				}

				function Wr(e, t, n, r, i) {
					n = n.render;
					var s = t.ref;
					return hn(t, i), r = dr(e, t, n, r, s, i), null === e || zr ? (t.flags |= 1, Vr(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -517, e.lanes &= ~i, hi(e, t, i))
				}

				function jr(e, t, n, r, i, s) {
					if (null === e) {
						var a = n.type;
						return "function" !== typeof a || wa(a) || void 0 !== a.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Aa(n.type, null, r, t, t.mode, s)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = a, Jr(e, t, a, r, i, s))
					}
					return a = e.child, 0 === (i & s) && (i = a.memoizedProps, (n = null !== (n = n.compare) ? n : $t)(i, r) && e.ref === t.ref) ? hi(e, t, s) : (t.flags |= 1, (e = Ma(a, r)).ref = t.ref, e.return = t, t.child = e)
				}

				function Jr(e, t, n, r, i, s) {
					if (null !== e && $t(e.memoizedProps, r) && e.ref === t.ref) {
						if (zr = !1, 0 === (s & i)) return t.lanes = e.lanes, hi(e, t, s);
						0 !== (16384 & e.flags) && (zr = !0)
					}
					return Kr(e, t, n, r, s)
				}

				function Xr(e, t, n) {
					var r = t.pendingProps,
						i = r.children,
						s = null !== e ? e.memoizedState : null;
					if ("hidden" === r.mode || "unstable-defer-without-hiding" === r.mode)
						if (0 === (4 & t.mode)) t.memoizedState = {
							baseLanes: 0
						}, Js(t, n);
						else {
							if (0 === (1073741824 & n)) return e = null !== s ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
								baseLanes: e
							}, Js(t, e), null;
							t.memoizedState = {
								baseLanes: 0
							}, Js(t, null !== s ? s.baseLanes : n)
						}
					else null !== s ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, Js(t, r);
					return Vr(e, t, i, n), t.child
				}

				function qr(e, t) {
					var n = t.ref;
					(null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 128)
				}

				function Kr(e, t, n, r, i) {
					var s = st(n) ? rt : tt.current;
					return s = it(t, s), hn(t, i), n = dr(e, t, n, r, s, i), null === e || zr ? (t.flags |= 1, Vr(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -517, e.lanes &= ~i, hi(e, t, i))
				}

				function Yr(e, t, n, r, i) {
					if (st(n)) {
						var s = !0;
						ct(t)
					} else s = !1;
					if (hn(t, i), null === t.stateNode) null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), Sn(t, n, r), Tn(t, n, r, i), r = !0;
					else if (null === e) {
						var a = t.stateNode,
							o = t.memoizedProps;
						a.props = o;
						var l = a.context,
							c = n.contextType;
						"object" === typeof c && null !== c ? c = dn(c) : c = it(t, c = st(n) ? rt : tt.current);
						var u = n.getDerivedStateFromProps,
							h = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
						h || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (o !== r || l !== c) && En(t, a, r, c), pn = !1;
						var d = t.memoizedState;
						a.state = d, xn(t, r, a, i), l = t.memoizedState, o !== r || d !== l || nt.current || pn ? ("function" === typeof u && (wn(t, n, u, r), l = t.memoizedState), (o = pn || An(t, n, o, r, d, l, c)) ? (h || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4)) : ("function" === typeof a.componentDidMount && (t.flags |= 4), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = o) : ("function" === typeof a.componentDidMount && (t.flags |= 4), r = !1)
					} else {
						a = t.stateNode, mn(e, t), o = t.memoizedProps, c = t.type === t.elementType ? o : tn(t.type, o), a.props = c, h = t.pendingProps, d = a.context, "object" === typeof(l = n.contextType) && null !== l ? l = dn(l) : l = it(t, l = st(n) ? rt : tt.current);
						var p = n.getDerivedStateFromProps;
						(u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (o !== h || d !== l) && En(t, a, r, l), pn = !1, d = t.memoizedState, a.state = d, xn(t, r, a, i);
						var f = t.memoizedState;
						o !== h || d !== f || nt.current || pn ? ("function" === typeof p && (wn(t, n, p, r), f = t.memoizedState), (c = pn || An(t, n, c, r, d, f, l)) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 256)) : ("function" !== typeof a.componentDidUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 256), t.memoizedProps = r, t.memoizedState = f), a.props = r, a.state = f, a.context = l, r = c) : ("function" !== typeof a.componentDidUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 256), r = !1)
					}
					return Qr(e, t, n, r, s, i)
				}

				function Qr(e, t, n, r, i, s) {
					qr(e, t);
					var a = 0 !== (64 & t.flags);
					if (!r && !a) return i && ut(t, n, !1), hi(e, t, s);
					r = t.stateNode, Ur.current = t;
					var o = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
					return t.flags |= 1, null !== e && a ? (t.child = In(t, e.child, null, s), t.child = In(t, null, o, s)) : Vr(e, t, o, s), t.memoizedState = r.state, i && ut(t, n, !0), t.child
				}

				function Zr(e) {
					var t = e.stateNode;
					t.pendingContext ? ot(0, t.pendingContext, t.pendingContext !== t.context) : t.context && ot(0, t.context, !1), kn(e, t.containerInfo)
				}
				var $r, ei, ti, ni, ri = {
					dehydrated: null,
					retryLane: 0
				};

				function ii(e, t, n) {
					var r, i = t.pendingProps,
						s = Vn.current,
						a = !1;
					return (r = 0 !== (64 & t.flags)) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)), r ? (a = !0, t.flags &= -65) : null !== e && null === e.memoizedState || void 0 === i.fallback || !0 === i.unstable_avoidThisFallback || (s |= 1), $e(Vn, 1 & s), null === e ? (void 0 !== i.fallback && Yn(t), e = i.children, s = i.fallback, a ? (e = si(t, e, s, n), t.child.memoizedState = {
						baseLanes: n
					}, t.memoizedState = ri, e) : "number" === typeof i.unstable_expectedLoadTime ? (e = si(t, e, s, n), t.child.memoizedState = {
						baseLanes: n
					}, t.memoizedState = ri, t.lanes = 33554432, e) : ((n = Ea({
						mode: "visible",
						children: e
					}, t.mode, n, null)).return = t, t.child = n)) : (e.memoizedState, a ? (i = oi(e, t, i.children, i.fallback, n), a = t.child, s = e.child.memoizedState, a.memoizedState = null === s ? {
						baseLanes: n
					} : {
						baseLanes: s.baseLanes | n
					}, a.childLanes = e.childLanes & ~n, t.memoizedState = ri, i) : (n = ai(e, t, i.children, n), t.memoizedState = null, n))
				}

				function si(e, t, n, r) {
					var i = e.mode,
						s = e.child;
					return t = {
						mode: "hidden",
						children: t
					}, 0 === (2 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = t) : s = Ea(t, i, 0, null), n = Sa(n, i, r, null), s.return = e, n.return = e, s.sibling = n, e.child = s, n
				}

				function ai(e, t, n, r) {
					var i = e.child;
					return e = i.sibling, n = Ma(i, {
						mode: "visible",
						children: n
					}), 0 === (2 & t.mode) && (n.lanes = r), n.return = t, n.sibling = null, null !== e && (e.nextEffect = null, e.flags = 8, t.firstEffect = t.lastEffect = e), t.child = n
				}

				function oi(e, t, n, r, i) {
					var s = t.mode,
						a = e.child;
					e = a.sibling;
					var o = {
						mode: "hidden",
						children: n
					};
					return 0 === (2 & s) && t.child !== a ? ((n = t.child).childLanes = 0, n.pendingProps = o, null !== (a = n.lastEffect) ? (t.firstEffect = n.firstEffect, t.lastEffect = a, a.nextEffect = null) : t.firstEffect = t.lastEffect = null) : n = Ma(a, o), null !== e ? r = Ma(e, r) : (r = Sa(r, s, i, null)).flags |= 2, r.return = t, n.return = t, n.sibling = r, t.child = n, r
				}

				function li(e, t) {
					e.lanes |= t;
					var n = e.alternate;
					null !== n && (n.lanes |= t), un(e.return, t)
				}

				function ci(e, t, n, r, i, s) {
					var a = e.memoizedState;
					null === a ? e.memoizedState = {
						isBackwards: t,
						rendering: null,
						renderingStartTime: 0,
						last: r,
						tail: n,
						tailMode: i,
						lastEffect: s
					} : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = r, a.tail = n, a.tailMode = i, a.lastEffect = s)
				}

				function ui(e, t, n) {
					var r = t.pendingProps,
						i = r.revealOrder,
						s = r.tail;
					if (Vr(e, t, r.children, n), 0 !== (2 & (r = Vn.current))) r = 1 & r | 2, t.flags |= 64;
					else {
						if (null !== e && 0 !== (64 & e.flags)) e: for (e = t.child; null !== e;) {
							if (13 === e.tag) null !== e.memoizedState && li(e, n);
							else if (19 === e.tag) li(e, n);
							else if (null !== e.child) {
								e.child.return = e, e = e.child;
								continue
							}
							if (e === t) break e;
							for (; null === e.sibling;) {
								if (null === e.return || e.return === t) break e;
								e = e.return
							}
							e.sibling.return = e.return, e = e.sibling
						}
						r &= 1
					}
					if ($e(Vn, r), 0 === (2 & t.mode)) t.memoizedState = null;
					else switch (i) {
						case "forwards":
							for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === Wn(e) && (i = n), n = n.sibling;
							null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), ci(t, !1, i, n, s, t.lastEffect);
							break;
						case "backwards":
							for (n = null, i = t.child, t.child = null; null !== i;) {
								if (null !== (e = i.alternate) && null === Wn(e)) {
									t.child = i;
									break
								}
								e = i.sibling, i.sibling = n, n = i, i = e
							}
							ci(t, !0, n, null, s, t.lastEffect);
							break;
						case "together":
							ci(t, !1, null, null, void 0, t.lastEffect);
							break;
						default:
							t.memoizedState = null
					}
					return t.child
				}

				function hi(e, t, n) {
					if (null !== e && (t.dependencies = e.dependencies), hs |= t.lanes, 0 !== (n & t.childLanes)) {
						if (null !== e && t.child !== e.child) throw Error(o(153));
						if (null !== t.child) {
							for (n = Ma(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Ma(e, e.pendingProps)).return = t;
							n.sibling = null
						}
						return t.child
					}
					return null
				}

				function di(e) {
					e.flags |= 4
				}
				if (Y) $r = function(e, t) {
					for (var n = t.child; null !== n;) {
						if (5 === n.tag || 6 === n.tag) U(e, n.stateNode);
						else if (4 !== n.tag && null !== n.child) {
							n.child.return = n, n = n.child;
							continue
						}
						if (n === t) break;
						for (; null === n.sibling;) {
							if (null === n.return || n.return === t) return;
							n = n.return
						}
						n.sibling.return = n.return, n = n.sibling
					}
				}, ei = function() {}, ti = function(e, t, n, r, i) {
					if ((e = e.memoizedProps) !== r) {
						var s = t.stateNode,
							a = Hn(Fn.current);
						n = V(s, n, e, r, i, a), (t.updateQueue = n) && di(t)
					}
				}, ni = function(e, t, n, r) {
					n !== r && di(t)
				};
				else if (Q) {
					$r = function(e, t, n, r) {
						for (var i = t.child; null !== i;) {
							if (5 === i.tag) {
								var s = i.stateNode;
								n && r && (s = Pe(s, i.type, i.memoizedProps, i)), U(e, s)
							} else if (6 === i.tag) s = i.stateNode, n && r && (s = De(s, i.memoizedProps, i)), U(e, s);
							else if (4 !== i.tag) {
								if (13 === i.tag && 0 !== (4 & i.flags) && (s = null !== i.memoizedState)) {
									var a = i.child;
									if (null !== a && (null !== a.child && (a.child.return = a, $r(e, a, !0, s)), null !== (s = a.sibling))) {
										s.return = i, i = s;
										continue
									}
								}
								if (null !== i.child) {
									i.child.return = i, i = i.child;
									continue
								}
							}
							if (i === t) break;
							for (; null === i.sibling;) {
								if (null === i.return || i.return === t) return;
								i = i.return
							}
							i.sibling.return = i.return, i = i.sibling
						}
					};
					var pi = function(e, t, n, r) {
						for (var i = t.child; null !== i;) {
							if (5 === i.tag) {
								var s = i.stateNode;
								n && r && (s = Pe(s, i.type, i.memoizedProps, i)), Re(e, s)
							} else if (6 === i.tag) s = i.stateNode, n && r && (s = De(s, i.memoizedProps, i)), Re(e, s);
							else if (4 !== i.tag) {
								if (13 === i.tag && 0 !== (4 & i.flags) && (s = null !== i.memoizedState)) {
									var a = i.child;
									if (null !== a && (null !== a.child && (a.child.return = a, pi(e, a, !0, s)), null !== (s = a.sibling))) {
										s.return = i, i = s;
										continue
									}
								}
								if (null !== i.child) {
									i.child.return = i, i = i.child;
									continue
								}
							}
							if (i === t) break;
							for (; null === i.sibling;) {
								if (null === i.return || i.return === t) return;
								i = i.return
							}
							i.sibling.return = i.return, i = i.sibling
						}
					};
					ei = function(e) {
						var t = e.stateNode;
						if (null !== e.firstEffect) {
							var n = t.containerInfo,
								r = Be(n);
							pi(r, e, !1, !1), t.pendingChildren = r, di(e), Le(n, r)
						}
					}, ti = function(e, t, n, r, i) {
						var s = e.stateNode,
							a = e.memoizedProps;
						if ((e = null === t.firstEffect) && a === r) t.stateNode = s;
						else {
							var o = t.stateNode,
								l = Hn(Fn.current),
								c = null;
							a !== r && (c = V(o, n, a, r, i, l)), e && null === c ? t.stateNode = s : (s = Ce(s, c, n, a, r, t, e, o), z(s, n, r, i, l) && di(t), t.stateNode = s, e ? di(t) : $r(s, t, !1, !1))
						}
					}, ni = function(e, t, n, r) {
						n !== r ? (e = Hn(Nn.current), n = Hn(Fn.current), t.stateNode = j(r, e, n, t), di(t)) : t.stateNode = e.stateNode
					}
				} else ei = function() {}, ti = function() {}, ni = function() {};

				function fi(e, t) {
					if (!Xn) switch (e.tailMode) {
						case "hidden":
							t = e.tail;
							for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
							null === n ? e.tail = null : n.sibling = null;
							break;
						case "collapsed":
							n = e.tail;
							for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
							null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
					}
				}

				function mi(e, t, n) {
					var r = t.pendingProps;
					switch (t.tag) {
						case 2:
						case 16:
						case 15:
						case 0:
						case 11:
						case 7:
						case 8:
						case 12:
						case 9:
						case 14:
							return null;
						case 1:
							return st(t.type) && at(), null;
						case 3:
							return Gn(), Ze(nt), Ze(tt), tr(), (r = t.stateNode).pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (Zn(t) ? di(t) : r.hydrate || (t.flags |= 256)), ei(t), null;
						case 5:
							zn(t);
							var i = Hn(Nn.current);
							if (n = t.type, null !== e && null != t.stateNode) ti(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 128);
							else {
								if (!r) {
									if (null === t.stateNode) throw Error(o(166));
									return null
								}
								if (e = Hn(Fn.current), Zn(t)) {
									if (!Z) throw Error(o(175));
									e = Ue(t.stateNode, t.type, t.memoizedProps, i, e, t), t.updateQueue = e, null !== e && di(t)
								} else {
									var s = G(n, r, i, e, t);
									$r(s, t, !1, !1), t.stateNode = s, z(s, n, r, i, e) && di(t)
								}
								null !== t.ref && (t.flags |= 128)
							}
							return null;
						case 6:
							if (e && null != t.stateNode) ni(e, t, e.memoizedProps, r);
							else {
								if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
								if (e = Hn(Nn.current), i = Hn(Fn.current), Zn(t)) {
									if (!Z) throw Error(o(176));
									ze(t.stateNode, t.memoizedProps, t) && di(t)
								} else t.stateNode = j(r, e, i, t)
							}
							return null;
						case 13:
							return Ze(Vn), r = t.memoizedState, 0 !== (64 & t.flags) ? (t.lanes = n, t) : (r = null !== r, i = !1, null === e ? void 0 !== t.memoizedProps.fallback && Zn(t) : i = null !== e.memoizedState, r && !i && 0 !== (2 & t.mode) && (null === e && !0 !== t.memoizedProps.unstable_avoidThisFallback || 0 !== (1 & Vn.current) ? 0 === ls && (ls = 3) : (0 !== ls && 3 !== ls || (ls = 4), null === rs || 0 === (134217727 & hs) && 0 === (134217727 & ds) || zs(rs, ss))), Q && r && (t.flags |= 4), Y && (r || i) && (t.flags |= 4), null);
						case 4:
							return Gn(), ei(t), null === e && ie(t.stateNode.containerInfo), null;
						case 10:
							return cn(t), null;
						case 17:
							return st(t.type) && at(), null;
						case 19:
							if (Ze(Vn), null === (r = t.memoizedState)) return null;
							if (i = 0 !== (64 & t.flags), null === (s = r.rendering))
								if (i) fi(r, !1);
								else {
									if (0 !== ls || null !== e && 0 !== (64 & e.flags))
										for (e = t.child; null !== e;) {
											if (null !== (s = Wn(e))) {
												for (t.flags |= 64, fi(r, !1), null !== (e = s.updateQueue) && (t.updateQueue = e, t.flags |= 4), null === r.lastEffect && (t.firstEffect = null), t.lastEffect = r.lastEffect, e = n, r = t.child; null !== r;) n = e, (i = r).flags &= 2, i.nextEffect = null, i.firstEffect = null, i.lastEffect = null, null === (s = i.alternate) ? (i.childLanes = 0, i.lanes = n, i.child = null, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = s.childLanes, i.lanes = s.lanes, i.child = s.child, i.memoizedProps = s.memoizedProps, i.memoizedState = s.memoizedState, i.updateQueue = s.updateQueue, i.type = s.type, n = s.dependencies, i.dependencies = null === n ? null : {
													lanes: n.lanes,
													firstContext: n.firstContext
												}), r = r.sibling;
												return $e(Vn, 1 & Vn.current | 2), t.child
											}
											e = e.sibling
										}
									null !== r.tail && Vt() > gs && (t.flags |= 64, i = !0, fi(r, !1), t.lanes = 33554432)
								}
							else {
								if (!i)
									if (null !== (e = Wn(s))) {
										if (t.flags |= 64, i = !0, null !== (e = e.updateQueue) && (t.updateQueue = e, t.flags |= 4), fi(r, !0), null === r.tail && "hidden" === r.tailMode && !s.alternate && !Xn) return null !== (t = t.lastEffect = r.lastEffect) && (t.nextEffect = null), null
									} else 2 * Vt() - r.renderingStartTime > gs && 1073741824 !== n && (t.flags |= 64, i = !0, fi(r, !1), t.lanes = 33554432);
								r.isBackwards ? (s.sibling = t.child, t.child = s) : (null !== (e = r.last) ? e.sibling = s : t.child = s, r.last = s)
							}
							return null !== r.tail ? (e = r.tail, r.rendering = e, r.tail = e.sibling, r.lastEffect = t.lastEffect, r.renderingStartTime = Vt(), e.sibling = null, t = Vn.current, $e(Vn, i ? 1 & t | 2 : 1 & t), e) : null;
						case 23:
						case 24:
							return Xs(), null !== e && null !== e.memoizedState !== (null !== t.memoizedState) && "unstable-defer-without-hiding" !== r.mode && (t.flags |= 4), null
					}
					throw Error(o(156, t.tag))
				}

				function gi(e) {
					switch (e.tag) {
						case 1:
							st(e.type) && at();
							var t = e.flags;
							return 4096 & t ? (e.flags = -4097 & t | 64, e) : null;
						case 3:
							if (Gn(), Ze(nt), Ze(tt), tr(), 0 !== (64 & (t = e.flags))) throw Error(o(285));
							return e.flags = -4097 & t | 64, e;
						case 5:
							return zn(e), null;
						case 13:
							return Ze(Vn), 4096 & (t = e.flags) ? (e.flags = -4097 & t | 64, e) : null;
						case 19:
							return Ze(Vn), null;
						case 4:
							return Gn(), null;
						case 10:
							return cn(e), null;
						case 23:
						case 24:
							return Xs(), null;
						default:
							return null
					}
				}

				function vi(e, t) {
					try {
						var n = "",
							r = t;
						do {
							n += en(r), r = r.return
						} while (r);
						var i = n
					} catch (s) {
						i = "\nError generating stack: " + s.message + "\n" + s.stack
					}
					return {
						value: e,
						source: t,
						stack: i
					}
				}

				function yi(e, t) {
					try {
						console.error(t.value)
					} catch (n) {
						setTimeout((function() {
							throw n
						}))
					}
				}
				var xi = "function" === typeof WeakMap ? WeakMap : Map;

				function _i(e, t, n) {
					(n = gn(-1, n)).tag = 3, n.payload = {
						element: null
					};
					var r = t.value;
					return n.callback = function() {
						_s || (_s = !0, bs = r), yi(0, t)
					}, n
				}

				function bi(e, t, n) {
					(n = gn(-1, n)).tag = 3;
					var r = e.type.getDerivedStateFromError;
					if ("function" === typeof r) {
						var i = t.value;
						n.payload = function() {
							return yi(0, t), r(i)
						}
					}
					var s = e.stateNode;
					return null !== s && "function" === typeof s.componentDidCatch && (n.callback = function() {
						"function" !== typeof r && (null === ws ? ws = new Set([this]) : ws.add(this), yi(0, t));
						var e = t.stack;
						this.componentDidCatch(t.value, {
							componentStack: null !== e ? e : ""
						})
					}), n
				}
				var wi = "function" === typeof WeakSet ? WeakSet : Set;

				function Mi(e) {
					var t = e.ref;
					if (null !== t)
						if ("function" === typeof t) try {
							t(null)
						} catch (n) {
							ua(e, n)
						} else t.current = null
				}

				function Ai(e, t) {
					switch (t.tag) {
						case 0:
						case 11:
						case 15:
						case 22:
							return;
						case 1:
							if (256 & t.flags && null !== e) {
								var n = e.memoizedProps,
									r = e.memoizedState;
								t = (e = t.stateNode).getSnapshotBeforeUpdate(t.elementType === t.type ? n : tn(t.type, n), r), e.__reactInternalSnapshotBeforeUpdate = t
							}
							return;
						case 3:
							return void(Y && 256 & t.flags && Te(t.stateNode.containerInfo));
						case 5:
						case 6:
						case 4:
						case 17:
							return
					}
					throw Error(o(163))
				}

				function Si(e, t) {
					if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
						var n = t = t.next;
						do {
							if ((n.tag & e) === e) {
								var r = n.destroy;
								n.destroy = void 0, void 0 !== r && r()
							}
							n = n.next
						} while (n !== t)
					}
				}

				function Ei(e, t, n) {
					switch (n.tag) {
						case 0:
						case 11:
						case 15:
						case 22:
							if (null !== (t = null !== (t = n.updateQueue) ? t.lastEffect : null)) {
								e = t = t.next;
								do {
									if (3 === (3 & e.tag)) {
										var r = e.create;
										e.destroy = r()
									}
									e = e.next
								} while (e !== t)
							}
							if (null !== (t = null !== (t = n.updateQueue) ? t.lastEffect : null)) {
								e = t = t.next;
								do {
									var i = e;
									r = i.next, 0 !== (4 & (i = i.tag)) && 0 !== (1 & i) && (oa(n, e), aa(n, e)), e = r
								} while (e !== t)
							}
							return;
						case 1:
							return e = n.stateNode, 4 & n.flags && (null === t ? e.componentDidMount() : (r = n.elementType === n.type ? t.memoizedProps : tn(n.type, t.memoizedProps), e.componentDidUpdate(r, t.memoizedState, e.__reactInternalSnapshotBeforeUpdate))), void(null !== (t = n.updateQueue) && _n(n, t, e));
						case 3:
							if (null !== (t = n.updateQueue)) {
								if (e = null, null !== n.child) switch (n.child.tag) {
									case 5:
										e = F(n.child.stateNode);
										break;
									case 1:
										e = n.child.stateNode
								}
								_n(n, t, e)
							}
							return;
						case 5:
							return e = n.stateNode, void(null === t && 4 & n.flags && ge(e, n.type, n.memoizedProps, n));
						case 6:
						case 4:
						case 12:
							return;
						case 13:
							return void(Z && null === n.memoizedState && (n = n.alternate, null !== n && (n = n.memoizedState, null !== n && (n = n.dehydrated, null !== n && je(n)))));
						case 19:
						case 17:
						case 20:
						case 21:
						case 23:
						case 24:
							return
					}
					throw Error(o(163))
				}

				function Ti(e, t) {
					if (Y)
						for (var n = e;;) {
							if (5 === n.tag) {
								var r = n.stateNode;
								t ? Me(r) : Se(n.stateNode, n.memoizedProps)
							} else if (6 === n.tag) r = n.stateNode, t ? Ae(r) : Ee(r, n.memoizedProps);
							else if ((23 !== n.tag && 24 !== n.tag || null === n.memoizedState || n === e) && null !== n.child) {
								n.child.return = n, n = n.child;
								continue
							}
							if (n === e) break;
							for (; null === n.sibling;) {
								if (null === n.return || n.return === e) return;
								n = n.return
							}
							n.sibling.return = n.return, n = n.sibling
						}
				}

				function Ci(e, t) {
					if (dt && "function" === typeof dt.onCommitFiberUnmount) try {
						dt.onCommitFiberUnmount(ht, t)
					} catch (s) {}
					switch (t.tag) {
						case 0:
						case 11:
						case 14:
						case 15:
						case 22:
							if (null !== (e = t.updateQueue) && null !== (e = e.lastEffect)) {
								var n = e = e.next;
								do {
									var r = n,
										i = r.destroy;
									if (r = r.tag, void 0 !== i)
										if (0 !== (4 & r)) oa(t, n);
										else {
											r = t;
											try {
												i()
											} catch (s) {
												ua(r, s)
											}
										} n = n.next
								} while (n !== e)
							}
							break;
						case 1:
							if (Mi(t), "function" === typeof(e = t.stateNode).componentWillUnmount) try {
								e.props = t.memoizedProps, e.state = t.memoizedState, e.componentWillUnmount()
							} catch (s) {
								ua(t, s)
							}
							break;
						case 5:
							Mi(t);
							break;
						case 4:
							Y ? Fi(e, t) : Q && Q && (t = t.stateNode.containerInfo, e = Be(t), Ie(t, e))
					}
				}

				function Bi(e, t) {
					for (var n = t;;)
						if (Ci(e, n), null === n.child || Y && 4 === n.tag) {
							if (n === t) break;
							for (; null === n.sibling;) {
								if (null === n.return || n.return === t) return;
								n = n.return
							}
							n.sibling.return = n.return, n = n.sibling
						} else n.child.return = n, n = n.child
				}

				function Ri(e) {
					e.alternate = null, e.child = null, e.dependencies = null, e.firstEffect = null, e.lastEffect = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.return = null, e.updateQueue = null
				}

				function Li(e) {
					return 5 === e.tag || 3 === e.tag || 4 === e.tag
				}

				function Ii(e) {
					if (Y) {
						e: {
							for (var t = e.return; null !== t;) {
								if (Li(t)) break e;
								t = t.return
							}
							throw Error(o(160))
						}
						var n = t;
						switch (t = n.stateNode, n.tag) {
							case 5:
								var r = !1;
								break;
							case 3:
							case 4:
								t = t.containerInfo, r = !0;
								break;
							default:
								throw Error(o(161))
						}
						16 & n.flags && (we(t), n.flags &= -17);e: t: for (n = e;;) {
							for (; null === n.sibling;) {
								if (null === n.return || Li(n.return)) {
									n = null;
									break e
								}
								n = n.return
							}
							for (n.sibling.return = n.return, n = n.sibling; 5 !== n.tag && 6 !== n.tag && 18 !== n.tag;) {
								if (2 & n.flags) continue t;
								if (null === n.child || 4 === n.tag) continue t;
								n.child.return = n, n = n.child
							}
							if (!(2 & n.flags)) {
								n = n.stateNode;
								break e
							}
						}
						r ? Pi(e, n, t) : Di(e, n, t)
					}
				}

				function Pi(e, t, n) {
					var r = e.tag,
						i = 5 === r || 6 === r;
					if (i) e = i ? e.stateNode : e.stateNode.instance, t ? xe(n, e, t) : fe(n, e);
					else if (4 !== r && null !== (e = e.child))
						for (Pi(e, t, n), e = e.sibling; null !== e;) Pi(e, t, n), e = e.sibling
				}

				function Di(e, t, n) {
					var r = e.tag,
						i = 5 === r || 6 === r;
					if (i) e = i ? e.stateNode : e.stateNode.instance, t ? ye(n, e, t) : pe(n, e);
					else if (4 !== r && null !== (e = e.child))
						for (Di(e, t, n), e = e.sibling; null !== e;) Di(e, t, n), e = e.sibling
				}

				function Fi(e, t) {
					for (var n, r, i = t, s = !1;;) {
						if (!s) {
							s = i.return;
							e: for (;;) {
								if (null === s) throw Error(o(160));
								switch (n = s.stateNode, s.tag) {
									case 5:
										r = !1;
										break e;
									case 3:
									case 4:
										n = n.containerInfo, r = !0;
										break e
								}
								s = s.return
							}
							s = !0
						}
						if (5 === i.tag || 6 === i.tag) Bi(e, i), r ? be(n, i.stateNode) : _e(n, i.stateNode);
						else if (4 === i.tag) {
							if (null !== i.child) {
								n = i.stateNode.containerInfo, r = !0, i.child.return = i, i = i.child;
								continue
							}
						} else if (Ci(e, i), null !== i.child) {
							i.child.return = i, i = i.child;
							continue
						}
						if (i === t) break;
						for (; null === i.sibling;) {
							if (null === i.return || i.return === t) return;
							4 === (i = i.return).tag && (s = !1)
						}
						i.sibling.return = i.return, i = i.sibling
					}
				}

				function Oi(e, t) {
					if (Y) {
						switch (t.tag) {
							case 0:
							case 11:
							case 14:
							case 15:
							case 22:
								return void Si(3, t);
							case 1:
								return;
							case 5:
								var n = t.stateNode;
								if (null != n) {
									var r = t.memoizedProps;
									e = null !== e ? e.memoizedProps : r;
									var i = t.type,
										s = t.updateQueue;
									t.updateQueue = null, null !== s && ve(n, s, i, e, r, t)
								}
								return;
							case 6:
								if (null === t.stateNode) throw Error(o(162));
								return n = t.memoizedProps, void me(t.stateNode, null !== e ? e.memoizedProps : n, n);
							case 3:
								return void(Z && (t = t.stateNode, t.hydrate && (t.hydrate = !1, We(t.containerInfo))));
							case 12:
								return;
							case 13:
								return Ni(t), void Hi(t);
							case 19:
								return void Hi(t);
							case 17:
								return;
							case 23:
							case 24:
								return void Ti(t, null !== t.memoizedState)
						}
						throw Error(o(163))
					}
					switch (t.tag) {
						case 0:
						case 11:
						case 14:
						case 15:
						case 22:
							return void Si(3, t);
						case 12:
							return;
						case 13:
							return Ni(t), void Hi(t);
						case 19:
							return void Hi(t);
						case 3:
							Z && ((n = t.stateNode).hydrate && (n.hydrate = !1, We(n.containerInfo)));
							break;
						case 23:
						case 24:
							return
					}
					e: if (Q) {
						switch (t.tag) {
							case 1:
							case 5:
							case 6:
							case 20:
								break e;
							case 3:
							case 4:
								t = t.stateNode, Ie(t.containerInfo, t.pendingChildren);
								break e
						}
						throw Error(o(163))
					}
				}

				function Ni(e) {
					null !== e.memoizedState && (ms = Vt(), Y && Ti(e.child, !0))
				}

				function Hi(e) {
					var t = e.updateQueue;
					if (null !== t) {
						e.updateQueue = null;
						var n = e.stateNode;
						null === n && (n = e.stateNode = new wi), t.forEach((function(t) {
							var r = da.bind(null, e, t);
							n.has(t) || (n.add(t), t.then(r, r))
						}))
					}
				}

				function ki(e, t) {
					return null !== e && (null === (e = e.memoizedState) || null !== e.dehydrated) && (null !== (t = t.memoizedState) && null === t.dehydrated)
				}
				var Gi = 0,
					Ui = 1,
					zi = 2,
					Vi = 3,
					Wi = 4;
				if ("function" === typeof Symbol && Symbol.for) {
					var ji = Symbol.for;
					Gi = ji("selector.component"), Ui = ji("selector.has_pseudo_class"), zi = ji("selector.role"), Vi = ji("selector.test_id"), Wi = ji("selector.text")
				}

				function Ji(e) {
					var t = $(e);
					if (null != t) {
						if ("string" !== typeof t.memoizedProps["data-testname"]) throw Error(o(364));
						return t
					}
					if (null === (e = ae(e))) throw Error(o(362));
					return e.stateNode.current
				}

				function Xi(e, t) {
					switch (t.$$typeof) {
						case Gi:
							if (e.type === t.value) return !0;
							break;
						case Ui:
							e: {
								t = t.value,
								e = [e, 0];
								for (var n = 0; n < e.length;) {
									var r = e[n++],
										i = e[n++],
										s = t[i];
									if (5 !== r.tag || !ce(r)) {
										for (; null != s && Xi(r, s);) s = t[++i];
										if (i === t.length) {
											t = !0;
											break e
										}
										for (r = r.child; null !== r;) e.push(r, i), r = r.sibling
									}
								}
								t = !1
							}
							return t;
						case zi:
							if (5 === e.tag && ue(e.stateNode, t.value)) return !0;
							break;
						case Wi:
							if ((5 === e.tag || 6 === e.tag) && (null !== (e = le(e)) && 0 <= e.indexOf(t.value))) return !0;
							break;
						case Vi:
							if (5 === e.tag && ("string" === typeof(e = e.memoizedProps["data-testname"]) && e.toLowerCase() === t.value.toLowerCase())) return !0;
							break;
						default:
							throw Error(o(365, t))
					}
					return !1
				}

				function qi(e) {
					switch (e.$$typeof) {
						case Gi:
							return "<" + (C(e.value) || "Unknown") + ">";
						case Ui:
							return ":has(" + (qi(e) || "") + ")";
						case zi:
							return '[role="' + e.value + '"]';
						case Wi:
							return '"' + e.value + '"';
						case Vi:
							return '[data-testname="' + e.value + '"]';
						default:
							throw Error(o(365, e))
					}
				}

				function Ki(e, t) {
					var n = [];
					e = [e, 0];
					for (var r = 0; r < e.length;) {
						var i = e[r++],
							s = e[r++],
							a = t[s];
						if (5 !== i.tag || !ce(i)) {
							for (; null != a && Xi(i, a);) a = t[++s];
							if (s === t.length) n.push(i);
							else
								for (i = i.child; null !== i;) e.push(i, s), i = i.sibling
						}
					}
					return n
				}

				function Yi(e, t) {
					if (!se) throw Error(o(363));
					e = Ki(e = Ji(e), t), t = [], e = Array.from(e);
					for (var n = 0; n < e.length;) {
						var r = e[n++];
						if (5 === r.tag) ce(r) || t.push(r.stateNode);
						else
							for (r = r.child; null !== r;) e.push(r), r = r.sibling
					}
					return t
				}
				var Qi = null;
				var Zi = Math.ceil,
					$i = l.ReactCurrentDispatcher,
					es = l.ReactCurrentOwner,
					ts = l.IsSomeRendererActing,
					ns = 0,
					rs = null,
					is = null,
					ss = 0,
					as = 0,
					os = Qe(0),
					ls = 0,
					cs = null,
					us = 0,
					hs = 0,
					ds = 0,
					ps = 0,
					fs = null,
					ms = 0,
					gs = 1 / 0;

				function vs() {
					gs = Vt() + 500
				}
				var ys, xs = null,
					_s = !1,
					bs = null,
					ws = null,
					Ms = !1,
					As = null,
					Ss = 90,
					Es = [],
					Ts = [],
					Cs = null,
					Bs = 0,
					Rs = null,
					Ls = -1,
					Is = 0,
					Ps = 0,
					Ds = null,
					Fs = !1;

				function Os() {
					return 0 !== (48 & ns) ? Vt() : -1 !== Ls ? Ls : Ls = Vt()
				}

				function Ns(e) {
					if (0 === (2 & (e = e.mode))) return 1;
					if (0 === (4 & e)) return 99 === Wt() ? 1 : 2;
					if (0 === Is && (Is = us), 0 !== Yt.transition) {
						0 !== Ps && (Ps = null !== fs ? fs.pendingLanes : 0), e = Is;
						var t = 4186112 & ~Ps;
						return 0 === (t &= -t) && (0 === (t = (e = 4186112 & ~e) & -e) && (t = 8192)), t
					}
					return e = Wt(), 0 !== (4 & ns) && 98 === e ? e = yt(12, Is) : e = yt(e = function(e) {
						switch (e) {
							case 99:
								return 15;
							case 98:
								return 10;
							case 97:
							case 96:
								return 8;
							case 95:
								return 2;
							default:
								return 0
						}
					}(e), Is), e
				}

				function Hs(e, t, n) {
					if (50 < Bs) throw Bs = 0, Rs = null, Error(o(185));
					if (null === (e = ks(e, t))) return null;
					bt(e, t, n), e === rs && (ds |= t, 4 === ls && zs(e, ss));
					var r = Wt();
					1 === t ? 0 !== (8 & ns) && 0 === (48 & ns) ? Vs(e) : (Gs(e, n), 0 === ns && (vs(), qt())) : (0 === (4 & ns) || 98 !== r && 99 !== r || (null === Cs ? Cs = new Set([e]) : Cs.add(e)), Gs(e, n)), fs = e
				}

				function ks(e, t) {
					e.lanes |= t;
					var n = e.alternate;
					for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
					return 3 === n.tag ? n.stateNode : null
				}

				function Gs(e, t) {
					for (var n = e.callbackNode, r = e.suspendedLanes, i = e.pingedLanes, s = e.expirationTimes, a = e.pendingLanes; 0 < a;) {
						var l = 31 - wt(a),
							c = 1 << l,
							u = s[l];
						if (-1 === u) {
							if (0 === (c & r) || 0 !== (c & i)) {
								u = t, mt(c);
								var h = ft;
								s[l] = 10 <= h ? u + 250 : 6 <= h ? u + 5e3 : -1
							}
						} else u <= t && (e.expiredLanes |= c);
						a &= ~c
					}
					if (r = gt(e, e === rs ? ss : 0), t = ft, 0 === r) null !== n && (n !== Nt && Tt(n), e.callbackNode = null, e.callbackPriority = 0);
					else {
						if (null !== n) {
							if (e.callbackPriority === t) return;
							n !== Nt && Tt(n)
						}
						15 === t ? (n = Vs.bind(null, e), null === kt ? (kt = [n], Gt = Et(It, Kt)) : kt.push(n), n = Nt) : 14 === t ? n = Xt(99, Vs.bind(null, e)) : n = Xt(n = function(e) {
							switch (e) {
								case 15:
								case 14:
									return 99;
								case 13:
								case 12:
								case 11:
								case 10:
									return 98;
								case 9:
								case 8:
								case 7:
								case 6:
								case 4:
								case 5:
									return 97;
								case 3:
								case 2:
								case 1:
									return 95;
								case 0:
									return 90;
								default:
									throw Error(o(358, e))
							}
						}(t), Us.bind(null, e)), e.callbackPriority = t, e.callbackNode = n
					}
				}

				function Us(e) {
					if (Ls = -1, Ps = Is = 0, 0 !== (48 & ns)) throw Error(o(327));
					var t = e.callbackNode;
					if (sa() && e.callbackNode !== t) return null;
					var n = gt(e, e === rs ? ss : 0);
					if (0 === n) return null;
					var r = n,
						i = ns;
					ns |= 16;
					var s = Ys();
					for (rs === e && ss === r || (vs(), qs(e, r));;) try {
						$s();
						break
					} catch (l) {
						Ks(e, l)
					}
					if (on(), $i.current = s, ns = i, null !== is ? r = 0 : (rs = null, ss = 0, r = ls), 0 !== (us & ds)) qs(e, 0);
					else if (0 !== r) {
						if (2 === r && (ns |= 64, e.hydrate && (e.hydrate = !1, Te(e.containerInfo)), 0 !== (n = vt(e)) && (r = Qs(e, n))), 1 === r) throw t = cs, qs(e, 0), zs(e, n), Gs(e, Vt()), t;
						switch (e.finishedWork = e.current.alternate, e.finishedLanes = n, r) {
							case 0:
							case 1:
								throw Error(o(345));
							case 2:
								na(e);
								break;
							case 3:
								if (zs(e, n), (62914560 & n) === n && 10 < (r = ms + 500 - Vt())) {
									if (0 !== gt(e, 0)) break;
									if (((i = e.suspendedLanes) & n) !== n) {
										Os(), e.pingedLanes |= e.suspendedLanes & i;
										break
									}
									e.timeoutHandle = J(na.bind(null, e), r);
									break
								}
								na(e);
								break;
							case 4:
								if (zs(e, n), (4186112 & n) === n) break;
								for (r = e.eventTimes, i = -1; 0 < n;) {
									var a = 31 - wt(n);
									s = 1 << a, (a = r[a]) > i && (i = a), n &= ~s
								}
								if (n = i, 10 < (n = (120 > (n = Vt() - n) ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Zi(n / 1960)) - n)) {
									e.timeoutHandle = J(na.bind(null, e), n);
									break
								}
								na(e);
								break;
							case 5:
								na(e);
								break;
							default:
								throw Error(o(329))
						}
					}
					return Gs(e, Vt()), e.callbackNode === t ? Us.bind(null, e) : null
				}

				function zs(e, t) {
					for (t &= ~ps, t &= ~ds, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
						var n = 31 - wt(t),
							r = 1 << n;
						e[n] = -1, t &= ~r
					}
				}

				function Vs(e) {
					if (0 !== (48 & ns)) throw Error(o(327));
					if (sa(), e === rs && 0 !== (e.expiredLanes & ss)) {
						var t = ss,
							n = Qs(e, t);
						0 !== (us & ds) && (n = Qs(e, t = gt(e, t)))
					} else n = Qs(e, t = gt(e, 0));
					if (0 !== e.tag && 2 === n && (ns |= 64, e.hydrate && (e.hydrate = !1, Te(e.containerInfo)), 0 !== (t = vt(e)) && (n = Qs(e, t))), 1 === n) throw n = cs, qs(e, 0), zs(e, t), Gs(e, Vt()), n;
					return e.finishedWork = e.current.alternate, e.finishedLanes = t, na(e), Gs(e, Vt()), null
				}

				function Ws(e, t) {
					var n = ns;
					ns |= 1;
					try {
						return e(t)
					} finally {
						0 === (ns = n) && (vs(), qt())
					}
				}

				function js(e, t) {
					var n = ns;
					if (0 !== (48 & n)) return e(t);
					ns |= 1;
					try {
						if (e) return Jt(99, e.bind(null, t))
					} finally {
						ns = n, qt()
					}
				}

				function Js(e, t) {
					$e(os, as), as |= t, us |= t
				}

				function Xs() {
					as = os.current, Ze(os)
				}

				function qs(e, t) {
					e.finishedWork = null, e.finishedLanes = 0;
					var n = e.timeoutHandle;
					if (n !== q && (e.timeoutHandle = q, X(n)), null !== is)
						for (n = is.return; null !== n;) {
							var r = n;
							switch (r.tag) {
								case 1:
									null !== (r = r.type.childContextTypes) && void 0 !== r && at();
									break;
								case 3:
									Gn(), Ze(nt), Ze(tt), tr();
									break;
								case 5:
									zn(r);
									break;
								case 4:
									Gn();
									break;
								case 13:
								case 19:
									Ze(Vn);
									break;
								case 10:
									cn(r);
									break;
								case 23:
								case 24:
									Xs()
							}
							n = n.return
						}
					rs = e, is = Ma(e.current, null), ss = as = us = t, ls = 0, cs = null, ps = ds = hs = 0
				}

				function Ks(e, t) {
					for (;;) {
						var n = is;
						try {
							if (on(), nr.current = Nr, lr) {
								for (var r = sr.memoizedState; null !== r;) {
									var i = r.queue;
									null !== i && (i.pending = null), r = r.next
								}
								lr = !1
							}
							if (ir = 0, or = ar = sr = null, cr = !1, es.current = null, null === n || null === n.return) {
								ls = 1, cs = t, is = null;
								break
							}
							e: {
								var s = e,
									a = n.return,
									o = n,
									l = t;
								if (t = ss, o.flags |= 2048, o.firstEffect = o.lastEffect = null, null !== l && "object" === typeof l && "function" === typeof l.then) {
									var c = l;
									if (0 === (2 & o.mode)) {
										var u = o.alternate;
										u ? (o.updateQueue = u.updateQueue, o.memoizedState = u.memoizedState, o.lanes = u.lanes) : (o.updateQueue = null, o.memoizedState = null)
									}
									var h = 0 !== (1 & Vn.current),
										d = a;
									do {
										var p;
										if (p = 13 === d.tag) {
											var f = d.memoizedState;
											if (null !== f) p = null !== f.dehydrated;
											else {
												var m = d.memoizedProps;
												p = void 0 !== m.fallback && (!0 !== m.unstable_avoidThisFallback || !h)
											}
										}
										if (p) {
											var g = d.updateQueue;
											if (null === g) {
												var v = new Set;
												v.add(c), d.updateQueue = v
											} else g.add(c);
											if (0 === (2 & d.mode)) {
												if (d.flags |= 64, o.flags |= 16384, o.flags &= -2981, 1 === o.tag)
													if (null === o.alternate) o.tag = 17;
													else {
														var y = gn(-1, 1);
														y.tag = 2, vn(o, y)
													} o.lanes |= 1;
												break e
											}
											l = void 0, o = t;
											var x = s.pingCache;
											if (null === x ? (x = s.pingCache = new xi, l = new Set, x.set(c, l)) : void 0 === (l = x.get(c)) && (l = new Set, x.set(c, l)), !l.has(o)) {
												l.add(o);
												var _ = ha.bind(null, s, c, o);
												c.then(_, _)
											}
											d.flags |= 4096, d.lanes = t;
											break e
										}
										d = d.return
									} while (null !== d);
									l = Error((C(o.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")
								}
								5 !== ls && (ls = 2),
								l = vi(l, o),
								d = a;do {
									switch (d.tag) {
										case 3:
											s = l, d.flags |= 4096, t &= -t, d.lanes |= t, yn(d, _i(0, s, t));
											break e;
										case 1:
											s = l;
											var b = d.type,
												w = d.stateNode;
											if (0 === (64 & d.flags) && ("function" === typeof b.getDerivedStateFromError || null !== w && "function" === typeof w.componentDidCatch && (null === ws || !ws.has(w)))) {
												d.flags |= 4096, t &= -t, d.lanes |= t, yn(d, bi(d, s, t));
												break e
											}
									}
									d = d.return
								} while (null !== d)
							}
							ta(n)
						} catch (M) {
							t = M, is === n && null !== n && (is = n = n.return);
							continue
						}
						break
					}
				}

				function Ys() {
					var e = $i.current;
					return $i.current = Nr, null === e ? Nr : e
				}

				function Qs(e, t) {
					var n = ns;
					ns |= 16;
					var r = Ys();
					for (rs === e && ss === t || qs(e, t);;) try {
						Zs();
						break
					} catch (i) {
						Ks(e, i)
					}
					if (on(), ns = n, $i.current = r, null !== is) throw Error(o(261));
					return rs = null, ss = 0, ls
				}

				function Zs() {
					for (; null !== is;) ea(is)
				}

				function $s() {
					for (; null !== is && !Ct();) ea(is)
				}

				function ea(e) {
					var t = ys(e.alternate, e, as);
					e.memoizedProps = e.pendingProps, null === t ? ta(e) : is = t, es.current = null
				}

				function ta(e) {
					var t = e;
					do {
						var n = t.alternate;
						if (e = t.return, 0 === (2048 & t.flags)) {
							if (null !== (n = mi(n, t, as))) return void(is = n);
							if (24 !== (n = t).tag && 23 !== n.tag || null === n.memoizedState || 0 !== (1073741824 & as) || 0 === (4 & n.mode)) {
								for (var r = 0, i = n.child; null !== i;) r |= i.lanes | i.childLanes, i = i.sibling;
								n.childLanes = r
							}
							null !== e && 0 === (2048 & e.flags) && (null === e.firstEffect && (e.firstEffect = t.firstEffect), null !== t.lastEffect && (null !== e.lastEffect && (e.lastEffect.nextEffect = t.firstEffect), e.lastEffect = t.lastEffect), 1 < t.flags && (null !== e.lastEffect ? e.lastEffect.nextEffect = t : e.firstEffect = t, e.lastEffect = t))
						} else {
							if (null !== (n = gi(t))) return n.flags &= 2047, void(is = n);
							null !== e && (e.firstEffect = e.lastEffect = null, e.flags |= 2048)
						}
						if (null !== (t = t.sibling)) return void(is = t);
						is = t = e
					} while (null !== t);
					0 === ls && (ls = 5)
				}

				function na(e) {
					var t = Wt();
					return Jt(99, ra.bind(null, e, t)), null
				}

				function ra(e, t) {
					do {
						sa()
					} while (null !== As);
					if (0 !== (48 & ns)) throw Error(o(327));
					var n = e.finishedWork;
					if (null === n) return null;
					if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177));
					e.callbackNode = null;
					var r = n.lanes | n.childLanes,
						i = r,
						s = e.pendingLanes & ~i;
					e.pendingLanes = i, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= i, e.mutableReadLanes &= i, e.entangledLanes &= i, i = e.entanglements;
					for (var a = e.eventTimes, l = e.expirationTimes; 0 < s;) {
						var c = 31 - wt(s),
							u = 1 << c;
						i[c] = 0, a[c] = -1, l[c] = -1, s &= ~u
					}
					if (null !== Cs && 0 === (24 & r) && Cs.has(e) && Cs.delete(e), e === rs && (is = rs = null, ss = 0), 1 < n.flags ? null !== n.lastEffect ? (n.lastEffect.nextEffect = n, r = n.firstEffect) : r = n : r = n.firstEffect, null !== r) {
						i = ns, ns |= 32, es.current = null, Ds = H(e.containerInfo), Fs = !1, xs = r;
						do {
							try {
								ia()
							} catch (y) {
								if (null === xs) throw Error(o(330));
								ua(xs, y), xs = xs.nextEffect
							}
						} while (null !== xs);
						Ds = null, xs = r;
						do {
							try {
								for (a = e; null !== xs;) {
									var h = xs.flags;
									if (16 & h && Y && we(xs.stateNode), 128 & h) {
										var d = xs.alternate;
										if (null !== d) {
											var p = d.ref;
											null !== p && ("function" === typeof p ? p(null) : p.current = null)
										}
									}
									switch (1038 & h) {
										case 2:
											Ii(xs), xs.flags &= -3;
											break;
										case 6:
											Ii(xs), xs.flags &= -3, Oi(xs.alternate, xs);
											break;
										case 1024:
											xs.flags &= -1025;
											break;
										case 1028:
											xs.flags &= -1025, Oi(xs.alternate, xs);
											break;
										case 4:
											Oi(xs.alternate, xs);
											break;
										case 8:
											l = a, s = xs, Y ? Fi(l, s) : Bi(l, s);
											var f = s.alternate;
											Ri(s), null !== f && Ri(f)
									}
									xs = xs.nextEffect
								}
							} catch (y) {
								if (null === xs) throw Error(o(330));
								ua(xs, y), xs = xs.nextEffect
							}
						} while (null !== xs);
						Fs && re(), k(e.containerInfo), e.current = n, xs = r;
						do {
							try {
								for (h = e; null !== xs;) {
									var m = xs.flags;
									if (36 & m && Ei(h, xs.alternate, xs), 128 & m) {
										d = void 0;
										var g = xs.ref;
										if (null !== g) {
											var v = xs.stateNode;
											switch (xs.tag) {
												case 5:
													d = F(v);
													break;
												default:
													d = v
											}
											"function" === typeof g ? g(d) : g.current = d
										}
									}
									xs = xs.nextEffect
								}
							} catch (y) {
								if (null === xs) throw Error(o(330));
								ua(xs, y), xs = xs.nextEffect
							}
						} while (null !== xs);
						xs = null, Ht(), ns = i
					} else e.current = n;
					if (Ms) Ms = !1, As = e, Ss = t;
					else
						for (xs = r; null !== xs;) t = xs.nextEffect, xs.nextEffect = null, 8 & xs.flags && ((m = xs).sibling = null, m.stateNode = null), xs = t;
					if (0 === (r = e.pendingLanes) && (ws = null), 1 === r ? e === Rs ? Bs++ : (Bs = 0, Rs = e) : Bs = 0, n = n.stateNode, dt && "function" === typeof dt.onCommitFiberRoot) try {
						dt.onCommitFiberRoot(ht, n, void 0, 64 === (64 & n.current.flags))
					} catch (y) {}
					if (Gs(e, Vt()), _s) throw _s = !1, e = bs, bs = null, e;
					return 0 !== (8 & ns) || qt(), null
				}

				function ia() {
					for (; null !== xs;) {
						var e = xs.alternate;
						Fs || null === Ds || (0 !== (8 & xs.flags) ? P(xs, Ds) && (Fs = !0, ne()) : 13 === xs.tag && ki(e, xs) && P(xs, Ds) && (Fs = !0, ne()));
						var t = xs.flags;
						0 !== (256 & t) && Ai(e, xs), 0 === (512 & t) || Ms || (Ms = !0, Xt(97, (function() {
							return sa(), null
						}))), xs = xs.nextEffect
					}
				}

				function sa() {
					if (90 !== Ss) {
						var e = 97 < Ss ? 97 : Ss;
						return Ss = 90, Jt(e, la)
					}
					return !1
				}

				function aa(e, t) {
					Es.push(t, e), Ms || (Ms = !0, Xt(97, (function() {
						return sa(), null
					})))
				}

				function oa(e, t) {
					Ts.push(t, e), Ms || (Ms = !0, Xt(97, (function() {
						return sa(), null
					})))
				}

				function la() {
					if (null === As) return !1;
					var e = As;
					if (As = null, 0 !== (48 & ns)) throw Error(o(331));
					var t = ns;
					ns |= 32;
					var n = Ts;
					Ts = [];
					for (var r = 0; r < n.length; r += 2) {
						var i = n[r],
							s = n[r + 1],
							a = i.destroy;
						if (i.destroy = void 0, "function" === typeof a) try {
							a()
						} catch (c) {
							if (null === s) throw Error(o(330));
							ua(s, c)
						}
					}
					for (n = Es, Es = [], r = 0; r < n.length; r += 2) {
						i = n[r], s = n[r + 1];
						try {
							var l = i.create;
							i.destroy = l()
						} catch (c) {
							if (null === s) throw Error(o(330));
							ua(s, c)
						}
					}
					for (l = e.current.firstEffect; null !== l;) e = l.nextEffect, l.nextEffect = null, 8 & l.flags && (l.sibling = null, l.stateNode = null), l = e;
					return ns = t, qt(), !0
				}

				function ca(e, t, n) {
					vn(e, t = _i(0, t = vi(n, t), 1)), t = Os(), null !== (e = ks(e, 1)) && (bt(e, 1, t), Gs(e, t))
				}

				function ua(e, t) {
					if (3 === e.tag) ca(e, e, t);
					else
						for (var n = e.return; null !== n;) {
							if (3 === n.tag) {
								ca(n, e, t);
								break
							}
							if (1 === n.tag) {
								var r = n.stateNode;
								if ("function" === typeof n.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === ws || !ws.has(r))) {
									var i = bi(n, e = vi(t, e), 1);
									if (vn(n, i), i = Os(), null !== (n = ks(n, 1))) bt(n, 1, i), Gs(n, i);
									else if ("function" === typeof r.componentDidCatch && (null === ws || !ws.has(r))) try {
										r.componentDidCatch(t, e)
									} catch (s) {}
									break
								}
							}
							n = n.return
						}
				}

				function ha(e, t, n) {
					var r = e.pingCache;
					null !== r && r.delete(t), t = Os(), e.pingedLanes |= e.suspendedLanes & n, rs === e && (ss & n) === n && (4 === ls || 3 === ls && (62914560 & ss) === ss && 500 > Vt() - ms ? qs(e, 0) : ps |= n), Gs(e, t)
				}

				function da(e, t) {
					var n = e.stateNode;
					null !== n && n.delete(t), 0 === (t = 0) && (0 === (2 & (t = e.mode)) ? t = 1 : 0 === (4 & t) ? t = 99 === Wt() ? 1 : 2 : (0 === Is && (Is = us), 0 === (t = xt(62914560 & ~Is)) && (t = 4194304))), n = Os(), null !== (e = ks(e, t)) && (bt(e, t, n), Gs(e, n))
				}
				ys = function(e, t, n) {
					var r = t.lanes;
					if (null !== e)
						if (e.memoizedProps !== t.pendingProps || nt.current) zr = !0;
						else {
							if (0 === (n & r)) {
								switch (zr = !1, t.tag) {
									case 3:
										Zr(t), $n();
										break;
									case 5:
										Un(t);
										break;
									case 1:
										st(t.type) && ct(t);
										break;
									case 4:
										kn(t, t.stateNode.containerInfo);
										break;
									case 10:
										ln(t, t.memoizedProps.value);
										break;
									case 13:
										if (null !== t.memoizedState) return 0 !== (n & t.child.childLanes) ? ii(e, t, n) : ($e(Vn, 1 & Vn.current), null !== (t = hi(e, t, n)) ? t.sibling : null);
										$e(Vn, 1 & Vn.current);
										break;
									case 19:
										if (r = 0 !== (n & t.childLanes), 0 !== (64 & e.flags)) {
											if (r) return ui(e, t, n);
											t.flags |= 64
										}
										var i = t.memoizedState;
										if (null !== i && (i.rendering = null, i.tail = null, i.lastEffect = null), $e(Vn, Vn.current), r) break;
										return null;
									case 23:
									case 24:
										return t.lanes = 0, Xr(e, t, n)
								}
								return hi(e, t, n)
							}
							zr = 0 !== (16384 & e.flags)
						}
					else zr = !1;
					switch (t.lanes = 0, t.tag) {
						case 2:
							if (r = t.type, null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps, i = it(t, tt.current), hn(t, n), i = dr(null, t, r, e, i, n), t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof) {
								if (t.tag = 1, t.memoizedState = null, t.updateQueue = null, st(r)) {
									var s = !0;
									ct(t)
								} else s = !1;
								t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, fn(t);
								var a = r.getDerivedStateFromProps;
								"function" === typeof a && wn(t, r, a, e), i.updater = Mn, t.stateNode = i, i._reactInternals = t, Tn(t, r, e, n), t = Qr(null, t, r, !0, s, n)
							} else t.tag = 0, Vr(null, t, i, n), t = t.child;
							return t;
						case 16:
							i = t.elementType;
							e: {
								switch (null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps, i = (s = i._init)(i._payload), t.type = i, s = t.tag = function(e) {
										if ("function" === typeof e) return wa(e) ? 1 : 0;
										if (void 0 !== e && null !== e) {
											if ((e = e.$$typeof) === g) return 11;
											if (e === x) return 14
										}
										return 2
									}(i), e = tn(i, e), s) {
									case 0:
										t = Kr(null, t, i, e, n);
										break e;
									case 1:
										t = Yr(null, t, i, e, n);
										break e;
									case 11:
										t = Wr(null, t, i, e, n);
										break e;
									case 14:
										t = jr(null, t, i, tn(i.type, e), r, n);
										break e
								}
								throw Error(o(306, i, ""))
							}
							return t;
						case 0:
							return r = t.type, i = t.pendingProps, Kr(e, t, r, i = t.elementType === r ? i : tn(r, i), n);
						case 1:
							return r = t.type, i = t.pendingProps, Yr(e, t, r, i = t.elementType === r ? i : tn(r, i), n);
						case 3:
							if (Zr(t), r = t.updateQueue, null === e || null === r) throw Error(o(282));
							if (r = t.pendingProps, i = null !== (i = t.memoizedState) ? i.element : null, mn(e, t), xn(t, r, null, n), (r = t.memoizedState.element) === i) $n(), t = hi(e, t, n);
							else {
								if ((s = (i = t.stateNode).hydrate) && (Z ? (Jn = Ge(t.stateNode.containerInfo), jn = t, s = Xn = !0) : s = !1), s) {
									if (Z && null != (e = i.mutableSourceEagerHydrationData))
										for (i = 0; i < e.length; i += 2) s = e[i], a = e[i + 1], K ? s._workInProgressVersionPrimary = a : s._workInProgressVersionSecondary = a, er.push(s);
									for (n = Pn(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 1024, n = n.sibling
								} else Vr(e, t, r, n), $n();
								t = t.child
							}
							return t;
						case 5:
							return Un(t), null === e && Yn(t), r = t.type, i = t.pendingProps, s = null !== e ? e.memoizedProps : null, a = i.children, W(r, i) ? a = null : null !== s && W(r, s) && (t.flags |= 16), qr(e, t), Vr(e, t, a, n), t.child;
						case 6:
							return null === e && Yn(t), null;
						case 13:
							return ii(e, t, n);
						case 4:
							return kn(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = In(t, null, r, n) : Vr(e, t, r, n), t.child;
						case 11:
							return r = t.type, i = t.pendingProps, Wr(e, t, r, i = t.elementType === r ? i : tn(r, i), n);
						case 7:
							return Vr(e, t, t.pendingProps, n), t.child;
						case 8:
						case 12:
							return Vr(e, t, t.pendingProps.children, n), t.child;
						case 10:
							e: {
								if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, ln(t, s = i.value), null !== a) {
									var l = a.value;
									if (0 === (s = Qt(l, s) ? 0 : 0 | ("function" === typeof r._calculateChangedBits ? r._calculateChangedBits(l, s) : 1073741823))) {
										if (a.children === i.children && !nt.current) {
											t = hi(e, t, n);
											break e
										}
									} else
										for (null !== (l = t.child) && (l.return = t); null !== l;) {
											var c = l.dependencies;
											if (null !== c) {
												a = l.child;
												for (var u = c.firstContext; null !== u;) {
													if (u.context === r && 0 !== (u.observedBits & s)) {
														1 === l.tag && ((u = gn(-1, n & -n)).tag = 2, vn(l, u)), l.lanes |= n, null !== (u = l.alternate) && (u.lanes |= n), un(l.return, n), c.lanes |= n;
														break
													}
													u = u.next
												}
											} else a = 10 === l.tag && l.type === t.type ? null : l.child;
											if (null !== a) a.return = l;
											else
												for (a = l; null !== a;) {
													if (a === t) {
														a = null;
														break
													}
													if (null !== (l = a.sibling)) {
														l.return = a.return, a = l;
														break
													}
													a = a.return
												}
											l = a
										}
								}
								Vr(e, t, i.children, n),
								t = t.child
							}
							return t;
						case 9:
							return i = t.type, r = (s = t.pendingProps).children, hn(t, n), r = r(i = dn(i, s.unstable_observedBits)), t.flags |= 1, Vr(e, t, r, n), t.child;
						case 14:
							return s = tn(i = t.type, t.pendingProps), jr(e, t, i, s = tn(i.type, s), r, n);
						case 15:
							return Jr(e, t, t.type, t.pendingProps, r, n);
						case 17:
							return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : tn(r, i), null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), t.tag = 1, st(r) ? (e = !0, ct(t)) : e = !1, hn(t, n), Sn(t, r, i), Tn(t, r, i, n), Qr(null, t, r, !0, e, n);
						case 19:
							return ui(e, t, n);
						case 23:
						case 24:
							return Xr(e, t, n)
					}
					throw Error(o(156, t.tag))
				};
				var pa = {
						current: !1
					},
					fa = a.unstable_flushAllWithoutAsserting,
					ma = "function" === typeof fa;

				function ga() {
					if (void 0 !== fa) return fa();
					for (var e = !1; sa();) e = !0;
					return e
				}

				function va(t) {
					try {
						ga(),
							function(t) {
								if (null === Qi) try {
									var n = ("require" + Math.random()).slice(0, 7);
									Qi = (e && e[n]).call(e, "timers").setImmediate
								} catch (r) {
									Qi = function(e) {
										var t = new MessageChannel;
										t.port1.onmessage = e, t.port2.postMessage(void 0)
									}
								}
								Qi(t)
							}((function() {
								ga() ? va(t) : t()
							}))
					} catch (n) {
						t(n)
					}
				}
				var ya = 0,
					xa = !1;

				function _a(e, t, n, r) {
					this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null
				}

				function ba(e, t, n, r) {
					return new _a(e, t, n, r)
				}

				function wa(e) {
					return !(!(e = e.prototype) || !e.isReactComponent)
				}

				function Ma(e, t) {
					var n = e.alternate;
					return null === n ? ((n = ba(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.nextEffect = null, n.firstEffect = null, n.lastEffect = null), n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
						lanes: t.lanes,
						firstContext: t.firstContext
					}, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
				}

				function Aa(e, t, n, r, i, s) {
					var a = 2;
					if (r = e, "function" === typeof e) wa(e) && (a = 1);
					else if ("string" === typeof e) a = 5;
					else e: switch (e) {
						case h:
							return Sa(n.children, i, s, t);
						case w:
							a = 8, i |= 16;
							break;
						case d:
							a = 8, i |= 1;
							break;
						case p:
							return (e = ba(12, n, t, 8 | i)).elementType = p, e.type = p, e.lanes = s, e;
						case v:
							return (e = ba(13, n, t, i)).type = v, e.elementType = v, e.lanes = s, e;
						case y:
							return (e = ba(19, n, t, i)).elementType = y, e.lanes = s, e;
						case M:
							return Ea(n, i, s, t);
						case A:
							return (e = ba(24, n, t, i)).elementType = A, e.lanes = s, e;
						default:
							if ("object" === typeof e && null !== e) switch (e.$$typeof) {
								case f:
									a = 10;
									break e;
								case m:
									a = 9;
									break e;
								case g:
									a = 11;
									break e;
								case x:
									a = 14;
									break e;
								case _:
									a = 16, r = null;
									break e;
								case b:
									a = 22;
									break e
							}
							throw Error(o(130, null == e ? e : typeof e, ""))
					}
					return (t = ba(a, n, t, i)).elementType = e, t.type = r, t.lanes = s, t
				}

				function Sa(e, t, n, r) {
					return (e = ba(7, e, r, t)).lanes = n, e
				}

				function Ea(e, t, n, r) {
					return (e = ba(23, e, r, t)).elementType = M, e.lanes = n, e
				}

				function Ta(e, t, n) {
					return (e = ba(6, e, null, t)).lanes = n, e
				}

				function Ca(e, t, n) {
					return (t = ba(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
						containerInfo: e.containerInfo,
						pendingChildren: null,
						implementation: e.implementation
					}, t
				}

				function Ba(e, t, n) {
					this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = q, this.pendingContext = this.context = null, this.hydrate = n, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = _t(0), this.expirationTimes = _t(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = _t(0), Z && (this.mutableSourceEagerHydrationData = null)
				}

				function Ra(e) {
					var t = e._reactInternals;
					if (void 0 === t) {
						if ("function" === typeof e.render) throw Error(o(188));
						throw Error(o(268, Object.keys(e)))
					}
					return null === (e = I(t)) ? null : e.stateNode
				}

				function La(e, t) {
					if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
						var n = e.retryLane;
						e.retryLane = 0 !== n && n < t ? n : t
					}
				}

				function Ia(e, t) {
					La(e, t), (e = e.alternate) && La(e, t)
				}

				function Pa(e) {
					return null === (e = I(e)) ? null : e.stateNode
				}

				function Da() {
					return null
				}
				return r.IsThisRendererActing = pa, r.act = function(e) {
					function t() {
						ya--, ts.current = n, pa.current = r
					}!1 === xa && (xa = !0, console.error("act(...) is not supported in production builds of React, and might not behave as expected.")), ya++;
					var n = ts.current,
						r = pa.current;
					ts.current = !0, pa.current = !0;
					try {
						var i = Ws(e)
					} catch (s) {
						throw t(), s
					}
					if (null !== i && "object" === typeof i && "function" === typeof i.then) return {
						then: function(e, r) {
							i.then((function() {
								1 < ya || !0 === ma && !0 === n ? (t(), e()) : va((function(n) {
									t(), n ? r(n) : e()
								}))
							}), (function(e) {
								t(), r(e)
							}))
						}
					};
					try {
						1 !== ya || !1 !== ma && !1 !== n || ga(), t()
					} catch (s) {
						throw t(), s
					}
					return {
						then: function(e) {
							e()
						}
					}
				}, r.attemptContinuousHydration = function(e) {
					13 === e.tag && (Hs(e, 67108864, Os()), Ia(e, 67108864))
				}, r.attemptHydrationAtCurrentPriority = function(e) {
					if (13 === e.tag) {
						var t = Os(),
							n = Ns(e);
						Hs(e, n, t), Ia(e, n)
					}
				}, r.attemptSynchronousHydration = function(e) {
					switch (e.tag) {
						case 3:
							var t = e.stateNode;
							if (t.hydrate) {
								var n = mt(t.pendingLanes);
								t.expiredLanes |= n & t.pendingLanes, Gs(t, Vt()), 0 === (48 & ns) && (vs(), qt())
							}
							break;
						case 13:
							var r = Os();
							js((function() {
								return Hs(e, 1, r)
							})), Ia(e, 4)
					}
				}, r.attemptUserBlockingHydration = function(e) {
					13 === e.tag && (Hs(e, 4, Os()), Ia(e, 4))
				}, r.batchedEventUpdates = function(e, t) {
					var n = ns;
					ns |= 2;
					try {
						return e(t)
					} finally {
						0 === (ns = n) && (vs(), qt())
					}
				}, r.batchedUpdates = Ws, r.createComponentSelector = function(e) {
					return {
						$$typeof: Gi,
						value: e
					}
				}, r.createContainer = function(e, t, n) {
					return e = new Ba(e, t, n), t = ba(3, null, null, 2 === t ? 7 : 1 === t ? 3 : 0), e.current = t, t.stateNode = e, fn(t), e
				}, r.createHasPsuedoClassSelector = function(e) {
					return {
						$$typeof: Ui,
						value: e
					}
				}, r.createPortal = function(e, t, n) {
					var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
					return {
						$$typeof: u,
						key: null == r ? null : "" + r,
						children: e,
						containerInfo: t,
						implementation: n
					}
				}, r.createRoleSelector = function(e) {
					return {
						$$typeof: zi,
						value: e
					}
				}, r.createTestNameSelector = function(e) {
					return {
						$$typeof: Vi,
						value: e
					}
				}, r.createTextSelector = function(e) {
					return {
						$$typeof: Wi,
						value: e
					}
				}, r.deferredUpdates = function(e) {
					return Jt(97, e)
				}, r.discreteUpdates = function(e, t, n, r, i) {
					var s = ns;
					ns |= 4;
					try {
						return Jt(98, e.bind(null, t, n, r, i))
					} finally {
						0 === (ns = s) && (vs(), qt())
					}
				}, r.findAllNodes = Yi, r.findBoundingRects = function(e, t) {
					if (!se) throw Error(o(363));
					t = Yi(e, t), e = [];
					for (var n = 0; n < t.length; n++) e.push(oe(t[n]));
					for (t = e.length - 1; 0 < t; t--)
						for (var r = (n = e[t]).x, i = r + n.width, s = n.y, a = s + n.height, l = t - 1; 0 <= l; l--)
							if (t !== l) {
								var c = e[l],
									u = c.x,
									h = u + c.width,
									d = c.y,
									p = d + c.height;
								if (r >= u && s >= d && i <= h && a <= p) {
									e.splice(t, 1);
									break
								}
								if (!(r !== u || n.width !== c.width || p < s || d > a)) {
									d > s && (c.height += d - s, c.y = s), p < a && (c.height = a - d), e.splice(t, 1);
									break
								}
								if (!(s !== d || n.height !== c.height || h < r || u > i)) {
									u > r && (c.width += u - r, c.x = r), h < i && (c.width = i - u), e.splice(t, 1);
									break
								}
							} return e
				}, r.findHostInstance = Ra, r.findHostInstanceWithNoPortals = function(e) {
					return null === (e = function(e) {
						if (!(e = L(e))) return null;
						for (var t = e;;) {
							if (5 === t.tag || 6 === t.tag) return t;
							if (t.child && 4 !== t.tag) t.child.return = t, t = t.child;
							else {
								if (t === e) break;
								for (; !t.sibling;) {
									if (!t.return || t.return === e) return null;
									t = t.return
								}
								t.sibling.return = t.return, t = t.sibling
							}
						}
						return null
					}(e)) ? null : 20 === e.tag ? e.stateNode.instance : e.stateNode
				}, r.findHostInstanceWithWarning = function(e) {
					return Ra(e)
				}, r.flushControlled = function(e) {
					var t = ns;
					ns |= 1;
					try {
						Jt(99, e)
					} finally {
						0 === (ns = t) && (vs(), qt())
					}
				}, r.flushDiscreteUpdates = function() {
					0 === (49 & ns) && (function() {
						if (null !== Cs) {
							var e = Cs;
							Cs = null, e.forEach((function(e) {
								e.expiredLanes |= 24 & e.pendingLanes, Gs(e, Vt())
							}))
						}
						qt()
					}(), sa())
				}, r.flushPassiveEffects = sa, r.flushSync = js, r.focusWithin = function(e, t) {
					if (!se) throw Error(o(363));
					for (t = Ki(e = Ji(e), t), t = Array.from(t), e = 0; e < t.length;) {
						var n = t[e++];
						if (!ce(n)) {
							if (5 === n.tag && he(n.stateNode)) return !0;
							for (n = n.child; null !== n;) t.push(n), n = n.sibling
						}
					}
					return !1
				}, r.getCurrentUpdateLanePriority = function() {
					return pt
				}, r.getFindAllNodesFailureDescription = function(e, t) {
					if (!se) throw Error(o(363));
					var n = 0,
						r = [];
					e = [Ji(e), 0];
					for (var i = 0; i < e.length;) {
						var s = e[i++],
							a = e[i++],
							l = t[a];
						if ((5 !== s.tag || !ce(s)) && (Xi(s, l) && (r.push(qi(l)), ++a > n && (n = a)), a < t.length))
							for (s = s.child; null !== s;) e.push(s, a), s = s.sibling
					}
					if (n < t.length) {
						for (e = []; n < t.length; n++) e.push(qi(t[n]));
						return "findAllNodes was able to match part of the selector:\n  " + r.join(" > ") + "\n\nNo matching component was found for:\n  " + e.join(" > ")
					}
					return null
				}, r.getPublicRootInstance = function(e) {
					if (!(e = e.current).child) return null;
					switch (e.child.tag) {
						case 5:
							return F(e.child.stateNode);
						default:
							return e.child.stateNode
					}
				}, r.injectIntoDevTools = function(e) {
					if (e = {
							bundleType: e.bundleType,
							version: e.version,
							rendererPackageName: e.rendererPackageName,
							rendererConfig: e.rendererConfig,
							overrideHookState: null,
							overrideHookStateDeletePath: null,
							overrideHookStateRenamePath: null,
							overrideProps: null,
							overridePropsDeletePath: null,
							overridePropsRenamePath: null,
							setSuspenseHandler: null,
							scheduleUpdate: null,
							currentDispatcherRef: l.ReactCurrentDispatcher,
							findHostInstanceByFiber: Pa,
							findFiberByHostInstance: e.findFiberByHostInstance || Da,
							findHostInstancesForRefresh: null,
							scheduleRefresh: null,
							scheduleRoot: null,
							setRefreshHandler: null,
							getCurrentFiber: null
						}, "undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) e = !1;
					else {
						var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
						if (!t.isDisabled && t.supportsFiber) try {
							ht = t.inject(e), dt = t
						} catch (n) {}
						e = !0
					}
					return e
				}, r.observeVisibleRects = function(e, t, n, r) {
					if (!se) throw Error(o(363));
					e = Yi(e, t);
					var i = de(e, n, r).disconnect;
					return {
						disconnect: function() {
							i()
						}
					}
				}, r.registerMutableSourceForHydration = function(e, t) {
					var n = t._getVersion;
					n = n(t._source), null == e.mutableSourceEagerHydrationData ? e.mutableSourceEagerHydrationData = [t, n] : e.mutableSourceEagerHydrationData.push(t, n)
				}, r.runWithPriority = function(e, t) {
					var n = pt;
					try {
						return pt = e, t()
					} finally {
						pt = n
					}
				}, r.shouldSuspend = function() {
					return !1
				}, r.unbatchedUpdates = function(e, t) {
					var n = ns;
					ns &= -2, ns |= 8;
					try {
						return e(t)
					} finally {
						0 === (ns = n) && (vs(), qt())
					}
				}, r.updateContainer = function(e, t, n, r) {
					var i = t.current,
						s = Os(),
						a = Ns(i);
					e: if (n) {
						t: {
							if (B(n = n._reactInternals) !== n || 1 !== n.tag) throw Error(o(170));
							var l = n;do {
								switch (l.tag) {
									case 3:
										l = l.stateNode.context;
										break t;
									case 1:
										if (st(l.type)) {
											l = l.stateNode.__reactInternalMemoizedMergedChildContext;
											break t
										}
								}
								l = l.return
							} while (null !== l);
							throw Error(o(171))
						}
						if (1 === n.tag) {
							var c = n.type;
							if (st(c)) {
								n = lt(n, c, l);
								break e
							}
						}
						n = l
					}
					else n = et;
					return null === t.context ? t.context = n : t.pendingContext = n, (t = gn(s, a)).payload = {
						element: e
					}, null !== (r = void 0 === r ? null : r) && (t.callback = r), vn(i, t), Hs(i, a, s), a
				}, r
			}
		},
		6525: function(e, t, n) {
			"use strict";
			e.exports = n(7287)
		},
		6743: function(e, t, n) {
			"use strict";
			n.d(t, {
				Z: function() {
					return h
				}
			});
			var r = n(7462),
				i = n(3366),
				s = n(5068);

			function a(e, t) {
				return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
			}
			var o = n(7294),
				l = n(8885),
				c = function(e, t) {
					return e && t && t.split(" ").forEach((function(t) {
						return r = t, void((n = e).classList ? n.classList.remove(r) : "string" === typeof n.className ? n.className = a(n.className, r) : n.setAttribute("class", a(n.className && n.className.baseVal || "", r)));
						var n, r
					}))
				},
				u = function(e) {
					function t() {
						for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
						return (t = e.call.apply(e, [this].concat(r)) || this).appliedClasses = {
							appear: {},
							enter: {},
							exit: {}
						}, t.onEnter = function(e, n) {
							var r = t.resolveArguments(e, n),
								i = r[0],
								s = r[1];
							t.removeClasses(i, "exit"), t.addClass(i, s ? "appear" : "enter", "base"), t.props.onEnter && t.props.onEnter(e, n)
						}, t.onEntering = function(e, n) {
							var r = t.resolveArguments(e, n),
								i = r[0],
								s = r[1] ? "appear" : "enter";
							t.addClass(i, s, "active"), t.props.onEntering && t.props.onEntering(e, n)
						}, t.onEntered = function(e, n) {
							var r = t.resolveArguments(e, n),
								i = r[0],
								s = r[1] ? "appear" : "enter";
							t.removeClasses(i, s), t.addClass(i, s, "done"), t.props.onEntered && t.props.onEntered(e, n)
						}, t.onExit = function(e) {
							var n = t.resolveArguments(e)[0];
							t.removeClasses(n, "appear"), t.removeClasses(n, "enter"), t.addClass(n, "exit", "base"), t.props.onExit && t.props.onExit(e)
						}, t.onExiting = function(e) {
							var n = t.resolveArguments(e)[0];
							t.addClass(n, "exit", "active"), t.props.onExiting && t.props.onExiting(e)
						}, t.onExited = function(e) {
							var n = t.resolveArguments(e)[0];
							t.removeClasses(n, "exit"), t.addClass(n, "exit", "done"), t.props.onExited && t.props.onExited(e)
						}, t.resolveArguments = function(e, n) {
							return t.props.nodeRef ? [t.props.nodeRef.current, e] : [e, n]
						}, t.getClassNames = function(e) {
							var n = t.props.classNames,
								r = "string" === typeof n,
								i = r ? "" + (r && n ? n + "-" : "") + e : n[e];
							return {
								baseClassName: i,
								activeClassName: r ? i + "-active" : n[e + "Active"],
								doneClassName: r ? i + "-done" : n[e + "Done"]
							}
						}, t
					}(0, s.Z)(t, e);
					var n = t.prototype;
					return n.addClass = function(e, t, n) {
						var r = this.getClassNames(t)[n + "ClassName"],
							i = this.getClassNames("enter").doneClassName;
						"appear" === t && "done" === n && i && (r += " " + i), "active" === n && e && e.scrollTop, r && (this.appliedClasses[t][n] = r, function(e, t) {
							e && t && t.split(" ").forEach((function(t) {
								return r = t, void((n = e).classList ? n.classList.add(r) : function(e, t) {
									return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ")
								}(n, r) || ("string" === typeof n.className ? n.className = n.className + " " + r : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + r)));
								var n, r
							}))
						}(e, r))
					}, n.removeClasses = function(e, t) {
						var n = this.appliedClasses[t],
							r = n.base,
							i = n.active,
							s = n.done;
						this.appliedClasses[t] = {}, r && c(e, r), i && c(e, i), s && c(e, s)
					}, n.render = function() {
						var e = this.props,
							t = (e.classNames, (0, i.Z)(e, ["classNames"]));
						return o.createElement(l.ZP, (0, r.Z)({}, t, {
							onEnter: this.onEnter,
							onEntered: this.onEntered,
							onEntering: this.onEntering,
							onExit: this.onExit,
							onExiting: this.onExiting,
							onExited: this.onExited
						}))
					}, t
				}(o.Component);
			u.defaultProps = {
				classNames: ""
			}, u.propTypes = {};
			var h = u
		},
		8885: function(e, t, n) {
			"use strict";
			n.d(t, {
				ZP: function() {
					return g
				}
			});
			var r = n(3366),
				i = n(5068),
				s = n(7294),
				a = n(3935),
				o = !1,
				l = n(220),
				c = "unmounted",
				u = "exited",
				h = "entering",
				d = "entered",
				p = "exiting",
				f = function(e) {
					function t(t, n) {
						var r;
						r = e.call(this, t, n) || this;
						var i, s = n && !n.isMounting ? t.enter : t.appear;
						return r.appearStatus = null, t.in ? s ? (i = u, r.appearStatus = h) : i = d : i = t.unmountOnExit || t.mountOnEnter ? c : u, r.state = {
							status: i
						}, r.nextCallback = null, r
					}(0, i.Z)(t, e), t.getDerivedStateFromProps = function(e, t) {
						return e.in && t.status === c ? {
							status: u
						} : null
					};
					var n = t.prototype;
					return n.componentDidMount = function() {
						this.updateStatus(!0, this.appearStatus)
					}, n.componentDidUpdate = function(e) {
						var t = null;
						if (e !== this.props) {
							var n = this.state.status;
							this.props.in ? n !== h && n !== d && (t = h) : n !== h && n !== d || (t = p)
						}
						this.updateStatus(!1, t)
					}, n.componentWillUnmount = function() {
						this.cancelNextCallback()
					}, n.getTimeouts = function() {
						var e, t, n, r = this.props.timeout;
						return e = t = n = r, null != r && "number" !== typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), {
							exit: e,
							enter: t,
							appear: n
						}
					}, n.updateStatus = function(e, t) {
						void 0 === e && (e = !1), null !== t ? (this.cancelNextCallback(), t === h ? this.performEnter(e) : this.performExit()) : this.props.unmountOnExit && this.state.status === u && this.setState({
							status: c
						})
					}, n.performEnter = function(e) {
						var t = this,
							n = this.props.enter,
							r = this.context ? this.context.isMounting : e,
							i = this.props.nodeRef ? [r] : [a.findDOMNode(this), r],
							s = i[0],
							l = i[1],
							c = this.getTimeouts(),
							u = r ? c.appear : c.enter;
						!e && !n || o ? this.safeSetState({
							status: d
						}, (function() {
							t.props.onEntered(s)
						})) : (this.props.onEnter(s, l), this.safeSetState({
							status: h
						}, (function() {
							t.props.onEntering(s, l), t.onTransitionEnd(u, (function() {
								t.safeSetState({
									status: d
								}, (function() {
									t.props.onEntered(s, l)
								}))
							}))
						})))
					}, n.performExit = function() {
						var e = this,
							t = this.props.exit,
							n = this.getTimeouts(),
							r = this.props.nodeRef ? void 0 : a.findDOMNode(this);
						t && !o ? (this.props.onExit(r), this.safeSetState({
							status: p
						}, (function() {
							e.props.onExiting(r), e.onTransitionEnd(n.exit, (function() {
								e.safeSetState({
									status: u
								}, (function() {
									e.props.onExited(r)
								}))
							}))
						}))) : this.safeSetState({
							status: u
						}, (function() {
							e.props.onExited(r)
						}))
					}, n.cancelNextCallback = function() {
						null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
					}, n.safeSetState = function(e, t) {
						t = this.setNextCallback(t), this.setState(e, t)
					}, n.setNextCallback = function(e) {
						var t = this,
							n = !0;
						return this.nextCallback = function(r) {
							n && (n = !1, t.nextCallback = null, e(r))
						}, this.nextCallback.cancel = function() {
							n = !1
						}, this.nextCallback
					}, n.onTransitionEnd = function(e, t) {
						this.setNextCallback(t);
						var n = this.props.nodeRef ? this.props.nodeRef.current : a.findDOMNode(this),
							r = null == e && !this.props.addEndListener;
						if (n && !r) {
							if (this.props.addEndListener) {
								var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback],
									s = i[0],
									o = i[1];
								this.props.addEndListener(s, o)
							}
							null != e && setTimeout(this.nextCallback, e)
						} else setTimeout(this.nextCallback, 0)
					}, n.render = function() {
						var e = this.state.status;
						if (e === c) return null;
						var t = this.props,
							n = t.children,
							i = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, (0, r.Z)(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
						return s.createElement(l.Z.Provider, {
							value: null
						}, "function" === typeof n ? n(e, i) : s.cloneElement(s.Children.only(n), i))
					}, t
				}(s.Component);

			function m() {}
			f.contextType = l.Z, f.propTypes = {}, f.defaultProps = {
				in: !1,
				mountOnEnter: !1,
				unmountOnExit: !1,
				appear: !1,
				enter: !0,
				exit: !0,
				onEnter: m,
				onEntering: m,
				onEntered: m,
				onExit: m,
				onExiting: m,
				onExited: m
			}, f.UNMOUNTED = c, f.EXITED = u, f.ENTERING = h, f.ENTERED = d, f.EXITING = p;
			var g = f
		},
		220: function(e, t, n) {
			"use strict";
			var r = n(7294);
			t.Z = r.createContext(null)
		},
		2212: function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, {
				ACESFilmicToneMapping: function() {
					return ne
				},
				AddEquation: function() {
					return S
				},
				AddOperation: function() {
					return Q
				},
				AdditiveAnimationBlendMode: function() {
					return jt
				},
				AdditiveBlending: function() {
					return b
				},
				AlphaFormat: function() {
					return Oe
				},
				AlwaysDepth: function() {
					return z
				},
				AlwaysStencilFunc: function() {
					return vn
				},
				AmbientLight: function() {
					return rd
				},
				AmbientLightProbe: function() {
					return _d
				},
				AnimationClip: function() {
					return Ch
				},
				AnimationLoader: function() {
					return Oh
				},
				AnimationMixer: function() {
					return $d
				},
				AnimationObjectGroup: function() {
					return Qd
				},
				AnimationUtils: function() {
					return mh
				},
				ArcCurve: function() {
					return Kc
				},
				ArrayCamera: function() {
					return yl
				},
				ArrowHelper: function() {
					return zp
				},
				Audio: function() {
					return Id
				},
				AudioAnalyser: function() {
					return Hd
				},
				AudioContext: function() {
					return vd
				},
				AudioListener: function() {
					return Ld
				},
				AudioLoader: function() {
					return yd
				},
				AxesHelper: function() {
					return Vp
				},
				AxisHelper: function() {
					return xf
				},
				BackSide: function() {
					return m
				},
				BasicDepthPacking: function() {
					return Qt
				},
				BasicShadowMap: function() {
					return u
				},
				BinaryTextureLoader: function() {
					return Af
				},
				Bone: function() {
					return ic
				},
				BooleanKeyframeTrack: function() {
					return bh
				},
				BoundingBoxHelper: function() {
					return _f
				},
				Box2: function() {
					return cp
				},
				Box3: function() {
					return or
				},
				Box3Helper: function() {
					return Np
				},
				BoxBufferGeometry: function() {
					return fs
				},
				BoxGeometry: function() {
					return fs
				},
				BoxHelper: function() {
					return Op
				},
				BufferAttribute: function() {
					return Ri
				},
				BufferGeometry: function() {
					return qi
				},
				BufferGeometryLoader: function() {
					return ud
				},
				ByteType: function() {
					return Se
				},
				Cache: function() {
					return Rh
				},
				Camera: function() {
					return xs
				},
				CameraHelper: function() {
					return Pp
				},
				CanvasRenderer: function() {
					return Ef
				},
				CanvasTexture: function() {
					return Oc
				},
				CatmullRomCurve3: function() {
					return tu
				},
				CineonToneMapping: function() {
					return te
				},
				CircleBufferGeometry: function() {
					return Nc
				},
				CircleGeometry: function() {
					return Nc
				},
				ClampToEdgeWrapping: function() {
					return de
				},
				Clock: function() {
					return Sd
				},
				Color: function() {
					return Ei
				},
				ColorKeyframeTrack: function() {
					return wh
				},
				CompressedTexture: function() {
					return Fc
				},
				CompressedTextureLoader: function() {
					return Nh
				},
				ConeBufferGeometry: function() {
					return kc
				},
				ConeGeometry: function() {
					return kc
				},
				CubeCamera: function() {
					return ws
				},
				CubeReflectionMapping: function() {
					return se
				},
				CubeRefractionMapping: function() {
					return ae
				},
				CubeTexture: function() {
					return Ms
				},
				CubeTextureLoader: function() {
					return kh
				},
				CubeUVReflectionMapping: function() {
					return ce
				},
				CubeUVRefractionMapping: function() {
					return ue
				},
				CubicBezierCurve: function() {
					return su
				},
				CubicBezierCurve3: function() {
					return au
				},
				CubicInterpolant: function() {
					return vh
				},
				CullFaceBack: function() {
					return o
				},
				CullFaceFront: function() {
					return l
				},
				CullFaceFrontBack: function() {
					return c
				},
				CullFaceNone: function() {
					return a
				},
				Curve: function() {
					return Xc
				},
				CurvePath: function() {
					return pu
				},
				CustomBlending: function() {
					return A
				},
				CustomToneMapping: function() {
					return re
				},
				CylinderBufferGeometry: function() {
					return Hc
				},
				CylinderGeometry: function() {
					return Hc
				},
				Cylindrical: function() {
					return op
				},
				DataTexture: function() {
					return sc
				},
				DataTexture2DArray: function() {
					return xa
				},
				DataTexture3D: function() {
					return Sa
				},
				DataTextureLoader: function() {
					return Gh
				},
				DataUtils: function() {
					return Xp
				},
				DecrementStencilOp: function() {
					return an
				},
				DecrementWrapStencilOp: function() {
					return ln
				},
				DefaultLoadingManager: function() {
					return Ih
				},
				DepthFormat: function() {
					return Ue
				},
				DepthStencilFormat: function() {
					return ze
				},
				DepthTexture: function() {
					return wl
				},
				DirectionalLight: function() {
					return nd
				},
				DirectionalLightHelper: function() {
					return Rp
				},
				DiscreteInterpolant: function() {
					return xh
				},
				DodecahedronBufferGeometry: function() {
					return Uc
				},
				DodecahedronGeometry: function() {
					return Uc
				},
				DoubleSide: function() {
					return g
				},
				DstAlphaFactor: function() {
					return O
				},
				DstColorFactor: function() {
					return H
				},
				DynamicBufferAttribute: function() {
					return cf
				},
				DynamicCopyUsage: function() {
					return Sn
				},
				DynamicDrawUsage: function() {
					return xn
				},
				DynamicReadUsage: function() {
					return wn
				},
				EdgesGeometry: function() {
					return Jc
				},
				EdgesHelper: function() {
					return bf
				},
				EllipseCurve: function() {
					return qc
				},
				EqualDepth: function() {
					return j
				},
				EqualStencilFunc: function() {
					return dn
				},
				EquirectangularReflectionMapping: function() {
					return oe
				},
				EquirectangularRefractionMapping: function() {
					return le
				},
				Euler: function() {
					return jr
				},
				EventDispatcher: function() {
					return Bn
				},
				ExtrudeBufferGeometry: function() {
					return Wu
				},
				ExtrudeGeometry: function() {
					return Wu
				},
				FaceColors: function() {
					return Qp
				},
				FileLoader: function() {
					return Fh
				},
				FlatShading: function() {
					return v
				},
				Float16BufferAttribute: function() {
					return Hi
				},
				Float32Attribute: function() {
					return vf
				},
				Float32BufferAttribute: function() {
					return ki
				},
				Float64Attribute: function() {
					return yf
				},
				Float64BufferAttribute: function() {
					return Gi
				},
				FloatType: function() {
					return Re
				},
				Fog: function() {
					return Cl
				},
				FogExp2: function() {
					return Tl
				},
				Font: function() {
					return Pf
				},
				FontLoader: function() {
					return If
				},
				FramebufferTexture: function() {
					return Dc
				},
				FrontSide: function() {
					return f
				},
				Frustum: function() {
					return Ls
				},
				GLBufferAttribute: function() {
					return np
				},
				GLSL1: function() {
					return Tn
				},
				GLSL3: function() {
					return Cn
				},
				GreaterDepth: function() {
					return X
				},
				GreaterEqualDepth: function() {
					return J
				},
				GreaterEqualStencilFunc: function() {
					return gn
				},
				GreaterStencilFunc: function() {
					return fn
				},
				GridHelper: function() {
					return Sp
				},
				Group: function() {
					return xl
				},
				HalfFloatType: function() {
					return Le
				},
				HemisphereLight: function() {
					return Vh
				},
				HemisphereLightHelper: function() {
					return Ap
				},
				HemisphereLightProbe: function() {
					return xd
				},
				IcosahedronBufferGeometry: function() {
					return Ju
				},
				IcosahedronGeometry: function() {
					return Ju
				},
				ImageBitmapLoader: function() {
					return md
				},
				ImageLoader: function() {
					return Hh
				},
				ImageUtils: function() {
					return Kn
				},
				ImmediateRenderObject: function() {
					return Df
				},
				IncrementStencilOp: function() {
					return sn
				},
				IncrementWrapStencilOp: function() {
					return on
				},
				InstancedBufferAttribute: function() {
					return cc
				},
				InstancedBufferGeometry: function() {
					return cd
				},
				InstancedInterleavedBuffer: function() {
					return tp
				},
				InstancedMesh: function() {
					return fc
				},
				Int16Attribute: function() {
					return pf
				},
				Int16BufferAttribute: function() {
					return Di
				},
				Int32Attribute: function() {
					return mf
				},
				Int32BufferAttribute: function() {
					return Oi
				},
				Int8Attribute: function() {
					return uf
				},
				Int8BufferAttribute: function() {
					return Li
				},
				IntType: function() {
					return Ce
				},
				InterleavedBuffer: function() {
					return Rl
				},
				InterleavedBufferAttribute: function() {
					return Il
				},
				Interpolant: function() {
					return gh
				},
				InterpolateDiscrete: function() {
					return Ht
				},
				InterpolateLinear: function() {
					return kt
				},
				InterpolateSmooth: function() {
					return Gt
				},
				InvertStencilOp: function() {
					return cn
				},
				JSONLoader: function() {
					return Tf
				},
				KeepStencilOp: function() {
					return nn
				},
				KeyframeTrack: function() {
					return _h
				},
				LOD: function() {
					return Ql
				},
				LatheBufferGeometry: function() {
					return Xu
				},
				LatheGeometry: function() {
					return Xu
				},
				Layers: function() {
					return Jr
				},
				LensFlare: function() {
					return Bf
				},
				LessDepth: function() {
					return V
				},
				LessEqualDepth: function() {
					return W
				},
				LessEqualStencilFunc: function() {
					return pn
				},
				LessStencilFunc: function() {
					return hn
				},
				Light: function() {
					return zh
				},
				LightProbe: function() {
					return ad
				},
				Line: function() {
					return bc
				},
				Line3: function() {
					return dp
				},
				LineBasicMaterial: function() {
					return mc
				},
				LineCurve: function() {
					return ou
				},
				LineCurve3: function() {
					return lu
				},
				LineDashedMaterial: function() {
					return ph
				},
				LineLoop: function() {
					return Sc
				},
				LinePieces: function() {
					return Kp
				},
				LineSegments: function() {
					return Ac
				},
				LineStrip: function() {
					return qp
				},
				LinearEncoding: function() {
					return Kt
				},
				LinearFilter: function() {
					return xe
				},
				LinearInterpolant: function() {
					return yh
				},
				LinearMipMapLinearFilter: function() {
					return Me
				},
				LinearMipMapNearestFilter: function() {
					return be
				},
				LinearMipmapLinearFilter: function() {
					return we
				},
				LinearMipmapNearestFilter: function() {
					return _e
				},
				LinearToneMapping: function() {
					return $
				},
				Loader: function() {
					return Ph
				},
				LoaderUtils: function() {
					return ld
				},
				LoadingManager: function() {
					return Lh
				},
				LoopOnce: function() {
					return Ft
				},
				LoopPingPong: function() {
					return Nt
				},
				LoopRepeat: function() {
					return Ot
				},
				LuminanceAlphaFormat: function() {
					return Ge
				},
				LuminanceFormat: function() {
					return ke
				},
				MOUSE: function() {
					return i
				},
				Material: function() {
					return xi
				},
				MaterialLoader: function() {
					return od
				},
				Math: function() {
					return Un
				},
				MathUtils: function() {
					return Un
				},
				Matrix3: function() {
					return Vn
				},
				Matrix4: function() {
					return Fr
				},
				MaxEquation: function() {
					return B
				},
				Mesh: function() {
					return ds
				},
				MeshBasicMaterial: function() {
					return Ti
				},
				MeshDepthMaterial: function() {
					return dl
				},
				MeshDistanceMaterial: function() {
					return pl
				},
				MeshFaceMaterial: function() {
					return $p
				},
				MeshLambertMaterial: function() {
					return hh
				},
				MeshMatcapMaterial: function() {
					return dh
				},
				MeshNormalMaterial: function() {
					return uh
				},
				MeshPhongMaterial: function() {
					return lh
				},
				MeshPhysicalMaterial: function() {
					return oh
				},
				MeshStandardMaterial: function() {
					return ah
				},
				MeshToonMaterial: function() {
					return ch
				},
				MinEquation: function() {
					return C
				},
				MirroredRepeatWrapping: function() {
					return pe
				},
				MixOperation: function() {
					return Y
				},
				MultiMaterial: function() {
					return ef
				},
				MultiplyBlending: function() {
					return M
				},
				MultiplyOperation: function() {
					return K
				},
				NearestFilter: function() {
					return fe
				},
				NearestMipMapLinearFilter: function() {
					return ye
				},
				NearestMipMapNearestFilter: function() {
					return ge
				},
				NearestMipmapLinearFilter: function() {
					return ve
				},
				NearestMipmapNearestFilter: function() {
					return me
				},
				NeverDepth: function() {
					return U
				},
				NeverStencilFunc: function() {
					return un
				},
				NoBlending: function() {
					return x
				},
				NoColors: function() {
					return Yp
				},
				NoToneMapping: function() {
					return Z
				},
				NormalAnimationBlendMode: function() {
					return Wt
				},
				NormalBlending: function() {
					return _
				},
				NotEqualDepth: function() {
					return q
				},
				NotEqualStencilFunc: function() {
					return mn
				},
				NumberKeyframeTrack: function() {
					return Mh
				},
				Object3D: function() {
					return ai
				},
				ObjectLoader: function() {
					return hd
				},
				ObjectSpaceNormalMap: function() {
					return en
				},
				OctahedronBufferGeometry: function() {
					return qu
				},
				OctahedronGeometry: function() {
					return qu
				},
				OneFactor: function() {
					return L
				},
				OneMinusDstAlphaFactor: function() {
					return N
				},
				OneMinusDstColorFactor: function() {
					return k
				},
				OneMinusSrcAlphaFactor: function() {
					return F
				},
				OneMinusSrcColorFactor: function() {
					return P
				},
				OrthographicCamera: function() {
					return Ws
				},
				PCFShadowMap: function() {
					return h
				},
				PCFSoftShadowMap: function() {
					return d
				},
				PMREMGenerator: function() {
					return aa
				},
				ParametricGeometry: function() {
					return Rf
				},
				Particle: function() {
					return nf
				},
				ParticleBasicMaterial: function() {
					return af
				},
				ParticleSystem: function() {
					return rf
				},
				ParticleSystemMaterial: function() {
					return of
				},
				Path: function() {
					return fu
				},
				PerspectiveCamera: function() {
					return _s
				},
				Plane: function() {
					return Cs
				},
				PlaneBufferGeometry: function() {
					return Ds
				},
				PlaneGeometry: function() {
					return Ds
				},
				PlaneHelper: function() {
					return Hp
				},
				PointCloud: function() {
					return tf
				},
				PointCloudMaterial: function() {
					return sf
				},
				PointLight: function() {
					return ed
				},
				PointLightHelper: function() {
					return _p
				},
				Points: function() {
					return Lc
				},
				PointsMaterial: function() {
					return Ec
				},
				PolarGridHelper: function() {
					return Ep
				},
				PolyhedronBufferGeometry: function() {
					return Gc
				},
				PolyhedronGeometry: function() {
					return Gc
				},
				PositionalAudio: function() {
					return Nd
				},
				PropertyBinding: function() {
					return Yd
				},
				PropertyMixer: function() {
					return kd
				},
				QuadraticBezierCurve: function() {
					return cu
				},
				QuadraticBezierCurve3: function() {
					return uu
				},
				Quaternion: function() {
					return rr
				},
				QuaternionKeyframeTrack: function() {
					return Sh
				},
				QuaternionLinearInterpolant: function() {
					return Ah
				},
				REVISION: function() {
					return r
				},
				RGBADepthPacking: function() {
					return Zt
				},
				RGBAFormat: function() {
					return He
				},
				RGBAIntegerFormat: function() {
					return qe
				},
				RGBA_ASTC_10x10_Format: function() {
					return vt
				},
				RGBA_ASTC_10x5_Format: function() {
					return ft
				},
				RGBA_ASTC_10x6_Format: function() {
					return mt
				},
				RGBA_ASTC_10x8_Format: function() {
					return gt
				},
				RGBA_ASTC_12x10_Format: function() {
					return yt
				},
				RGBA_ASTC_12x12_Format: function() {
					return xt
				},
				RGBA_ASTC_4x4_Format: function() {
					return at
				},
				RGBA_ASTC_5x4_Format: function() {
					return ot
				},
				RGBA_ASTC_5x5_Format: function() {
					return lt
				},
				RGBA_ASTC_6x5_Format: function() {
					return ct
				},
				RGBA_ASTC_6x6_Format: function() {
					return ut
				},
				RGBA_ASTC_8x5_Format: function() {
					return ht
				},
				RGBA_ASTC_8x6_Format: function() {
					return dt
				},
				RGBA_ASTC_8x8_Format: function() {
					return pt
				},
				RGBA_BPTC_Format: function() {
					return _t
				},
				RGBA_ETC2_EAC_Format: function() {
					return st
				},
				RGBA_PVRTC_2BPPV1_Format: function() {
					return nt
				},
				RGBA_PVRTC_4BPPV1_Format: function() {
					return tt
				},
				RGBA_S3TC_DXT1_Format: function() {
					return Ye
				},
				RGBA_S3TC_DXT3_Format: function() {
					return Qe
				},
				RGBA_S3TC_DXT5_Format: function() {
					return Ze
				},
				RGBFormat: function() {
					return Ne
				},
				RGBIntegerFormat: function() {
					return Xe
				},
				RGB_ETC1_Format: function() {
					return rt
				},
				RGB_ETC2_Format: function() {
					return it
				},
				RGB_PVRTC_2BPPV1_Format: function() {
					return et
				},
				RGB_PVRTC_4BPPV1_Format: function() {
					return $e
				},
				RGB_S3TC_DXT1_Format: function() {
					return Ke
				},
				RGFormat: function() {
					return je
				},
				RGIntegerFormat: function() {
					return Je
				},
				RawShaderMaterial: function() {
					return js
				},
				Ray: function() {
					return Dr
				},
				Raycaster: function() {
					return rp
				},
				RectAreaLight: function() {
					return id
				},
				RedFormat: function() {
					return Ve
				},
				RedIntegerFormat: function() {
					return We
				},
				ReinhardToneMapping: function() {
					return ee
				},
				RepeatWrapping: function() {
					return he
				},
				ReplaceStencilOp: function() {
					return rn
				},
				ReverseSubtractEquation: function() {
					return T
				},
				RingBufferGeometry: function() {
					return Ku
				},
				RingGeometry: function() {
					return Ku
				},
				SRGB8_ALPHA8_ASTC_10x10_Format: function() {
					return It
				},
				SRGB8_ALPHA8_ASTC_10x5_Format: function() {
					return Bt
				},
				SRGB8_ALPHA8_ASTC_10x6_Format: function() {
					return Rt
				},
				SRGB8_ALPHA8_ASTC_10x8_Format: function() {
					return Lt
				},
				SRGB8_ALPHA8_ASTC_12x10_Format: function() {
					return Pt
				},
				SRGB8_ALPHA8_ASTC_12x12_Format: function() {
					return Dt
				},
				SRGB8_ALPHA8_ASTC_4x4_Format: function() {
					return bt
				},
				SRGB8_ALPHA8_ASTC_5x4_Format: function() {
					return wt
				},
				SRGB8_ALPHA8_ASTC_5x5_Format: function() {
					return Mt
				},
				SRGB8_ALPHA8_ASTC_6x5_Format: function() {
					return At
				},
				SRGB8_ALPHA8_ASTC_6x6_Format: function() {
					return St
				},
				SRGB8_ALPHA8_ASTC_8x5_Format: function() {
					return Et
				},
				SRGB8_ALPHA8_ASTC_8x6_Format: function() {
					return Tt
				},
				SRGB8_ALPHA8_ASTC_8x8_Format: function() {
					return Ct
				},
				Scene: function() {
					return Bl
				},
				SceneUtils: function() {
					return Cf
				},
				ShaderChunk: function() {
					return Fs
				},
				ShaderLib: function() {
					return Ns
				},
				ShaderMaterial: function() {
					return ys
				},
				ShadowMaterial: function() {
					return sh
				},
				Shape: function() {
					return mu
				},
				ShapeBufferGeometry: function() {
					return Yu
				},
				ShapeGeometry: function() {
					return Yu
				},
				ShapePath: function() {
					return Wp
				},
				ShapeUtils: function() {
					return Uu
				},
				ShortType: function() {
					return Ee
				},
				Skeleton: function() {
					return lc
				},
				SkeletonHelper: function() {
					return yp
				},
				SkinnedMesh: function() {
					return rc
				},
				SmoothShading: function() {
					return y
				},
				Sphere: function() {
					return Er
				},
				SphereBufferGeometry: function() {
					return Qu
				},
				SphereGeometry: function() {
					return Qu
				},
				Spherical: function() {
					return ap
				},
				SphericalHarmonics3: function() {
					return sd
				},
				SplineCurve: function() {
					return hu
				},
				SpotLight: function() {
					return Kh
				},
				SpotLightHelper: function() {
					return fp
				},
				Sprite: function() {
					return Xl
				},
				SpriteMaterial: function() {
					return Pl
				},
				SrcAlphaFactor: function() {
					return D
				},
				SrcAlphaSaturateFactor: function() {
					return G
				},
				SrcColorFactor: function() {
					return I
				},
				StaticCopyUsage: function() {
					return An
				},
				StaticDrawUsage: function() {
					return yn
				},
				StaticReadUsage: function() {
					return bn
				},
				StereoCamera: function() {
					return Ad
				},
				StreamCopyUsage: function() {
					return En
				},
				StreamDrawUsage: function() {
					return _n
				},
				StreamReadUsage: function() {
					return Mn
				},
				StringKeyframeTrack: function() {
					return Eh
				},
				SubtractEquation: function() {
					return E
				},
				SubtractiveBlending: function() {
					return w
				},
				TOUCH: function() {
					return s
				},
				TangentSpaceNormalMap: function() {
					return $t
				},
				TetrahedronBufferGeometry: function() {
					return Zu
				},
				TetrahedronGeometry: function() {
					return Zu
				},
				TextGeometry: function() {
					return Lf
				},
				Texture: function() {
					return Qn
				},
				TextureLoader: function() {
					return Uh
				},
				TorusBufferGeometry: function() {
					return $u
				},
				TorusGeometry: function() {
					return $u
				},
				TorusKnotBufferGeometry: function() {
					return eh
				},
				TorusKnotGeometry: function() {
					return eh
				},
				Triangle: function() {
					return vi
				},
				TriangleFanDrawMode: function() {
					return qt
				},
				TriangleStripDrawMode: function() {
					return Xt
				},
				TrianglesDrawMode: function() {
					return Jt
				},
				TubeBufferGeometry: function() {
					return th
				},
				TubeGeometry: function() {
					return th
				},
				UVMapping: function() {
					return ie
				},
				Uint16Attribute: function() {
					return ff
				},
				Uint16BufferAttribute: function() {
					return Fi
				},
				Uint32Attribute: function() {
					return gf
				},
				Uint32BufferAttribute: function() {
					return Ni
				},
				Uint8Attribute: function() {
					return hf
				},
				Uint8BufferAttribute: function() {
					return Ii
				},
				Uint8ClampedAttribute: function() {
					return df
				},
				Uint8ClampedBufferAttribute: function() {
					return Pi
				},
				Uniform: function() {
					return ep
				},
				UniformsLib: function() {
					return Os
				},
				UniformsUtils: function() {
					return vs
				},
				UnsignedByteType: function() {
					return Ae
				},
				UnsignedInt248Type: function() {
					return Fe
				},
				UnsignedIntType: function() {
					return Be
				},
				UnsignedShort4444Type: function() {
					return Ie
				},
				UnsignedShort5551Type: function() {
					return Pe
				},
				UnsignedShort565Type: function() {
					return De
				},
				UnsignedShortType: function() {
					return Te
				},
				VSMShadowMap: function() {
					return p
				},
				Vector2: function() {
					return zn
				},
				Vector3: function() {
					return ir
				},
				Vector4: function() {
					return $n
				},
				VectorKeyframeTrack: function() {
					return Th
				},
				Vertex: function() {
					return lf
				},
				VertexColors: function() {
					return Zp
				},
				VideoTexture: function() {
					return Pc
				},
				WebGL1Renderer: function() {
					return El
				},
				WebGLCubeRenderTarget: function() {
					return As
				},
				WebGLMultipleRenderTargets: function() {
					return tr
				},
				WebGLMultisampleRenderTarget: function() {
					return nr
				},
				WebGLRenderTarget: function() {
					return er
				},
				WebGLRenderTargetCube: function() {
					return Sf
				},
				WebGLRenderer: function() {
					return Sl
				},
				WebGLUtils: function() {
					return vl
				},
				WireframeGeometry: function() {
					return nh
				},
				WireframeHelper: function() {
					return wf
				},
				WrapAroundEnding: function() {
					return Vt
				},
				XHRLoader: function() {
					return Mf
				},
				ZeroCurvatureEnding: function() {
					return Ut
				},
				ZeroFactor: function() {
					return R
				},
				ZeroSlopeEnding: function() {
					return zt
				},
				ZeroStencilOp: function() {
					return tn
				},
				sRGBEncoding: function() {
					return Yt
				}
			});
			const r = "136",
				i = {
					LEFT: 0,
					MIDDLE: 1,
					RIGHT: 2,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2
				},
				s = {
					ROTATE: 0,
					PAN: 1,
					DOLLY_PAN: 2,
					DOLLY_ROTATE: 3
				},
				a = 0,
				o = 1,
				l = 2,
				c = 3,
				u = 0,
				h = 1,
				d = 2,
				p = 3,
				f = 0,
				m = 1,
				g = 2,
				v = 1,
				y = 2,
				x = 0,
				_ = 1,
				b = 2,
				w = 3,
				M = 4,
				A = 5,
				S = 100,
				E = 101,
				T = 102,
				C = 103,
				B = 104,
				R = 200,
				L = 201,
				I = 202,
				P = 203,
				D = 204,
				F = 205,
				O = 206,
				N = 207,
				H = 208,
				k = 209,
				G = 210,
				U = 0,
				z = 1,
				V = 2,
				W = 3,
				j = 4,
				J = 5,
				X = 6,
				q = 7,
				K = 0,
				Y = 1,
				Q = 2,
				Z = 0,
				$ = 1,
				ee = 2,
				te = 3,
				ne = 4,
				re = 5,
				ie = 300,
				se = 301,
				ae = 302,
				oe = 303,
				le = 304,
				ce = 306,
				ue = 307,
				he = 1e3,
				de = 1001,
				pe = 1002,
				fe = 1003,
				me = 1004,
				ge = 1004,
				ve = 1005,
				ye = 1005,
				xe = 1006,
				_e = 1007,
				be = 1007,
				we = 1008,
				Me = 1008,
				Ae = 1009,
				Se = 1010,
				Ee = 1011,
				Te = 1012,
				Ce = 1013,
				Be = 1014,
				Re = 1015,
				Le = 1016,
				Ie = 1017,
				Pe = 1018,
				De = 1019,
				Fe = 1020,
				Oe = 1021,
				Ne = 1022,
				He = 1023,
				ke = 1024,
				Ge = 1025,
				Ue = 1026,
				ze = 1027,
				Ve = 1028,
				We = 1029,
				je = 1030,
				Je = 1031,
				Xe = 1032,
				qe = 1033,
				Ke = 33776,
				Ye = 33777,
				Qe = 33778,
				Ze = 33779,
				$e = 35840,
				et = 35841,
				tt = 35842,
				nt = 35843,
				rt = 36196,
				it = 37492,
				st = 37496,
				at = 37808,
				ot = 37809,
				lt = 37810,
				ct = 37811,
				ut = 37812,
				ht = 37813,
				dt = 37814,
				pt = 37815,
				ft = 37816,
				mt = 37817,
				gt = 37818,
				vt = 37819,
				yt = 37820,
				xt = 37821,
				_t = 36492,
				bt = 37840,
				wt = 37841,
				Mt = 37842,
				At = 37843,
				St = 37844,
				Et = 37845,
				Tt = 37846,
				Ct = 37847,
				Bt = 37848,
				Rt = 37849,
				Lt = 37850,
				It = 37851,
				Pt = 37852,
				Dt = 37853,
				Ft = 2200,
				Ot = 2201,
				Nt = 2202,
				Ht = 2300,
				kt = 2301,
				Gt = 2302,
				Ut = 2400,
				zt = 2401,
				Vt = 2402,
				Wt = 2500,
				jt = 2501,
				Jt = 0,
				Xt = 1,
				qt = 2,
				Kt = 3e3,
				Yt = 3001,
				Qt = 3200,
				Zt = 3201,
				$t = 0,
				en = 1,
				tn = 0,
				nn = 7680,
				rn = 7681,
				sn = 7682,
				an = 7683,
				on = 34055,
				ln = 34056,
				cn = 5386,
				un = 512,
				hn = 513,
				dn = 514,
				pn = 515,
				fn = 516,
				mn = 517,
				gn = 518,
				vn = 519,
				yn = 35044,
				xn = 35048,
				_n = 35040,
				bn = 35045,
				wn = 35049,
				Mn = 35041,
				An = 35046,
				Sn = 35050,
				En = 35042,
				Tn = "100",
				Cn = "300 es";
			class Bn {
				addEventListener(e, t) {
					void 0 === this._listeners && (this._listeners = {});
					const n = this._listeners;
					void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
				}
				hasEventListener(e, t) {
					if (void 0 === this._listeners) return !1;
					const n = this._listeners;
					return void 0 !== n[e] && -1 !== n[e].indexOf(t)
				}
				removeEventListener(e, t) {
					if (void 0 === this._listeners) return;
					const n = this._listeners[e];
					if (void 0 !== n) {
						const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
					}
				}
				dispatchEvent(e) {
					if (void 0 === this._listeners) return;
					const t = this._listeners[e.type];
					if (void 0 !== t) {
						e.target = this;
						const n = t.slice(0);
						for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
						e.target = null
					}
				}
			}
			const Rn = [];
			for (let Ff = 0; Ff < 256; Ff++) Rn[Ff] = (Ff < 16 ? "0" : "") + Ff.toString(16);
			let Ln = 1234567;
			const In = Math.PI / 180,
				Pn = 180 / Math.PI;

			function Dn() {
				const e = 4294967295 * Math.random() | 0,
					t = 4294967295 * Math.random() | 0,
					n = 4294967295 * Math.random() | 0,
					r = 4294967295 * Math.random() | 0;
				return (Rn[255 & e] + Rn[e >> 8 & 255] + Rn[e >> 16 & 255] + Rn[e >> 24 & 255] + "-" + Rn[255 & t] + Rn[t >> 8 & 255] + "-" + Rn[t >> 16 & 15 | 64] + Rn[t >> 24 & 255] + "-" + Rn[63 & n | 128] + Rn[n >> 8 & 255] + "-" + Rn[n >> 16 & 255] + Rn[n >> 24 & 255] + Rn[255 & r] + Rn[r >> 8 & 255] + Rn[r >> 16 & 255] + Rn[r >> 24 & 255]).toUpperCase()
			}

			function Fn(e, t, n) {
				return Math.max(t, Math.min(n, e))
			}

			function On(e, t) {
				return (e % t + t) % t
			}

			function Nn(e, t, n) {
				return (1 - n) * e + n * t
			}

			function Hn(e) {
				return 0 === (e & e - 1) && 0 !== e
			}

			function kn(e) {
				return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
			}

			function Gn(e) {
				return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
			}
			var Un = Object.freeze({
				__proto__: null,
				DEG2RAD: In,
				RAD2DEG: Pn,
				generateUUID: Dn,
				clamp: Fn,
				euclideanModulo: On,
				mapLinear: function(e, t, n, r, i) {
					return r + (e - t) * (i - r) / (n - t)
				},
				inverseLerp: function(e, t, n) {
					return e !== t ? (n - e) / (t - e) : 0
				},
				lerp: Nn,
				damp: function(e, t, n, r) {
					return Nn(e, t, 1 - Math.exp(-n * r))
				},
				pingpong: function(e, t = 1) {
					return t - Math.abs(On(e, 2 * t) - t)
				},
				smoothstep: function(e, t, n) {
					return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
				},
				smootherstep: function(e, t, n) {
					return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
				},
				randInt: function(e, t) {
					return e + Math.floor(Math.random() * (t - e + 1))
				},
				randFloat: function(e, t) {
					return e + Math.random() * (t - e)
				},
				randFloatSpread: function(e) {
					return e * (.5 - Math.random())
				},
				seededRandom: function(e) {
					return void 0 !== e && (Ln = e % 2147483647), Ln = 16807 * Ln % 2147483647, (Ln - 1) / 2147483646
				},
				degToRad: function(e) {
					return e * In
				},
				radToDeg: function(e) {
					return e * Pn
				},
				isPowerOfTwo: Hn,
				ceilPowerOfTwo: kn,
				floorPowerOfTwo: Gn,
				setQuaternionFromProperEuler: function(e, t, n, r, i) {
					const s = Math.cos,
						a = Math.sin,
						o = s(n / 2),
						l = a(n / 2),
						c = s((t + r) / 2),
						u = a((t + r) / 2),
						h = s((t - r) / 2),
						d = a((t - r) / 2),
						p = s((r - t) / 2),
						f = a((r - t) / 2);
					switch (i) {
						case "XYX":
							e.set(o * u, l * h, l * d, o * c);
							break;
						case "YZY":
							e.set(l * d, o * u, l * h, o * c);
							break;
						case "ZXZ":
							e.set(l * h, l * d, o * u, o * c);
							break;
						case "XZX":
							e.set(o * u, l * f, l * p, o * c);
							break;
						case "YXY":
							e.set(l * p, o * u, l * f, o * c);
							break;
						case "ZYZ":
							e.set(l * f, l * p, o * u, o * c);
							break;
						default:
							console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
					}
				}
			});
			class zn {
				constructor(e = 0, t = 0) {
					this.x = e, this.y = t
				}
				get width() {
					return this.x
				}
				set width(e) {
					this.x = e
				}
				get height() {
					return this.y
				}
				set height(e) {
					this.y = e
				}
				set(e, t) {
					return this.x = e, this.y = t, this
				}
				setScalar(e) {
					return this.x = e, this.y = e, this
				}
				setX(e) {
					return this.x = e, this
				}
				setY(e) {
					return this.y = e, this
				}
				setComponent(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				}
				getComponent(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error("index is out of range: " + e)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y)
				}
				copy(e) {
					return this.x = e.x, this.y = e.y, this
				}
				add(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
				}
				addScalar(e) {
					return this.x += e, this.y += e, this
				}
				addVectors(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this
				}
				addScaledVector(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this
				}
				sub(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
				}
				subScalar(e) {
					return this.x -= e, this.y -= e, this
				}
				subVectors(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this
				}
				multiply(e) {
					return this.x *= e.x, this.y *= e.y, this
				}
				multiplyScalar(e) {
					return this.x *= e, this.y *= e, this
				}
				divide(e) {
					return this.x /= e.x, this.y /= e.y, this
				}
				divideScalar(e) {
					return this.multiplyScalar(1 / e)
				}
				applyMatrix3(e) {
					const t = this.x,
						n = this.y,
						r = e.elements;
					return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
				}
				min(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
				}
				max(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
				}
				clamp(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
				}
				clampScalar(e, t) {
					return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
				}
				clampLength(e, t) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this
				}
				dot(e) {
					return this.x * e.x + this.y * e.y
				}
				cross(e) {
					return this.x * e.y - this.y * e.x
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				angle() {
					return Math.atan2(-this.y, -this.x) + Math.PI
				}
				distanceTo(e) {
					return Math.sqrt(this.distanceToSquared(e))
				}
				distanceToSquared(e) {
					const t = this.x - e.x,
						n = this.y - e.y;
					return t * t + n * n
				}
				manhattanDistanceTo(e) {
					return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
				}
				setLength(e) {
					return this.normalize().multiplyScalar(e)
				}
				lerp(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
				}
				lerpVectors(e, t, n) {
					return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
				}
				equals(e) {
					return e.x === this.x && e.y === this.y
				}
				fromArray(e, t = 0) {
					return this.x = e[t], this.y = e[t + 1], this
				}
				toArray(e = [], t = 0) {
					return e[t] = this.x, e[t + 1] = this.y, e
				}
				fromBufferAttribute(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
				}
				rotateAround(e, t) {
					const n = Math.cos(t),
						r = Math.sin(t),
						i = this.x - e.x,
						s = this.y - e.y;
					return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y
				}
			}
			zn.prototype.isVector2 = !0;
			class Vn {
				constructor() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				set(e, t, n, r, i, s, a, o, l) {
					const c = this.elements;
					return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = i, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
				}
				identity() {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
				}
				copy(e) {
					const t = this.elements,
						n = e.elements;
					return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
				}
				extractBasis(e, t, n) {
					return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
				}
				setFromMatrix4(e) {
					const t = e.elements;
					return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
				}
				multiply(e) {
					return this.multiplyMatrices(this, e)
				}
				premultiply(e) {
					return this.multiplyMatrices(e, this)
				}
				multiplyMatrices(e, t) {
					const n = e.elements,
						r = t.elements,
						i = this.elements,
						s = n[0],
						a = n[3],
						o = n[6],
						l = n[1],
						c = n[4],
						u = n[7],
						h = n[2],
						d = n[5],
						p = n[8],
						f = r[0],
						m = r[3],
						g = r[6],
						v = r[1],
						y = r[4],
						x = r[7],
						_ = r[2],
						b = r[5],
						w = r[8];
					return i[0] = s * f + a * v + o * _, i[3] = s * m + a * y + o * b, i[6] = s * g + a * x + o * w, i[1] = l * f + c * v + u * _, i[4] = l * m + c * y + u * b, i[7] = l * g + c * x + u * w, i[2] = h * f + d * v + p * _, i[5] = h * m + d * y + p * b, i[8] = h * g + d * x + p * w, this
				}
				multiplyScalar(e) {
					const t = this.elements;
					return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
				}
				determinant() {
					const e = this.elements,
						t = e[0],
						n = e[1],
						r = e[2],
						i = e[3],
						s = e[4],
						a = e[5],
						o = e[6],
						l = e[7],
						c = e[8];
					return t * s * c - t * a * l - n * i * c + n * a * o + r * i * l - r * s * o
				}
				invert() {
					const e = this.elements,
						t = e[0],
						n = e[1],
						r = e[2],
						i = e[3],
						s = e[4],
						a = e[5],
						o = e[6],
						l = e[7],
						c = e[8],
						u = c * s - a * l,
						h = a * o - c * i,
						d = l * i - s * o,
						p = t * u + n * h + r * d;
					if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
					const f = 1 / p;
					return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (a * n - r * s) * f, e[3] = h * f, e[4] = (c * t - r * o) * f, e[5] = (r * i - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * i) * f, this
				}
				transpose() {
					let e;
					const t = this.elements;
					return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
				}
				getNormalMatrix(e) {
					return this.setFromMatrix4(e).invert().transpose()
				}
				transposeIntoArray(e) {
					const t = this.elements;
					return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
				}
				setUvTransform(e, t, n, r, i, s, a) {
					const o = Math.cos(i),
						l = Math.sin(i);
					return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -r * l, r * o, -r * (-l * s + o * a) + a + t, 0, 0, 1), this
				}
				scale(e, t) {
					const n = this.elements;
					return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
				}
				rotate(e) {
					const t = Math.cos(e),
						n = Math.sin(e),
						r = this.elements,
						i = r[0],
						s = r[3],
						a = r[6],
						o = r[1],
						l = r[4],
						c = r[7];
					return r[0] = t * i + n * o, r[3] = t * s + n * l, r[6] = t * a + n * c, r[1] = -n * i + t * o, r[4] = -n * s + t * l, r[7] = -n * a + t * c, this
				}
				translate(e, t) {
					const n = this.elements;
					return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
				}
				equals(e) {
					const t = this.elements,
						n = e.elements;
					for (let r = 0; r < 9; r++)
						if (t[r] !== n[r]) return !1;
					return !0
				}
				fromArray(e, t = 0) {
					for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
					return this
				}
				toArray(e = [], t = 0) {
					const n = this.elements;
					return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
				}
				clone() {
					return (new this.constructor).fromArray(this.elements)
				}
			}

			function Wn(e) {
				if (0 === e.length) return -1 / 0;
				let t = e[0];
				for (let n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
				return t
			}
			Vn.prototype.isMatrix3 = !0;
			const jn = {
				Int8Array: Int8Array,
				Uint8Array: Uint8Array,
				Uint8ClampedArray: Uint8ClampedArray,
				Int16Array: Int16Array,
				Uint16Array: Uint16Array,
				Int32Array: Int32Array,
				Uint32Array: Uint32Array,
				Float32Array: Float32Array,
				Float64Array: Float64Array
			};

			function Jn(e, t) {
				return new jn[e](t)
			}

			function Xn(e) {
				return document.createElementNS("http://www.w3.org/1999/xhtml", e)
			}
			let qn;
			class Kn {
				static getDataURL(e) {
					if (/^data:/i.test(e.src)) return e.src;
					if ("undefined" == typeof HTMLCanvasElement) return e.src;
					let t;
					if (e instanceof HTMLCanvasElement) t = e;
					else {
						void 0 === qn && (qn = Xn("canvas")), qn.width = e.width, qn.height = e.height;
						const n = qn.getContext("2d");
						e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = qn
					}
					return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
				}
			}
			let Yn = 0;
			class Qn extends Bn {
				constructor(e = Qn.DEFAULT_IMAGE, t = Qn.DEFAULT_MAPPING, n = de, r = de, i = xe, s = we, a = He, o = Ae, l = 1, c = Kt) {
					super(), Object.defineProperty(this, "id", {
						value: Yn++
					}), this.uuid = Dn(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new zn(0, 0), this.repeat = new zn(1, 1), this.center = new zn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Vn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
				}
				updateMatrix() {
					this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this
				}
				toJSON(e) {
					const t = void 0 === e || "string" === typeof e;
					if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
					const n = {
						metadata: {
							version: 4.5,
							type: "Texture",
							generator: "Texture.toJSON"
						},
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						center: [this.center.x, this.center.y],
						rotation: this.rotation,
						wrap: [this.wrapS, this.wrapT],
						format: this.format,
						type: this.type,
						encoding: this.encoding,
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY,
						premultiplyAlpha: this.premultiplyAlpha,
						unpackAlignment: this.unpackAlignment
					};
					if (void 0 !== this.image) {
						const r = this.image;
						if (void 0 === r.uuid && (r.uuid = Dn()), !t && void 0 === e.images[r.uuid]) {
							let t;
							if (Array.isArray(r)) {
								t = [];
								for (let e = 0, n = r.length; e < n; e++) r[e].isDataTexture ? t.push(Zn(r[e].image)) : t.push(Zn(r[e]))
							} else t = Zn(r);
							e.images[r.uuid] = {
								uuid: r.uuid,
								url: t
							}
						}
						n.image = r.uuid
					}
					return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
				transformUv(e) {
					if (this.mapping !== ie) return e;
					if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
						case he:
							e.x = e.x - Math.floor(e.x);
							break;
						case de:
							e.x = e.x < 0 ? 0 : 1;
							break;
						case pe:
							1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
					}
					if (e.y < 0 || e.y > 1) switch (this.wrapT) {
						case he:
							e.y = e.y - Math.floor(e.y);
							break;
						case de:
							e.y = e.y < 0 ? 0 : 1;
							break;
						case pe:
							1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
					}
					return this.flipY && (e.y = 1 - e.y), e
				}
				set needsUpdate(e) {
					!0 === e && this.version++
				}
			}

			function Zn(e) {
				return "undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap ? Kn.getDataURL(e) : e.data ? {
					data: Array.prototype.slice.call(e.data),
					width: e.width,
					height: e.height,
					type: e.data.constructor.name
				} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
			}
			Qn.DEFAULT_IMAGE = void 0, Qn.DEFAULT_MAPPING = ie, Qn.prototype.isTexture = !0;
			class $n {
				constructor(e = 0, t = 0, n = 0, r = 1) {
					this.x = e, this.y = t, this.z = n, this.w = r
				}
				get width() {
					return this.z
				}
				set width(e) {
					this.z = e
				}
				get height() {
					return this.w
				}
				set height(e) {
					this.w = e
				}
				set(e, t, n, r) {
					return this.x = e, this.y = t, this.z = n, this.w = r, this
				}
				setScalar(e) {
					return this.x = e, this.y = e, this.z = e, this.w = e, this
				}
				setX(e) {
					return this.x = e, this
				}
				setY(e) {
					return this.y = e, this
				}
				setZ(e) {
					return this.z = e, this
				}
				setW(e) {
					return this.w = e, this
				}
				setComponent(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						case 2:
							this.z = t;
							break;
						case 3:
							this.w = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				}
				getComponent(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						case 3:
							return this.w;
						default:
							throw new Error("index is out of range: " + e)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z, this.w)
				}
				copy(e) {
					return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
				}
				add(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
				}
				addScalar(e) {
					return this.x += e, this.y += e, this.z += e, this.w += e, this
				}
				addVectors(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
				}
				addScaledVector(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
				}
				sub(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
				}
				subScalar(e) {
					return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
				}
				subVectors(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
				}
				multiply(e) {
					return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
				}
				multiplyScalar(e) {
					return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
				}
				applyMatrix4(e) {
					const t = this.x,
						n = this.y,
						r = this.z,
						i = this.w,
						s = e.elements;
					return this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i, this
				}
				divideScalar(e) {
					return this.multiplyScalar(1 / e)
				}
				setAxisAngleFromQuaternion(e) {
					this.w = 2 * Math.acos(e.w);
					const t = Math.sqrt(1 - e.w * e.w);
					return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
				}
				setAxisAngleFromRotationMatrix(e) {
					let t, n, r, i;
					const s = .01,
						a = .1,
						o = e.elements,
						l = o[0],
						c = o[4],
						u = o[8],
						h = o[1],
						d = o[5],
						p = o[9],
						f = o[2],
						m = o[6],
						g = o[10];
					if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
						if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
						t = Math.PI;
						const e = (l + 1) / 2,
							o = (d + 1) / 2,
							v = (g + 1) / 2,
							y = (c + h) / 4,
							x = (u + f) / 4,
							_ = (p + m) / 4;
						return e > o && e > v ? e < s ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(e), r = y / n, i = x / n) : o > v ? o < s ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(o), n = y / r, i = _ / r) : v < s ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = x / i, r = _ / i), this.set(n, r, i, t), this
					}
					let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
					return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
				}
				min(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
				}
				max(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
				}
				clamp(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
				}
				clampScalar(e, t) {
					return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
				}
				clampLength(e, t) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
				}
				dot(e) {
					return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(e) {
					return this.normalize().multiplyScalar(e)
				}
				lerp(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
				}
				lerpVectors(e, t, n) {
					return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
				}
				equals(e) {
					return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
				}
				fromArray(e, t = 0) {
					return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
				}
				toArray(e = [], t = 0) {
					return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
				}
				fromBufferAttribute(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y, yield this.z, yield this.w
				}
			}
			$n.prototype.isVector4 = !0;
			class er extends Bn {
				constructor(e, t, n = {}) {
					super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new $n(0, 0, e, t), this.scissorTest = !1, this.viewport = new $n(0, 0, e, t), this.texture = new Qn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
						width: e,
						height: t,
						depth: 1
					}, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : xe, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
				}
				setTexture(e) {
					e.image = {
						width: this.width,
						height: this.height,
						depth: this.depth
					}, this.texture = e
				}
				setSize(e, t, n = 1) {
					this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = {
						...this.texture.image
					}, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			er.prototype.isWebGLRenderTarget = !0;
			class tr extends er {
				constructor(e, t, n) {
					super(e, t);
					const r = this.texture;
					this.texture = [];
					for (let i = 0; i < n; i++) this.texture[i] = r.clone()
				}
				setSize(e, t, n = 1) {
					if (this.width !== e || this.height !== t || this.depth !== n) {
						this.width = e, this.height = t, this.depth = n;
						for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
						this.dispose()
					}
					return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
				}
				copy(e) {
					this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
					for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone();
					return this
				}
			}
			tr.prototype.isWebGLMultipleRenderTargets = !0;
			class nr extends er {
				constructor(e, t, n = {}) {
					super(e, t, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
				}
				copy(e) {
					return super.copy.call(this, e), this.samples = e.samples, this.useRenderToTexture = e.useRenderToTexture, this.useRenderbuffer = e.useRenderbuffer, this
				}
			}
			nr.prototype.isWebGLMultisampleRenderTarget = !0;
			class rr {
				constructor(e = 0, t = 0, n = 0, r = 1) {
					this._x = e, this._y = t, this._z = n, this._w = r
				}
				static slerp(e, t, n, r) {
					return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, r)
				}
				static slerpFlat(e, t, n, r, i, s, a) {
					let o = n[r + 0],
						l = n[r + 1],
						c = n[r + 2],
						u = n[r + 3];
					const h = i[s + 0],
						d = i[s + 1],
						p = i[s + 2],
						f = i[s + 3];
					if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
					if (1 === a) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = f);
					if (u !== f || o !== h || l !== d || c !== p) {
						let e = 1 - a;
						const t = o * h + l * d + c * p + u * f,
							n = t >= 0 ? 1 : -1,
							r = 1 - t * t;
						if (r > Number.EPSILON) {
							const i = Math.sqrt(r),
								s = Math.atan2(i, t * n);
							e = Math.sin(e * s) / i, a = Math.sin(a * s) / i
						}
						const i = a * n;
						if (o = o * e + h * i, l = l * e + d * i, c = c * e + p * i, u = u * e + f * i, e === 1 - a) {
							const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
							o *= e, l *= e, c *= e, u *= e
						}
					}
					e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
				}
				static multiplyQuaternionsFlat(e, t, n, r, i, s) {
					const a = n[r],
						o = n[r + 1],
						l = n[r + 2],
						c = n[r + 3],
						u = i[s],
						h = i[s + 1],
						d = i[s + 2],
						p = i[s + 3];
					return e[t] = a * p + c * u + o * d - l * h, e[t + 1] = o * p + c * h + l * u - a * d, e[t + 2] = l * p + c * d + a * h - o * u, e[t + 3] = c * p - a * u - o * h - l * d, e
				}
				get x() {
					return this._x
				}
				set x(e) {
					this._x = e, this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(e) {
					this._y = e, this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(e) {
					this._z = e, this._onChangeCallback()
				}
				get w() {
					return this._w
				}
				set w(e) {
					this._w = e, this._onChangeCallback()
				}
				set(e, t, n, r) {
					return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._w)
				}
				copy(e) {
					return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
				}
				setFromEuler(e, t) {
					if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
					const n = e._x,
						r = e._y,
						i = e._z,
						s = e._order,
						a = Math.cos,
						o = Math.sin,
						l = a(n / 2),
						c = a(r / 2),
						u = a(i / 2),
						h = o(n / 2),
						d = o(r / 2),
						p = o(i / 2);
					switch (s) {
						case "XYZ":
							this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
							break;
						case "YXZ":
							this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
							break;
						case "ZXY":
							this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
							break;
						case "ZYX":
							this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
							break;
						case "YZX":
							this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
							break;
						case "XZY":
							this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p;
							break;
						default:
							console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
					}
					return !1 !== t && this._onChangeCallback(), this
				}
				setFromAxisAngle(e, t) {
					const n = t / 2,
						r = Math.sin(n);
					return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
				}
				setFromRotationMatrix(e) {
					const t = e.elements,
						n = t[0],
						r = t[4],
						i = t[8],
						s = t[1],
						a = t[5],
						o = t[9],
						l = t[2],
						c = t[6],
						u = t[10],
						h = n + a + u;
					if (h > 0) {
						const e = .5 / Math.sqrt(h + 1);
						this._w = .25 / e, this._x = (c - o) * e, this._y = (i - l) * e, this._z = (s - r) * e
					} else if (n > a && n > u) {
						const e = 2 * Math.sqrt(1 + n - a - u);
						this._w = (c - o) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (i + l) / e
					} else if (a > u) {
						const e = 2 * Math.sqrt(1 + a - n - u);
						this._w = (i - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (o + c) / e
					} else {
						const e = 2 * Math.sqrt(1 + u - n - a);
						this._w = (s - r) / e, this._x = (i + l) / e, this._y = (o + c) / e, this._z = .25 * e
					}
					return this._onChangeCallback(), this
				}
				setFromUnitVectors(e, t) {
					let n = e.dot(t) + 1;
					return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
				}
				angleTo(e) {
					return 2 * Math.acos(Math.abs(Fn(this.dot(e), -1, 1)))
				}
				rotateTowards(e, t) {
					const n = this.angleTo(e);
					if (0 === n) return this;
					const r = Math.min(1, t / n);
					return this.slerp(e, r), this
				}
				identity() {
					return this.set(0, 0, 0, 1)
				}
				invert() {
					return this.conjugate()
				}
				conjugate() {
					return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
				}
				dot(e) {
					return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
				}
				lengthSq() {
					return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
				}
				length() {
					return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
				}
				normalize() {
					let e = this.length();
					return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
				}
				multiply(e, t) {
					return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
				}
				premultiply(e) {
					return this.multiplyQuaternions(e, this)
				}
				multiplyQuaternions(e, t) {
					const n = e._x,
						r = e._y,
						i = e._z,
						s = e._w,
						a = t._x,
						o = t._y,
						l = t._z,
						c = t._w;
					return this._x = n * c + s * a + r * l - i * o, this._y = r * c + s * o + i * a - n * l, this._z = i * c + s * l + n * o - r * a, this._w = s * c - n * a - r * o - i * l, this._onChangeCallback(), this
				}
				slerp(e, t) {
					if (0 === t) return this;
					if (1 === t) return this.copy(e);
					const n = this._x,
						r = this._y,
						i = this._z,
						s = this._w;
					let a = s * e._w + n * e._x + r * e._y + i * e._z;
					if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
					const o = 1 - a * a;
					if (o <= Number.EPSILON) {
						const e = 1 - t;
						return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this
					}
					const l = Math.sqrt(o),
						c = Math.atan2(l, a),
						u = Math.sin((1 - t) * c) / l,
						h = Math.sin(t * c) / l;
					return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this
				}
				slerpQuaternions(e, t, n) {
					this.copy(e).slerp(t, n)
				}
				random() {
					const e = Math.random(),
						t = Math.sqrt(1 - e),
						n = Math.sqrt(e),
						r = 2 * Math.PI * Math.random(),
						i = 2 * Math.PI * Math.random();
					return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
				}
				equals(e) {
					return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
				}
				fromArray(e, t = 0) {
					return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
				}
				toArray(e = [], t = 0) {
					return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
				}
				fromBufferAttribute(e, t) {
					return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
				}
				_onChange(e) {
					return this._onChangeCallback = e, this
				}
				_onChangeCallback() {}
			}
			rr.prototype.isQuaternion = !0;
			class ir {
				constructor(e = 0, t = 0, n = 0) {
					this.x = e, this.y = t, this.z = n
				}
				set(e, t, n) {
					return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
				}
				setScalar(e) {
					return this.x = e, this.y = e, this.z = e, this
				}
				setX(e) {
					return this.x = e, this
				}
				setY(e) {
					return this.y = e, this
				}
				setZ(e) {
					return this.z = e, this
				}
				setComponent(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						case 2:
							this.z = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				}
				getComponent(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						default:
							throw new Error("index is out of range: " + e)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z)
				}
				copy(e) {
					return this.x = e.x, this.y = e.y, this.z = e.z, this
				}
				add(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
				}
				addScalar(e) {
					return this.x += e, this.y += e, this.z += e, this
				}
				addVectors(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
				}
				addScaledVector(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
				}
				sub(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
				}
				subScalar(e) {
					return this.x -= e, this.y -= e, this.z -= e, this
				}
				subVectors(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
				}
				multiply(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
				}
				multiplyScalar(e) {
					return this.x *= e, this.y *= e, this.z *= e, this
				}
				multiplyVectors(e, t) {
					return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
				}
				applyEuler(e) {
					return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ar.setFromEuler(e))
				}
				applyAxisAngle(e, t) {
					return this.applyQuaternion(ar.setFromAxisAngle(e, t))
				}
				applyMatrix3(e) {
					const t = this.x,
						n = this.y,
						r = this.z,
						i = e.elements;
					return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
				}
				applyNormalMatrix(e) {
					return this.applyMatrix3(e).normalize()
				}
				applyMatrix4(e) {
					const t = this.x,
						n = this.y,
						r = this.z,
						i = e.elements,
						s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
					return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s, this
				}
				applyQuaternion(e) {
					const t = this.x,
						n = this.y,
						r = this.z,
						i = e.x,
						s = e.y,
						a = e.z,
						o = e.w,
						l = o * t + s * r - a * n,
						c = o * n + a * t - i * r,
						u = o * r + i * n - s * t,
						h = -i * t - s * n - a * r;
					return this.x = l * o + h * -i + c * -a - u * -s, this.y = c * o + h * -s + u * -i - l * -a, this.z = u * o + h * -a + l * -s - c * -i, this
				}
				project(e) {
					return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
				}
				unproject(e) {
					return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
				}
				transformDirection(e) {
					const t = this.x,
						n = this.y,
						r = this.z,
						i = e.elements;
					return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
				}
				divide(e) {
					return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
				}
				divideScalar(e) {
					return this.multiplyScalar(1 / e)
				}
				min(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
				}
				max(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
				}
				clamp(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
				}
				clampScalar(e, t) {
					return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
				}
				clampLength(e, t) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
				}
				dot(e) {
					return this.x * e.x + this.y * e.y + this.z * e.z
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(e) {
					return this.normalize().multiplyScalar(e)
				}
				lerp(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
				}
				lerpVectors(e, t, n) {
					return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
				}
				cross(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
				}
				crossVectors(e, t) {
					const n = e.x,
						r = e.y,
						i = e.z,
						s = t.x,
						a = t.y,
						o = t.z;
					return this.x = r * o - i * a, this.y = i * s - n * o, this.z = n * a - r * s, this
				}
				projectOnVector(e) {
					const t = e.lengthSq();
					if (0 === t) return this.set(0, 0, 0);
					const n = e.dot(this) / t;
					return this.copy(e).multiplyScalar(n)
				}
				projectOnPlane(e) {
					return sr.copy(this).projectOnVector(e), this.sub(sr)
				}
				reflect(e) {
					return this.sub(sr.copy(e).multiplyScalar(2 * this.dot(e)))
				}
				angleTo(e) {
					const t = Math.sqrt(this.lengthSq() * e.lengthSq());
					if (0 === t) return Math.PI / 2;
					const n = this.dot(e) / t;
					return Math.acos(Fn(n, -1, 1))
				}
				distanceTo(e) {
					return Math.sqrt(this.distanceToSquared(e))
				}
				distanceToSquared(e) {
					const t = this.x - e.x,
						n = this.y - e.y,
						r = this.z - e.z;
					return t * t + n * n + r * r
				}
				manhattanDistanceTo(e) {
					return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
				}
				setFromSpherical(e) {
					return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
				}
				setFromSphericalCoords(e, t, n) {
					const r = Math.sin(t) * e;
					return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
				}
				setFromCylindrical(e) {
					return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
				}
				setFromCylindricalCoords(e, t, n) {
					return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
				}
				setFromMatrixPosition(e) {
					const t = e.elements;
					return this.x = t[12], this.y = t[13], this.z = t[14], this
				}
				setFromMatrixScale(e) {
					const t = this.setFromMatrixColumn(e, 0).length(),
						n = this.setFromMatrixColumn(e, 1).length(),
						r = this.setFromMatrixColumn(e, 2).length();
					return this.x = t, this.y = n, this.z = r, this
				}
				setFromMatrixColumn(e, t) {
					return this.fromArray(e.elements, 4 * t)
				}
				setFromMatrix3Column(e, t) {
					return this.fromArray(e.elements, 3 * t)
				}
				equals(e) {
					return e.x === this.x && e.y === this.y && e.z === this.z
				}
				fromArray(e, t = 0) {
					return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
				}
				toArray(e = [], t = 0) {
					return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
				}
				fromBufferAttribute(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
				}
				randomDirection() {
					const e = 2 * (Math.random() - .5),
						t = Math.random() * Math.PI * 2,
						n = Math.sqrt(1 - e ** 2);
					return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y, yield this.z
				}
			}
			ir.prototype.isVector3 = !0;
			const sr = new ir,
				ar = new rr;
			class or {
				constructor(e = new ir(1 / 0, 1 / 0, 1 / 0), t = new ir(-1 / 0, -1 / 0, -1 / 0)) {
					this.min = e, this.max = t
				}
				set(e, t) {
					return this.min.copy(e), this.max.copy(t), this
				}
				setFromArray(e) {
					let t = 1 / 0,
						n = 1 / 0,
						r = 1 / 0,
						i = -1 / 0,
						s = -1 / 0,
						a = -1 / 0;
					for (let o = 0, l = e.length; o < l; o += 3) {
						const l = e[o],
							c = e[o + 1],
							u = e[o + 2];
						l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > a && (a = u)
					}
					return this.min.set(t, n, r), this.max.set(i, s, a), this
				}
				setFromBufferAttribute(e) {
					let t = 1 / 0,
						n = 1 / 0,
						r = 1 / 0,
						i = -1 / 0,
						s = -1 / 0,
						a = -1 / 0;
					for (let o = 0, l = e.count; o < l; o++) {
						const l = e.getX(o),
							c = e.getY(o),
							u = e.getZ(o);
						l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > a && (a = u)
					}
					return this.min.set(t, n, r), this.max.set(i, s, a), this
				}
				setFromPoints(e) {
					this.makeEmpty();
					for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
					return this
				}
				setFromCenterAndSize(e, t) {
					const n = cr.copy(t).multiplyScalar(.5);
					return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
				}
				setFromObject(e) {
					return this.makeEmpty(), this.expandByObject(e)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.min.copy(e.min), this.max.copy(e.max), this
				}
				makeEmpty() {
					return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
				}
				getCenter(e) {
					return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
				}
				getSize(e) {
					return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
				}
				expandByPoint(e) {
					return this.min.min(e), this.max.max(e), this
				}
				expandByVector(e) {
					return this.min.sub(e), this.max.add(e), this
				}
				expandByScalar(e) {
					return this.min.addScalar(-e), this.max.addScalar(e), this
				}
				expandByObject(e) {
					e.updateWorldMatrix(!1, !1);
					const t = e.geometry;
					void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), ur.copy(t.boundingBox), ur.applyMatrix4(e.matrixWorld), this.union(ur));
					const n = e.children;
					for (let r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
					return this
				}
				containsPoint(e) {
					return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
				}
				containsBox(e) {
					return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
				}
				getParameter(e, t) {
					return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
				}
				intersectsBox(e) {
					return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
				}
				intersectsSphere(e) {
					return this.clampPoint(e.center, cr), cr.distanceToSquared(e.center) <= e.radius * e.radius
				}
				intersectsPlane(e) {
					let t, n;
					return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
				}
				intersectsTriangle(e) {
					if (this.isEmpty()) return !1;
					this.getCenter(vr), yr.subVectors(this.max, vr), hr.subVectors(e.a, vr), dr.subVectors(e.b, vr), pr.subVectors(e.c, vr), fr.subVectors(dr, hr), mr.subVectors(pr, dr), gr.subVectors(hr, pr);
					let t = [0, -fr.z, fr.y, 0, -mr.z, mr.y, 0, -gr.z, gr.y, fr.z, 0, -fr.x, mr.z, 0, -mr.x, gr.z, 0, -gr.x, -fr.y, fr.x, 0, -mr.y, mr.x, 0, -gr.y, gr.x, 0];
					return !!br(t, hr, dr, pr, yr) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!br(t, hr, dr, pr, yr) && (xr.crossVectors(fr, mr), t = [xr.x, xr.y, xr.z], br(t, hr, dr, pr, yr)))
				}
				clampPoint(e, t) {
					return t.copy(e).clamp(this.min, this.max)
				}
				distanceToPoint(e) {
					return cr.copy(e).clamp(this.min, this.max).sub(e).length()
				}
				getBoundingSphere(e) {
					return this.getCenter(e.center), e.radius = .5 * this.getSize(cr).length(), e
				}
				intersect(e) {
					return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
				}
				union(e) {
					return this.min.min(e.min), this.max.max(e.max), this
				}
				applyMatrix4(e) {
					return this.isEmpty() || (lr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), lr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), lr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), lr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), lr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), lr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), lr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), lr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(lr)), this
				}
				translate(e) {
					return this.min.add(e), this.max.add(e), this
				}
				equals(e) {
					return e.min.equals(this.min) && e.max.equals(this.max)
				}
			}
			or.prototype.isBox3 = !0;
			const lr = [new ir, new ir, new ir, new ir, new ir, new ir, new ir, new ir],
				cr = new ir,
				ur = new or,
				hr = new ir,
				dr = new ir,
				pr = new ir,
				fr = new ir,
				mr = new ir,
				gr = new ir,
				vr = new ir,
				yr = new ir,
				xr = new ir,
				_r = new ir;

			function br(e, t, n, r, i) {
				for (let s = 0, a = e.length - 3; s <= a; s += 3) {
					_r.fromArray(e, s);
					const a = i.x * Math.abs(_r.x) + i.y * Math.abs(_r.y) + i.z * Math.abs(_r.z),
						o = t.dot(_r),
						l = n.dot(_r),
						c = r.dot(_r);
					if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
				}
				return !0
			}
			const wr = new or,
				Mr = new ir,
				Ar = new ir,
				Sr = new ir;
			class Er {
				constructor(e = new ir, t = -1) {
					this.center = e, this.radius = t
				}
				set(e, t) {
					return this.center.copy(e), this.radius = t, this
				}
				setFromPoints(e, t) {
					const n = this.center;
					void 0 !== t ? n.copy(t) : wr.setFromPoints(e).getCenter(n);
					let r = 0;
					for (let i = 0, s = e.length; i < s; i++) r = Math.max(r, n.distanceToSquared(e[i]));
					return this.radius = Math.sqrt(r), this
				}
				copy(e) {
					return this.center.copy(e.center), this.radius = e.radius, this
				}
				isEmpty() {
					return this.radius < 0
				}
				makeEmpty() {
					return this.center.set(0, 0, 0), this.radius = -1, this
				}
				containsPoint(e) {
					return e.distanceToSquared(this.center) <= this.radius * this.radius
				}
				distanceToPoint(e) {
					return e.distanceTo(this.center) - this.radius
				}
				intersectsSphere(e) {
					const t = this.radius + e.radius;
					return e.center.distanceToSquared(this.center) <= t * t
				}
				intersectsBox(e) {
					return e.intersectsSphere(this)
				}
				intersectsPlane(e) {
					return Math.abs(e.distanceToPoint(this.center)) <= this.radius
				}
				clampPoint(e, t) {
					const n = this.center.distanceToSquared(e);
					return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
				}
				getBoundingBox(e) {
					return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
				}
				applyMatrix4(e) {
					return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
				}
				translate(e) {
					return this.center.add(e), this
				}
				expandByPoint(e) {
					Sr.subVectors(e, this.center);
					const t = Sr.lengthSq();
					if (t > this.radius * this.radius) {
						const e = Math.sqrt(t),
							n = .5 * (e - this.radius);
						this.center.add(Sr.multiplyScalar(n / e)), this.radius += n
					}
					return this
				}
				union(e) {
					return !0 === this.center.equals(e.center) ? Ar.set(0, 0, 1).multiplyScalar(e.radius) : Ar.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Mr.copy(e.center).add(Ar)), this.expandByPoint(Mr.copy(e.center).sub(Ar)), this
				}
				equals(e) {
					return e.center.equals(this.center) && e.radius === this.radius
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			const Tr = new ir,
				Cr = new ir,
				Br = new ir,
				Rr = new ir,
				Lr = new ir,
				Ir = new ir,
				Pr = new ir;
			class Dr {
				constructor(e = new ir, t = new ir(0, 0, -1)) {
					this.origin = e, this.direction = t
				}
				set(e, t) {
					return this.origin.copy(e), this.direction.copy(t), this
				}
				copy(e) {
					return this.origin.copy(e.origin), this.direction.copy(e.direction), this
				}
				at(e, t) {
					return t.copy(this.direction).multiplyScalar(e).add(this.origin)
				}
				lookAt(e) {
					return this.direction.copy(e).sub(this.origin).normalize(), this
				}
				recast(e) {
					return this.origin.copy(this.at(e, Tr)), this
				}
				closestPointToPoint(e, t) {
					t.subVectors(e, this.origin);
					const n = t.dot(this.direction);
					return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
				}
				distanceToPoint(e) {
					return Math.sqrt(this.distanceSqToPoint(e))
				}
				distanceSqToPoint(e) {
					const t = Tr.subVectors(e, this.origin).dot(this.direction);
					return t < 0 ? this.origin.distanceToSquared(e) : (Tr.copy(this.direction).multiplyScalar(t).add(this.origin), Tr.distanceToSquared(e))
				}
				distanceSqToSegment(e, t, n, r) {
					Cr.copy(e).add(t).multiplyScalar(.5), Br.copy(t).sub(e).normalize(), Rr.copy(this.origin).sub(Cr);
					const i = .5 * e.distanceTo(t),
						s = -this.direction.dot(Br),
						a = Rr.dot(this.direction),
						o = -Rr.dot(Br),
						l = Rr.lengthSq(),
						c = Math.abs(1 - s * s);
					let u, h, d, p;
					if (c > 0)
						if (u = s * o - a, h = s * a - o, p = i * c, u >= 0)
							if (h >= -p)
								if (h <= p) {
									const e = 1 / c;
									u *= e, h *= e, d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l
								} else h = i, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
					else h = -i, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
					else h <= -p ? (u = Math.max(0, -(-s * i + a)), h = u > 0 ? -i : Math.min(Math.max(-i, -o), i), d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-i, -o), i), d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * i + a)), h = u > 0 ? i : Math.min(Math.max(-i, -o), i), d = -u * u + h * (h + 2 * o) + l);
					else h = s > 0 ? -i : i, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
					return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Br).multiplyScalar(h).add(Cr), d
				}
				intersectSphere(e, t) {
					Tr.subVectors(e.center, this.origin);
					const n = Tr.dot(this.direction),
						r = Tr.dot(Tr) - n * n,
						i = e.radius * e.radius;
					if (r > i) return null;
					const s = Math.sqrt(i - r),
						a = n - s,
						o = n + s;
					return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
				}
				intersectsSphere(e) {
					return this.distanceSqToPoint(e.center) <= e.radius * e.radius
				}
				distanceToPlane(e) {
					const t = e.normal.dot(this.direction);
					if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
					const n = -(this.origin.dot(e.normal) + e.constant) / t;
					return n >= 0 ? n : null
				}
				intersectPlane(e, t) {
					const n = this.distanceToPlane(e);
					return null === n ? null : this.at(n, t)
				}
				intersectsPlane(e) {
					const t = e.distanceToPoint(this.origin);
					if (0 === t) return !0;
					return e.normal.dot(this.direction) * t < 0
				}
				intersectBox(e, t) {
					let n, r, i, s, a, o;
					const l = 1 / this.direction.x,
						c = 1 / this.direction.y,
						u = 1 / this.direction.z,
						h = this.origin;
					return l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), c >= 0 ? (i = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), n > s || i > r ? null : ((i > n || n !== n) && (n = i), (s < r || r !== r) && (r = s), u >= 0 ? (a = (e.min.z - h.z) * u, o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, o = (e.min.z - h.z) * u), n > o || a > r ? null : ((a > n || n !== n) && (n = a), (o < r || r !== r) && (r = o), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
				}
				intersectsBox(e) {
					return null !== this.intersectBox(e, Tr)
				}
				intersectTriangle(e, t, n, r, i) {
					Lr.subVectors(t, e), Ir.subVectors(n, e), Pr.crossVectors(Lr, Ir);
					let s, a = this.direction.dot(Pr);
					if (a > 0) {
						if (r) return null;
						s = 1
					} else {
						if (!(a < 0)) return null;
						s = -1, a = -a
					}
					Rr.subVectors(this.origin, e);
					const o = s * this.direction.dot(Ir.crossVectors(Rr, Ir));
					if (o < 0) return null;
					const l = s * this.direction.dot(Lr.cross(Rr));
					if (l < 0) return null;
					if (o + l > a) return null;
					const c = -s * Rr.dot(Pr);
					return c < 0 ? null : this.at(c / a, i)
				}
				applyMatrix4(e) {
					return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
				}
				equals(e) {
					return e.origin.equals(this.origin) && e.direction.equals(this.direction)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			class Fr {
				constructor() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}
				set(e, t, n, r, i, s, a, o, l, c, u, h, d, p, f, m) {
					const g = this.elements;
					return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
				}
				identity() {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				clone() {
					return (new Fr).fromArray(this.elements)
				}
				copy(e) {
					const t = this.elements,
						n = e.elements;
					return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
				}
				copyPosition(e) {
					const t = this.elements,
						n = e.elements;
					return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
				}
				setFromMatrix3(e) {
					const t = e.elements;
					return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
				}
				extractBasis(e, t, n) {
					return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
				}
				makeBasis(e, t, n) {
					return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
				}
				extractRotation(e) {
					const t = this.elements,
						n = e.elements,
						r = 1 / Or.setFromMatrixColumn(e, 0).length(),
						i = 1 / Or.setFromMatrixColumn(e, 1).length(),
						s = 1 / Or.setFromMatrixColumn(e, 2).length();
					return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
				}
				makeRotationFromEuler(e) {
					e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
					const t = this.elements,
						n = e.x,
						r = e.y,
						i = e.z,
						s = Math.cos(n),
						a = Math.sin(n),
						o = Math.cos(r),
						l = Math.sin(r),
						c = Math.cos(i),
						u = Math.sin(i);
					if ("XYZ" === e.order) {
						const e = s * c,
							n = s * u,
							r = a * c,
							i = a * u;
						t[0] = o * c, t[4] = -o * u, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -a * o, t[2] = i - e * l, t[6] = r + n * l, t[10] = s * o
					} else if ("YXZ" === e.order) {
						const e = o * c,
							n = o * u,
							r = l * c,
							i = l * u;
						t[0] = e + i * a, t[4] = r * a - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -a, t[2] = n * a - r, t[6] = i + e * a, t[10] = s * o
					} else if ("ZXY" === e.order) {
						const e = o * c,
							n = o * u,
							r = l * c,
							i = l * u;
						t[0] = e - i * a, t[4] = -s * u, t[8] = r + n * a, t[1] = n + r * a, t[5] = s * c, t[9] = i - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
					} else if ("ZYX" === e.order) {
						const e = s * c,
							n = s * u,
							r = a * c,
							i = a * u;
						t[0] = o * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = o * u, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = a * o, t[10] = s * o
					} else if ("YZX" === e.order) {
						const e = s * o,
							n = s * l,
							r = a * o,
							i = a * l;
						t[0] = o * c, t[4] = i - e * u, t[8] = r * u + n, t[1] = u, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * u + r, t[10] = e - i * u
					} else if ("XZY" === e.order) {
						const e = s * o,
							n = s * l,
							r = a * o,
							i = a * l;
						t[0] = o * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = s * c, t[9] = n * u - r, t[2] = r * u - n, t[6] = a * c, t[10] = i * u + e
					}
					return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
				}
				makeRotationFromQuaternion(e) {
					return this.compose(Hr, e, kr)
				}
				lookAt(e, t, n) {
					const r = this.elements;
					return zr.subVectors(e, t), 0 === zr.lengthSq() && (zr.z = 1), zr.normalize(), Gr.crossVectors(n, zr), 0 === Gr.lengthSq() && (1 === Math.abs(n.z) ? zr.x += 1e-4 : zr.z += 1e-4, zr.normalize(), Gr.crossVectors(n, zr)), Gr.normalize(), Ur.crossVectors(zr, Gr), r[0] = Gr.x, r[4] = Ur.x, r[8] = zr.x, r[1] = Gr.y, r[5] = Ur.y, r[9] = zr.y, r[2] = Gr.z, r[6] = Ur.z, r[10] = zr.z, this
				}
				multiply(e, t) {
					return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
				}
				premultiply(e) {
					return this.multiplyMatrices(e, this)
				}
				multiplyMatrices(e, t) {
					const n = e.elements,
						r = t.elements,
						i = this.elements,
						s = n[0],
						a = n[4],
						o = n[8],
						l = n[12],
						c = n[1],
						u = n[5],
						h = n[9],
						d = n[13],
						p = n[2],
						f = n[6],
						m = n[10],
						g = n[14],
						v = n[3],
						y = n[7],
						x = n[11],
						_ = n[15],
						b = r[0],
						w = r[4],
						M = r[8],
						A = r[12],
						S = r[1],
						E = r[5],
						T = r[9],
						C = r[13],
						B = r[2],
						R = r[6],
						L = r[10],
						I = r[14],
						P = r[3],
						D = r[7],
						F = r[11],
						O = r[15];
					return i[0] = s * b + a * S + o * B + l * P, i[4] = s * w + a * E + o * R + l * D, i[8] = s * M + a * T + o * L + l * F, i[12] = s * A + a * C + o * I + l * O, i[1] = c * b + u * S + h * B + d * P, i[5] = c * w + u * E + h * R + d * D, i[9] = c * M + u * T + h * L + d * F, i[13] = c * A + u * C + h * I + d * O, i[2] = p * b + f * S + m * B + g * P, i[6] = p * w + f * E + m * R + g * D, i[10] = p * M + f * T + m * L + g * F, i[14] = p * A + f * C + m * I + g * O, i[3] = v * b + y * S + x * B + _ * P, i[7] = v * w + y * E + x * R + _ * D, i[11] = v * M + y * T + x * L + _ * F, i[15] = v * A + y * C + x * I + _ * O, this
				}
				multiplyScalar(e) {
					const t = this.elements;
					return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
				}
				determinant() {
					const e = this.elements,
						t = e[0],
						n = e[4],
						r = e[8],
						i = e[12],
						s = e[1],
						a = e[5],
						o = e[9],
						l = e[13],
						c = e[2],
						u = e[6],
						h = e[10],
						d = e[14];
					return e[3] * (+i * o * u - r * l * u - i * a * h + n * l * h + r * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + i * s * h - r * s * d + r * l * c - i * o * c) + e[11] * (+t * l * u - t * a * d - i * s * u + n * s * d + i * a * c - n * l * c) + e[15] * (-r * a * c - t * o * u + t * a * h + r * s * u - n * s * h + n * o * c)
				}
				transpose() {
					const e = this.elements;
					let t;
					return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
				}
				setPosition(e, t, n) {
					const r = this.elements;
					return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
				}
				invert() {
					const e = this.elements,
						t = e[0],
						n = e[1],
						r = e[2],
						i = e[3],
						s = e[4],
						a = e[5],
						o = e[6],
						l = e[7],
						c = e[8],
						u = e[9],
						h = e[10],
						d = e[11],
						p = e[12],
						f = e[13],
						m = e[14],
						g = e[15],
						v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g,
						y = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g,
						x = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g,
						_ = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m,
						b = t * v + n * y + r * x + i * _;
					if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
					const w = 1 / b;
					return e[0] = v * w, e[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * w, e[2] = (a * m * i - f * o * i + f * r * l - n * m * l - a * r * g + n * o * g) * w, e[3] = (u * o * i - a * h * i - u * r * l + n * h * l + a * r * d - n * o * d) * w, e[4] = y * w, e[5] = (c * m * i - p * h * i + p * r * d - t * m * d - c * r * g + t * h * g) * w, e[6] = (p * o * i - s * m * i - p * r * l + t * m * l + s * r * g - t * o * g) * w, e[7] = (s * h * i - c * o * i + c * r * l - t * h * l - s * r * d + t * o * d) * w, e[8] = x * w, e[9] = (p * u * i - c * f * i - p * n * d + t * f * d + c * n * g - t * u * g) * w, e[10] = (s * f * i - p * a * i + p * n * l - t * f * l - s * n * g + t * a * g) * w, e[11] = (c * a * i - s * u * i - c * n * l + t * u * l + s * n * d - t * a * d) * w, e[12] = _ * w, e[13] = (c * f * r - p * u * r + p * n * h - t * f * h - c * n * m + t * u * m) * w, e[14] = (p * a * r - s * f * r - p * n * o + t * f * o + s * n * m - t * a * m) * w, e[15] = (s * u * r - c * a * r + c * n * o - t * u * o - s * n * h + t * a * h) * w, this
				}
				scale(e) {
					const t = this.elements,
						n = e.x,
						r = e.y,
						i = e.z;
					return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
				}
				getMaxScaleOnAxis() {
					const e = this.elements,
						t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
						n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
						r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
					return Math.sqrt(Math.max(t, n, r))
				}
				makeTranslation(e, t, n) {
					return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
				}
				makeRotationX(e) {
					const t = Math.cos(e),
						n = Math.sin(e);
					return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
				}
				makeRotationY(e) {
					const t = Math.cos(e),
						n = Math.sin(e);
					return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
				}
				makeRotationZ(e) {
					const t = Math.cos(e),
						n = Math.sin(e);
					return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				makeRotationAxis(e, t) {
					const n = Math.cos(t),
						r = Math.sin(t),
						i = 1 - n,
						s = e.x,
						a = e.y,
						o = e.z,
						l = i * s,
						c = i * a;
					return this.set(l * s + n, l * a - r * o, l * o + r * a, 0, l * a + r * o, c * a + n, c * o - r * s, 0, l * o - r * a, c * o + r * s, i * o * o + n, 0, 0, 0, 0, 1), this
				}
				makeScale(e, t, n) {
					return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
				}
				makeShear(e, t, n, r, i, s) {
					return this.set(1, n, i, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this
				}
				compose(e, t, n) {
					const r = this.elements,
						i = t._x,
						s = t._y,
						a = t._z,
						o = t._w,
						l = i + i,
						c = s + s,
						u = a + a,
						h = i * l,
						d = i * c,
						p = i * u,
						f = s * c,
						m = s * u,
						g = a * u,
						v = o * l,
						y = o * c,
						x = o * u,
						_ = n.x,
						b = n.y,
						w = n.z;
					return r[0] = (1 - (f + g)) * _, r[1] = (d + x) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - x) * b, r[5] = (1 - (h + g)) * b, r[6] = (m + v) * b, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - v) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
				}
				decompose(e, t, n) {
					const r = this.elements;
					let i = Or.set(r[0], r[1], r[2]).length();
					const s = Or.set(r[4], r[5], r[6]).length(),
						a = Or.set(r[8], r[9], r[10]).length();
					this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], Nr.copy(this);
					const o = 1 / i,
						l = 1 / s,
						c = 1 / a;
					return Nr.elements[0] *= o, Nr.elements[1] *= o, Nr.elements[2] *= o, Nr.elements[4] *= l, Nr.elements[5] *= l, Nr.elements[6] *= l, Nr.elements[8] *= c, Nr.elements[9] *= c, Nr.elements[10] *= c, t.setFromRotationMatrix(Nr), n.x = i, n.y = s, n.z = a, this
				}
				makePerspective(e, t, n, r, i, s) {
					void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
					const a = this.elements,
						o = 2 * i / (t - e),
						l = 2 * i / (n - r),
						c = (t + e) / (t - e),
						u = (n + r) / (n - r),
						h = -(s + i) / (s - i),
						d = -2 * s * i / (s - i);
					return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
				}
				makeOrthographic(e, t, n, r, i, s) {
					const a = this.elements,
						o = 1 / (t - e),
						l = 1 / (n - r),
						c = 1 / (s - i),
						u = (t + e) * o,
						h = (n + r) * l,
						d = (s + i) * c;
					return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
				}
				equals(e) {
					const t = this.elements,
						n = e.elements;
					for (let r = 0; r < 16; r++)
						if (t[r] !== n[r]) return !1;
					return !0
				}
				fromArray(e, t = 0) {
					for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
					return this
				}
				toArray(e = [], t = 0) {
					const n = this.elements;
					return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
				}
			}
			Fr.prototype.isMatrix4 = !0;
			const Or = new ir,
				Nr = new Fr,
				Hr = new ir(0, 0, 0),
				kr = new ir(1, 1, 1),
				Gr = new ir,
				Ur = new ir,
				zr = new ir,
				Vr = new Fr,
				Wr = new rr;
			class jr {
				constructor(e = 0, t = 0, n = 0, r = jr.DefaultOrder) {
					this._x = e, this._y = t, this._z = n, this._order = r
				}
				get x() {
					return this._x
				}
				set x(e) {
					this._x = e, this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(e) {
					this._y = e, this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(e) {
					this._z = e, this._onChangeCallback()
				}
				get order() {
					return this._order
				}
				set order(e) {
					this._order = e, this._onChangeCallback()
				}
				set(e, t, n, r = this._order) {
					return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._order)
				}
				copy(e) {
					return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
				}
				setFromRotationMatrix(e, t = this._order, n = !0) {
					const r = e.elements,
						i = r[0],
						s = r[4],
						a = r[8],
						o = r[1],
						l = r[5],
						c = r[9],
						u = r[2],
						h = r[6],
						d = r[10];
					switch (t) {
						case "XYZ":
							this._y = Math.asin(Fn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(h, l), this._z = 0);
							break;
						case "YXZ":
							this._x = Math.asin(-Fn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
							break;
						case "ZXY":
							this._x = Math.asin(Fn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, i));
							break;
						case "ZYX":
							this._y = Math.asin(-Fn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
							break;
						case "YZX":
							this._z = Math.asin(Fn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(a, d));
							break;
						case "XZY":
							this._z = Math.asin(-Fn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-c, d), this._y = 0);
							break;
						default:
							console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
					}
					return this._order = t, !0 === n && this._onChangeCallback(), this
				}
				setFromQuaternion(e, t, n) {
					return Vr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Vr, t, n)
				}
				setFromVector3(e, t = this._order) {
					return this.set(e.x, e.y, e.z, t)
				}
				reorder(e) {
					return Wr.setFromEuler(this), this.setFromQuaternion(Wr, e)
				}
				equals(e) {
					return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
				}
				fromArray(e) {
					return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
				}
				toArray(e = [], t = 0) {
					return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
				}
				toVector3(e) {
					return e ? e.set(this._x, this._y, this._z) : new ir(this._x, this._y, this._z)
				}
				_onChange(e) {
					return this._onChangeCallback = e, this
				}
				_onChangeCallback() {}
			}
			jr.prototype.isEuler = !0, jr.DefaultOrder = "XYZ", jr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
			class Jr {
				constructor() {
					this.mask = 1
				}
				set(e) {
					this.mask = (1 << e | 0) >>> 0
				}
				enable(e) {
					this.mask |= 1 << e | 0
				}
				enableAll() {
					this.mask = -1
				}
				toggle(e) {
					this.mask ^= 1 << e | 0
				}
				disable(e) {
					this.mask &= ~(1 << e | 0)
				}
				disableAll() {
					this.mask = 0
				}
				test(e) {
					return 0 !== (this.mask & e.mask)
				}
				isEnabled(e) {
					return 0 !== (this.mask & (1 << e | 0))
				}
			}
			let Xr = 0;
			const qr = new ir,
				Kr = new rr,
				Yr = new Fr,
				Qr = new ir,
				Zr = new ir,
				$r = new ir,
				ei = new rr,
				ti = new ir(1, 0, 0),
				ni = new ir(0, 1, 0),
				ri = new ir(0, 0, 1),
				ii = {
					type: "added"
				},
				si = {
					type: "removed"
				};
			class ai extends Bn {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: Xr++
					}), this.uuid = Dn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ai.DefaultUp.clone();
					const e = new ir,
						t = new jr,
						n = new rr,
						r = new ir(1, 1, 1);
					t._onChange((function() {
						n.setFromEuler(t, !1)
					})), n._onChange((function() {
						t.setFromQuaternion(n, void 0, !1)
					})), Object.defineProperties(this, {
						position: {
							configurable: !0,
							enumerable: !0,
							value: e
						},
						rotation: {
							configurable: !0,
							enumerable: !0,
							value: t
						},
						quaternion: {
							configurable: !0,
							enumerable: !0,
							value: n
						},
						scale: {
							configurable: !0,
							enumerable: !0,
							value: r
						},
						modelViewMatrix: {
							value: new Fr
						},
						normalMatrix: {
							value: new Vn
						}
					}), this.matrix = new Fr, this.matrixWorld = new Fr, this.matrixAutoUpdate = ai.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Jr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
				}
				onBeforeRender() {}
				onAfterRender() {}
				applyMatrix4(e) {
					this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
				}
				applyQuaternion(e) {
					return this.quaternion.premultiply(e), this
				}
				setRotationFromAxisAngle(e, t) {
					this.quaternion.setFromAxisAngle(e, t)
				}
				setRotationFromEuler(e) {
					this.quaternion.setFromEuler(e, !0)
				}
				setRotationFromMatrix(e) {
					this.quaternion.setFromRotationMatrix(e)
				}
				setRotationFromQuaternion(e) {
					this.quaternion.copy(e)
				}
				rotateOnAxis(e, t) {
					return Kr.setFromAxisAngle(e, t), this.quaternion.multiply(Kr), this
				}
				rotateOnWorldAxis(e, t) {
					return Kr.setFromAxisAngle(e, t), this.quaternion.premultiply(Kr), this
				}
				rotateX(e) {
					return this.rotateOnAxis(ti, e)
				}
				rotateY(e) {
					return this.rotateOnAxis(ni, e)
				}
				rotateZ(e) {
					return this.rotateOnAxis(ri, e)
				}
				translateOnAxis(e, t) {
					return qr.copy(e).applyQuaternion(this.quaternion), this.position.add(qr.multiplyScalar(t)), this
				}
				translateX(e) {
					return this.translateOnAxis(ti, e)
				}
				translateY(e) {
					return this.translateOnAxis(ni, e)
				}
				translateZ(e) {
					return this.translateOnAxis(ri, e)
				}
				localToWorld(e) {
					return e.applyMatrix4(this.matrixWorld)
				}
				worldToLocal(e) {
					return e.applyMatrix4(Yr.copy(this.matrixWorld).invert())
				}
				lookAt(e, t, n) {
					e.isVector3 ? Qr.copy(e) : Qr.set(e, t, n);
					const r = this.parent;
					this.updateWorldMatrix(!0, !1), Zr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Yr.lookAt(Zr, Qr, this.up) : Yr.lookAt(Qr, Zr, this.up), this.quaternion.setFromRotationMatrix(Yr), r && (Yr.extractRotation(r.matrixWorld), Kr.setFromRotationMatrix(Yr), this.quaternion.premultiply(Kr.invert()))
				}
				add(e) {
					if (arguments.length > 1) {
						for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
						return this
					}
					return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(ii)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
				}
				remove(e) {
					if (arguments.length > 1) {
						for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
						return this
					}
					const t = this.children.indexOf(e);
					return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(si)), this
				}
				removeFromParent() {
					const e = this.parent;
					return null !== e && e.remove(this), this
				}
				clear() {
					for (let e = 0; e < this.children.length; e++) {
						const t = this.children[e];
						t.parent = null, t.dispatchEvent(si)
					}
					return this.children.length = 0, this
				}
				attach(e) {
					return this.updateWorldMatrix(!0, !1), Yr.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Yr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Yr), this.add(e), e.updateWorldMatrix(!1, !0), this
				}
				getObjectById(e) {
					return this.getObjectByProperty("id", e)
				}
				getObjectByName(e) {
					return this.getObjectByProperty("name", e)
				}
				getObjectByProperty(e, t) {
					if (this[e] === t) return this;
					for (let n = 0, r = this.children.length; n < r; n++) {
						const r = this.children[n].getObjectByProperty(e, t);
						if (void 0 !== r) return r
					}
				}
				getWorldPosition(e) {
					return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
				}
				getWorldQuaternion(e) {
					return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zr, e, $r), e
				}
				getWorldScale(e) {
					return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zr, ei, e), e
				}
				getWorldDirection(e) {
					this.updateWorldMatrix(!0, !1);
					const t = this.matrixWorld.elements;
					return e.set(t[8], t[9], t[10]).normalize()
				}
				raycast() {}
				traverse(e) {
					e(this);
					const t = this.children;
					for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e)
				}
				traverseVisible(e) {
					if (!1 === this.visible) return;
					e(this);
					const t = this.children;
					for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
				}
				traverseAncestors(e) {
					const t = this.parent;
					null !== t && (e(t), t.traverseAncestors(e))
				}
				updateMatrix() {
					this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
				}
				updateMatrixWorld(e) {
					this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
					const t = this.children;
					for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
				}
				updateWorldMatrix(e, t) {
					const n = this.parent;
					if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
						const e = this.children;
						for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
					}
				}
				toJSON(e) {
					const t = void 0 === e || "string" === typeof e,
						n = {};
					t && (e = {
						geometries: {},
						materials: {},
						textures: {},
						images: {},
						shapes: {},
						skeletons: {},
						animations: {}
					}, n.metadata = {
						version: 4.5,
						type: "Object",
						generator: "Object3D.toJSON"
					});
					const r = {};

					function i(t, n) {
						return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
					}
					if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(e).uuid);
					else if (this.isMesh || this.isLine || this.isPoints) {
						r.geometry = i(e.geometries, this.geometry);
						const t = this.geometry.parameters;
						if (void 0 !== t && void 0 !== t.shapes) {
							const n = t.shapes;
							if (Array.isArray(n))
								for (let t = 0, r = n.length; t < r; t++) {
									const r = n[t];
									i(e.shapes, r)
								} else i(e.shapes, n)
						}
					}
					if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
						if (Array.isArray(this.material)) {
							const t = [];
							for (let n = 0, r = this.material.length; n < r; n++) t.push(i(e.materials, this.material[n]));
							r.material = t
						} else r.material = i(e.materials, this.material);
					if (this.children.length > 0) {
						r.children = [];
						for (let t = 0; t < this.children.length; t++) r.children.push(this.children[t].toJSON(e).object)
					}
					if (this.animations.length > 0) {
						r.animations = [];
						for (let t = 0; t < this.animations.length; t++) {
							const n = this.animations[t];
							r.animations.push(i(e.animations, n))
						}
					}
					if (t) {
						const t = s(e.geometries),
							r = s(e.materials),
							i = s(e.textures),
							a = s(e.images),
							o = s(e.shapes),
							l = s(e.skeletons),
							c = s(e.animations);
						t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
					}
					return n.object = r, n;

					function s(e) {
						const t = [];
						for (const n in e) {
							const r = e[n];
							delete r.metadata, t.push(r)
						}
						return t
					}
				}
				clone(e) {
					return (new this.constructor).copy(this, e)
				}
				copy(e, t = !0) {
					if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
						for (let n = 0; n < e.children.length; n++) {
							const t = e.children[n];
							this.add(t.clone())
						}
					return this
				}
			}
			ai.DefaultUp = new ir(0, 1, 0), ai.DefaultMatrixAutoUpdate = !0, ai.prototype.isObject3D = !0;
			const oi = new ir,
				li = new ir,
				ci = new ir,
				ui = new ir,
				hi = new ir,
				di = new ir,
				pi = new ir,
				fi = new ir,
				mi = new ir,
				gi = new ir;
			class vi {
				constructor(e = new ir, t = new ir, n = new ir) {
					this.a = e, this.b = t, this.c = n
				}
				static getNormal(e, t, n, r) {
					r.subVectors(n, t), oi.subVectors(e, t), r.cross(oi);
					const i = r.lengthSq();
					return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
				}
				static getBarycoord(e, t, n, r, i) {
					oi.subVectors(r, t), li.subVectors(n, t), ci.subVectors(e, t);
					const s = oi.dot(oi),
						a = oi.dot(li),
						o = oi.dot(ci),
						l = li.dot(li),
						c = li.dot(ci),
						u = s * l - a * a;
					if (0 === u) return i.set(-2, -1, -1);
					const h = 1 / u,
						d = (l * o - a * c) * h,
						p = (s * c - a * o) * h;
					return i.set(1 - d - p, p, d)
				}
				static containsPoint(e, t, n, r) {
					return this.getBarycoord(e, t, n, r, ui), ui.x >= 0 && ui.y >= 0 && ui.x + ui.y <= 1
				}
				static getUV(e, t, n, r, i, s, a, o) {
					return this.getBarycoord(e, t, n, r, ui), o.set(0, 0), o.addScaledVector(i, ui.x), o.addScaledVector(s, ui.y), o.addScaledVector(a, ui.z), o
				}
				static isFrontFacing(e, t, n, r) {
					return oi.subVectors(n, t), li.subVectors(e, t), oi.cross(li).dot(r) < 0
				}
				set(e, t, n) {
					return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
				}
				setFromPointsAndIndices(e, t, n, r) {
					return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
				}
				setFromAttributeAndIndices(e, t, n, r) {
					return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
				}
				getArea() {
					return oi.subVectors(this.c, this.b), li.subVectors(this.a, this.b), .5 * oi.cross(li).length()
				}
				getMidpoint(e) {
					return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
				}
				getNormal(e) {
					return vi.getNormal(this.a, this.b, this.c, e)
				}
				getPlane(e) {
					return e.setFromCoplanarPoints(this.a, this.b, this.c)
				}
				getBarycoord(e, t) {
					return vi.getBarycoord(e, this.a, this.b, this.c, t)
				}
				getUV(e, t, n, r, i) {
					return vi.getUV(e, this.a, this.b, this.c, t, n, r, i)
				}
				containsPoint(e) {
					return vi.containsPoint(e, this.a, this.b, this.c)
				}
				isFrontFacing(e) {
					return vi.isFrontFacing(this.a, this.b, this.c, e)
				}
				intersectsBox(e) {
					return e.intersectsTriangle(this)
				}
				closestPointToPoint(e, t) {
					const n = this.a,
						r = this.b,
						i = this.c;
					let s, a;
					hi.subVectors(r, n), di.subVectors(i, n), fi.subVectors(e, n);
					const o = hi.dot(fi),
						l = di.dot(fi);
					if (o <= 0 && l <= 0) return t.copy(n);
					mi.subVectors(e, r);
					const c = hi.dot(mi),
						u = di.dot(mi);
					if (c >= 0 && u <= c) return t.copy(r);
					const h = o * u - c * l;
					if (h <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(hi, s);
					gi.subVectors(e, i);
					const d = hi.dot(gi),
						p = di.dot(gi);
					if (p >= 0 && d <= p) return t.copy(i);
					const f = d * l - o * p;
					if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(di, a);
					const m = c * p - d * u;
					if (m <= 0 && u - c >= 0 && d - p >= 0) return pi.subVectors(i, r), a = (u - c) / (u - c + (d - p)), t.copy(r).addScaledVector(pi, a);
					const g = 1 / (m + f + h);
					return s = f * g, a = h * g, t.copy(n).addScaledVector(hi, s).addScaledVector(di, a)
				}
				equals(e) {
					return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
				}
			}
			let yi = 0;
			class xi extends Bn {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: yi++
					}), this.uuid = Dn(), this.name = "", this.type = "Material", this.fog = !0, this.blending = _, this.side = f, this.vertexColors = !1, this.opacity = 1, this.format = He, this.transparent = !1, this.blendSrc = D, this.blendDst = F, this.blendEquation = S, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = W, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = vn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = nn, this.stencilZFail = nn, this.stencilZPass = nn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
				}
				get alphaTest() {
					return this._alphaTest
				}
				set alphaTest(e) {
					this._alphaTest > 0 !== e > 0 && this.version++, this._alphaTest = e
				}
				onBuild() {}
				onBeforeRender() {}
				onBeforeCompile() {}
				customProgramCacheKey() {
					return this.onBeforeCompile.toString()
				}
				setValues(e) {
					if (void 0 !== e)
						for (const t in e) {
							const n = e[t];
							if (void 0 === n) {
								console.warn("THREE.Material: '" + t + "' parameter is undefined.");
								continue
							}
							if ("shading" === t) {
								console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === v;
								continue
							}
							const r = this[t];
							void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
						}
				}
				toJSON(e) {
					const t = void 0 === e || "string" === typeof e;
					t && (e = {
						textures: {},
						images: {}
					});
					const n = {
						metadata: {
							version: 4.5,
							type: "Material",
							generator: "Material.toJSON"
						}
					};

					function r(e) {
						const t = [];
						for (const n in e) {
							const r = e[n];
							delete r.metadata, t.push(r)
						}
						return t
					}
					if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== _ && (n.blending = this.blending), this.side !== f && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== He && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
						const t = r(e.textures),
							i = r(e.images);
						t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
					}
					return n
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
					const t = e.clippingPlanes;
					let n = null;
					if (null !== t) {
						const e = t.length;
						n = new Array(e);
						for (let r = 0; r !== e; ++r) n[r] = t[r].clone()
					}
					return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
				set needsUpdate(e) {
					!0 === e && this.version++
				}
			}
			xi.prototype.isMaterial = !0;
			const _i = {
					aliceblue: 15792383,
					antiquewhite: 16444375,
					aqua: 65535,
					aquamarine: 8388564,
					azure: 15794175,
					beige: 16119260,
					bisque: 16770244,
					black: 0,
					blanchedalmond: 16772045,
					blue: 255,
					blueviolet: 9055202,
					brown: 10824234,
					burlywood: 14596231,
					cadetblue: 6266528,
					chartreuse: 8388352,
					chocolate: 13789470,
					coral: 16744272,
					cornflowerblue: 6591981,
					cornsilk: 16775388,
					crimson: 14423100,
					cyan: 65535,
					darkblue: 139,
					darkcyan: 35723,
					darkgoldenrod: 12092939,
					darkgray: 11119017,
					darkgreen: 25600,
					darkgrey: 11119017,
					darkkhaki: 12433259,
					darkmagenta: 9109643,
					darkolivegreen: 5597999,
					darkorange: 16747520,
					darkorchid: 10040012,
					darkred: 9109504,
					darksalmon: 15308410,
					darkseagreen: 9419919,
					darkslateblue: 4734347,
					darkslategray: 3100495,
					darkslategrey: 3100495,
					darkturquoise: 52945,
					darkviolet: 9699539,
					deeppink: 16716947,
					deepskyblue: 49151,
					dimgray: 6908265,
					dimgrey: 6908265,
					dodgerblue: 2003199,
					firebrick: 11674146,
					floralwhite: 16775920,
					forestgreen: 2263842,
					fuchsia: 16711935,
					gainsboro: 14474460,
					ghostwhite: 16316671,
					gold: 16766720,
					goldenrod: 14329120,
					gray: 8421504,
					green: 32768,
					greenyellow: 11403055,
					grey: 8421504,
					honeydew: 15794160,
					hotpink: 16738740,
					indianred: 13458524,
					indigo: 4915330,
					ivory: 16777200,
					khaki: 15787660,
					lavender: 15132410,
					lavenderblush: 16773365,
					lawngreen: 8190976,
					lemonchiffon: 16775885,
					lightblue: 11393254,
					lightcoral: 15761536,
					lightcyan: 14745599,
					lightgoldenrodyellow: 16448210,
					lightgray: 13882323,
					lightgreen: 9498256,
					lightgrey: 13882323,
					lightpink: 16758465,
					lightsalmon: 16752762,
					lightseagreen: 2142890,
					lightskyblue: 8900346,
					lightslategray: 7833753,
					lightslategrey: 7833753,
					lightsteelblue: 11584734,
					lightyellow: 16777184,
					lime: 65280,
					limegreen: 3329330,
					linen: 16445670,
					magenta: 16711935,
					maroon: 8388608,
					mediumaquamarine: 6737322,
					mediumblue: 205,
					mediumorchid: 12211667,
					mediumpurple: 9662683,
					mediumseagreen: 3978097,
					mediumslateblue: 8087790,
					mediumspringgreen: 64154,
					mediumturquoise: 4772300,
					mediumvioletred: 13047173,
					midnightblue: 1644912,
					mintcream: 16121850,
					mistyrose: 16770273,
					moccasin: 16770229,
					navajowhite: 16768685,
					navy: 128,
					oldlace: 16643558,
					olive: 8421376,
					olivedrab: 7048739,
					orange: 16753920,
					orangered: 16729344,
					orchid: 14315734,
					palegoldenrod: 15657130,
					palegreen: 10025880,
					paleturquoise: 11529966,
					palevioletred: 14381203,
					papayawhip: 16773077,
					peachpuff: 16767673,
					peru: 13468991,
					pink: 16761035,
					plum: 14524637,
					powderblue: 11591910,
					purple: 8388736,
					rebeccapurple: 6697881,
					red: 16711680,
					rosybrown: 12357519,
					royalblue: 4286945,
					saddlebrown: 9127187,
					salmon: 16416882,
					sandybrown: 16032864,
					seagreen: 3050327,
					seashell: 16774638,
					sienna: 10506797,
					silver: 12632256,
					skyblue: 8900331,
					slateblue: 6970061,
					slategray: 7372944,
					slategrey: 7372944,
					snow: 16775930,
					springgreen: 65407,
					steelblue: 4620980,
					tan: 13808780,
					teal: 32896,
					thistle: 14204888,
					tomato: 16737095,
					turquoise: 4251856,
					violet: 15631086,
					wheat: 16113331,
					white: 16777215,
					whitesmoke: 16119285,
					yellow: 16776960,
					yellowgreen: 10145074
				},
				bi = {
					h: 0,
					s: 0,
					l: 0
				},
				wi = {
					h: 0,
					s: 0,
					l: 0
				};

			function Mi(e, t, n) {
				return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
			}

			function Ai(e) {
				return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
			}

			function Si(e) {
				return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
			}
			class Ei {
				constructor(e, t, n) {
					return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
				}
				set(e) {
					return e && e.isColor ? this.copy(e) : "number" === typeof e ? this.setHex(e) : "string" === typeof e && this.setStyle(e), this
				}
				setScalar(e) {
					return this.r = e, this.g = e, this.b = e, this
				}
				setHex(e) {
					return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
				}
				setRGB(e, t, n) {
					return this.r = e, this.g = t, this.b = n, this
				}
				setHSL(e, t, n) {
					if (e = On(e, 1), t = Fn(t, 0, 1), n = Fn(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
					else {
						const r = n <= .5 ? n * (1 + t) : n + t - n * t,
							i = 2 * n - r;
						this.r = Mi(i, r, e + 1 / 3), this.g = Mi(i, r, e), this.b = Mi(i, r, e - 1 / 3)
					}
					return this
				}
				setStyle(e) {
					function t(t) {
						void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
					}
					let n;
					if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
						let e;
						const r = n[1],
							i = n[2];
						switch (r) {
							case "rgb":
							case "rgba":
								if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
								if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
								break;
							case "hsl":
							case "hsla":
								if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
									const n = parseFloat(e[1]) / 360,
										r = parseInt(e[2], 10) / 100,
										i = parseInt(e[3], 10) / 100;
									return t(e[4]), this.setHSL(n, r, i)
								}
						}
					} else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
						const e = n[1],
							t = e.length;
						if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
						if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
					}
					return e && e.length > 0 ? this.setColorName(e) : this
				}
				setColorName(e) {
					const t = _i[e.toLowerCase()];
					return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
				}
				clone() {
					return new this.constructor(this.r, this.g, this.b)
				}
				copy(e) {
					return this.r = e.r, this.g = e.g, this.b = e.b, this
				}
				copySRGBToLinear(e) {
					return this.r = Ai(e.r), this.g = Ai(e.g), this.b = Ai(e.b), this
				}
				copyLinearToSRGB(e) {
					return this.r = Si(e.r), this.g = Si(e.g), this.b = Si(e.b), this
				}
				convertSRGBToLinear() {
					return this.copySRGBToLinear(this), this
				}
				convertLinearToSRGB() {
					return this.copyLinearToSRGB(this), this
				}
				getHex() {
					return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
				}
				getHexString() {
					return ("000000" + this.getHex().toString(16)).slice(-6)
				}
				getHSL(e) {
					const t = this.r,
						n = this.g,
						r = this.b,
						i = Math.max(t, n, r),
						s = Math.min(t, n, r);
					let a, o;
					const l = (s + i) / 2;
					if (s === i) a = 0, o = 0;
					else {
						const e = i - s;
						switch (o = l <= .5 ? e / (i + s) : e / (2 - i - s), i) {
							case t:
								a = (n - r) / e + (n < r ? 6 : 0);
								break;
							case n:
								a = (r - t) / e + 2;
								break;
							case r:
								a = (t - n) / e + 4
						}
						a /= 6
					}
					return e.h = a, e.s = o, e.l = l, e
				}
				getStyle() {
					return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
				}
				offsetHSL(e, t, n) {
					return this.getHSL(bi), bi.h += e, bi.s += t, bi.l += n, this.setHSL(bi.h, bi.s, bi.l), this
				}
				add(e) {
					return this.r += e.r, this.g += e.g, this.b += e.b, this
				}
				addColors(e, t) {
					return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
				}
				addScalar(e) {
					return this.r += e, this.g += e, this.b += e, this
				}
				sub(e) {
					return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
				}
				multiply(e) {
					return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
				}
				multiplyScalar(e) {
					return this.r *= e, this.g *= e, this.b *= e, this
				}
				lerp(e, t) {
					return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
				}
				lerpColors(e, t, n) {
					return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
				}
				lerpHSL(e, t) {
					this.getHSL(bi), e.getHSL(wi);
					const n = Nn(bi.h, wi.h, t),
						r = Nn(bi.s, wi.s, t),
						i = Nn(bi.l, wi.l, t);
					return this.setHSL(n, r, i), this
				}
				equals(e) {
					return e.r === this.r && e.g === this.g && e.b === this.b
				}
				fromArray(e, t = 0) {
					return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
				}
				toArray(e = [], t = 0) {
					return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
				}
				fromBufferAttribute(e, t) {
					return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
				}
				toJSON() {
					return this.getHex()
				}
			}
			Ei.NAMES = _i, Ei.prototype.isColor = !0, Ei.prototype.r = 1, Ei.prototype.g = 1, Ei.prototype.b = 1;
			class Ti extends xi {
				constructor(e) {
					super(), this.type = "MeshBasicMaterial", this.color = new Ei(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
				}
			}
			Ti.prototype.isMeshBasicMaterial = !0;
			const Ci = new ir,
				Bi = new zn;
			class Ri {
				constructor(e, t, n) {
					if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = yn, this.updateRange = {
						offset: 0,
						count: -1
					}, this.version = 0
				}
				onUploadCallback() {}
				set needsUpdate(e) {
					!0 === e && this.version++
				}
				setUsage(e) {
					return this.usage = e, this
				}
				copy(e) {
					return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
				}
				copyAt(e, t, n) {
					e *= this.itemSize, n *= t.itemSize;
					for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
					return this
				}
				copyArray(e) {
					return this.array.set(e), this
				}
				copyColorsArray(e) {
					const t = this.array;
					let n = 0;
					for (let r = 0, i = e.length; r < i; r++) {
						let i = e[r];
						void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new Ei), t[n++] = i.r, t[n++] = i.g, t[n++] = i.b
					}
					return this
				}
				copyVector2sArray(e) {
					const t = this.array;
					let n = 0;
					for (let r = 0, i = e.length; r < i; r++) {
						let i = e[r];
						void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new zn), t[n++] = i.x, t[n++] = i.y
					}
					return this
				}
				copyVector3sArray(e) {
					const t = this.array;
					let n = 0;
					for (let r = 0, i = e.length; r < i; r++) {
						let i = e[r];
						void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new ir), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z
					}
					return this
				}
				copyVector4sArray(e) {
					const t = this.array;
					let n = 0;
					for (let r = 0, i = e.length; r < i; r++) {
						let i = e[r];
						void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new $n), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z, t[n++] = i.w
					}
					return this
				}
				applyMatrix3(e) {
					if (2 === this.itemSize)
						for (let t = 0, n = this.count; t < n; t++) Bi.fromBufferAttribute(this, t), Bi.applyMatrix3(e), this.setXY(t, Bi.x, Bi.y);
					else if (3 === this.itemSize)
						for (let t = 0, n = this.count; t < n; t++) Ci.fromBufferAttribute(this, t), Ci.applyMatrix3(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
					return this
				}
				applyMatrix4(e) {
					for (let t = 0, n = this.count; t < n; t++) Ci.x = this.getX(t), Ci.y = this.getY(t), Ci.z = this.getZ(t), Ci.applyMatrix4(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
					return this
				}
				applyNormalMatrix(e) {
					for (let t = 0, n = this.count; t < n; t++) Ci.x = this.getX(t), Ci.y = this.getY(t), Ci.z = this.getZ(t), Ci.applyNormalMatrix(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
					return this
				}
				transformDirection(e) {
					for (let t = 0, n = this.count; t < n; t++) Ci.x = this.getX(t), Ci.y = this.getY(t), Ci.z = this.getZ(t), Ci.transformDirection(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
					return this
				}
				set(e, t = 0) {
					return this.array.set(e, t), this
				}
				getX(e) {
					return this.array[e * this.itemSize]
				}
				setX(e, t) {
					return this.array[e * this.itemSize] = t, this
				}
				getY(e) {
					return this.array[e * this.itemSize + 1]
				}
				setY(e, t) {
					return this.array[e * this.itemSize + 1] = t, this
				}
				getZ(e) {
					return this.array[e * this.itemSize + 2]
				}
				setZ(e, t) {
					return this.array[e * this.itemSize + 2] = t, this
				}
				getW(e) {
					return this.array[e * this.itemSize + 3]
				}
				setW(e, t) {
					return this.array[e * this.itemSize + 3] = t, this
				}
				setXY(e, t, n) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
				}
				setXYZ(e, t, n, r) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
				}
				setXYZW(e, t, n, r, i) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
				}
				onUpload(e) {
					return this.onUploadCallback = e, this
				}
				clone() {
					return new this.constructor(this.array, this.itemSize).copy(this)
				}
				toJSON() {
					const e = {
						itemSize: this.itemSize,
						type: this.array.constructor.name,
						array: Array.prototype.slice.call(this.array),
						normalized: this.normalized
					};
					return "" !== this.name && (e.name = this.name), this.usage !== yn && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
				}
			}
			Ri.prototype.isBufferAttribute = !0;
			class Li extends Ri {
				constructor(e, t, n) {
					super(new Int8Array(e), t, n)
				}
			}
			class Ii extends Ri {
				constructor(e, t, n) {
					super(new Uint8Array(e), t, n)
				}
			}
			class Pi extends Ri {
				constructor(e, t, n) {
					super(new Uint8ClampedArray(e), t, n)
				}
			}
			class Di extends Ri {
				constructor(e, t, n) {
					super(new Int16Array(e), t, n)
				}
			}
			class Fi extends Ri {
				constructor(e, t, n) {
					super(new Uint16Array(e), t, n)
				}
			}
			class Oi extends Ri {
				constructor(e, t, n) {
					super(new Int32Array(e), t, n)
				}
			}
			class Ni extends Ri {
				constructor(e, t, n) {
					super(new Uint32Array(e), t, n)
				}
			}
			class Hi extends Ri {
				constructor(e, t, n) {
					super(new Uint16Array(e), t, n)
				}
			}
			Hi.prototype.isFloat16BufferAttribute = !0;
			class ki extends Ri {
				constructor(e, t, n) {
					super(new Float32Array(e), t, n)
				}
			}
			class Gi extends Ri {
				constructor(e, t, n) {
					super(new Float64Array(e), t, n)
				}
			}
			let Ui = 0;
			const zi = new Fr,
				Vi = new ai,
				Wi = new ir,
				ji = new or,
				Ji = new or,
				Xi = new ir;
			class qi extends Bn {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: Ui++
					}), this.uuid = Dn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
						start: 0,
						count: 1 / 0
					}, this.userData = {}
				}
				getIndex() {
					return this.index
				}
				setIndex(e) {
					return Array.isArray(e) ? this.index = new(Wn(e) > 65535 ? Ni : Fi)(e, 1) : this.index = e, this
				}
				getAttribute(e) {
					return this.attributes[e]
				}
				setAttribute(e, t) {
					return this.attributes[e] = t, this
				}
				deleteAttribute(e) {
					return delete this.attributes[e], this
				}
				hasAttribute(e) {
					return void 0 !== this.attributes[e]
				}
				addGroup(e, t, n = 0) {
					this.groups.push({
						start: e,
						count: t,
						materialIndex: n
					})
				}
				clearGroups() {
					this.groups = []
				}
				setDrawRange(e, t) {
					this.drawRange.start = e, this.drawRange.count = t
				}
				applyMatrix4(e) {
					const t = this.attributes.position;
					void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
					const n = this.attributes.normal;
					if (void 0 !== n) {
						const t = (new Vn).getNormalMatrix(e);
						n.applyNormalMatrix(t), n.needsUpdate = !0
					}
					const r = this.attributes.tangent;
					return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
				}
				applyQuaternion(e) {
					return zi.makeRotationFromQuaternion(e), this.applyMatrix4(zi), this
				}
				rotateX(e) {
					return zi.makeRotationX(e), this.applyMatrix4(zi), this
				}
				rotateY(e) {
					return zi.makeRotationY(e), this.applyMatrix4(zi), this
				}
				rotateZ(e) {
					return zi.makeRotationZ(e), this.applyMatrix4(zi), this
				}
				translate(e, t, n) {
					return zi.makeTranslation(e, t, n), this.applyMatrix4(zi), this
				}
				scale(e, t, n) {
					return zi.makeScale(e, t, n), this.applyMatrix4(zi), this
				}
				lookAt(e) {
					return Vi.lookAt(e), Vi.updateMatrix(), this.applyMatrix4(Vi.matrix), this
				}
				center() {
					return this.computeBoundingBox(), this.boundingBox.getCenter(Wi).negate(), this.translate(Wi.x, Wi.y, Wi.z), this
				}
				setFromPoints(e) {
					const t = [];
					for (let n = 0, r = e.length; n < r; n++) {
						const r = e[n];
						t.push(r.x, r.y, r.z || 0)
					}
					return this.setAttribute("position", new ki(t, 3)), this
				}
				computeBoundingBox() {
					null === this.boundingBox && (this.boundingBox = new or);
					const e = this.attributes.position,
						t = this.morphAttributes.position;
					if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ir(-1 / 0, -1 / 0, -1 / 0), new ir(1 / 0, 1 / 0, 1 / 0));
					if (void 0 !== e) {
						if (this.boundingBox.setFromBufferAttribute(e), t)
							for (let n = 0, r = t.length; n < r; n++) {
								const e = t[n];
								ji.setFromBufferAttribute(e), this.morphTargetsRelative ? (Xi.addVectors(this.boundingBox.min, ji.min), this.boundingBox.expandByPoint(Xi), Xi.addVectors(this.boundingBox.max, ji.max), this.boundingBox.expandByPoint(Xi)) : (this.boundingBox.expandByPoint(ji.min), this.boundingBox.expandByPoint(ji.max))
							}
					} else this.boundingBox.makeEmpty();
					(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
				}
				computeBoundingSphere() {
					null === this.boundingSphere && (this.boundingSphere = new Er);
					const e = this.attributes.position,
						t = this.morphAttributes.position;
					if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ir, 1 / 0);
					if (e) {
						const n = this.boundingSphere.center;
						if (ji.setFromBufferAttribute(e), t)
							for (let e = 0, i = t.length; e < i; e++) {
								const n = t[e];
								Ji.setFromBufferAttribute(n), this.morphTargetsRelative ? (Xi.addVectors(ji.min, Ji.min), ji.expandByPoint(Xi), Xi.addVectors(ji.max, Ji.max), ji.expandByPoint(Xi)) : (ji.expandByPoint(Ji.min), ji.expandByPoint(Ji.max))
							}
						ji.getCenter(n);
						let r = 0;
						for (let t = 0, i = e.count; t < i; t++) Xi.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(Xi));
						if (t)
							for (let i = 0, s = t.length; i < s; i++) {
								const s = t[i],
									a = this.morphTargetsRelative;
								for (let t = 0, i = s.count; t < i; t++) Xi.fromBufferAttribute(s, t), a && (Wi.fromBufferAttribute(e, t), Xi.add(Wi)), r = Math.max(r, n.distanceToSquared(Xi))
							}
						this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
					}
				}
				computeTangents() {
					const e = this.index,
						t = this.attributes;
					if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
					const n = e.array,
						r = t.position.array,
						i = t.normal.array,
						s = t.uv.array,
						a = r.length / 3;
					void 0 === t.tangent && this.setAttribute("tangent", new Ri(new Float32Array(4 * a), 4));
					const o = t.tangent.array,
						l = [],
						c = [];
					for (let S = 0; S < a; S++) l[S] = new ir, c[S] = new ir;
					const u = new ir,
						h = new ir,
						d = new ir,
						p = new zn,
						f = new zn,
						m = new zn,
						g = new ir,
						v = new ir;

					function y(e, t, n) {
						u.fromArray(r, 3 * e), h.fromArray(r, 3 * t), d.fromArray(r, 3 * n), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
						const i = 1 / (f.x * m.y - m.x * f.y);
						isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
					}
					let x = this.groups;
					0 === x.length && (x = [{
						start: 0,
						count: n.length
					}]);
					for (let S = 0, E = x.length; S < E; ++S) {
						const e = x[S],
							t = e.start;
						for (let r = t, i = t + e.count; r < i; r += 3) y(n[r + 0], n[r + 1], n[r + 2])
					}
					const _ = new ir,
						b = new ir,
						w = new ir,
						M = new ir;

					function A(e) {
						w.fromArray(i, 3 * e), M.copy(w);
						const t = l[e];
						_.copy(t), _.sub(w.multiplyScalar(w.dot(t))).normalize(), b.crossVectors(M, t);
						const n = b.dot(c[e]) < 0 ? -1 : 1;
						o[4 * e] = _.x, o[4 * e + 1] = _.y, o[4 * e + 2] = _.z, o[4 * e + 3] = n
					}
					for (let S = 0, E = x.length; S < E; ++S) {
						const e = x[S],
							t = e.start;
						for (let r = t, i = t + e.count; r < i; r += 3) A(n[r + 0]), A(n[r + 1]), A(n[r + 2])
					}
				}
				computeVertexNormals() {
					const e = this.index,
						t = this.getAttribute("position");
					if (void 0 !== t) {
						let n = this.getAttribute("normal");
						if (void 0 === n) n = new Ri(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
						else
							for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
						const r = new ir,
							i = new ir,
							s = new ir,
							a = new ir,
							o = new ir,
							l = new ir,
							c = new ir,
							u = new ir;
						if (e)
							for (let h = 0, d = e.count; h < d; h += 3) {
								const d = e.getX(h + 0),
									p = e.getX(h + 1),
									f = e.getX(h + 2);
								r.fromBufferAttribute(t, d), i.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
							} else
								for (let e = 0, h = t.count; e < h; e += 3) r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
						this.normalizeNormals(), n.needsUpdate = !0
					}
				}
				merge(e, t) {
					if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
					void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
					const n = this.attributes;
					for (const r in n) {
						if (void 0 === e.attributes[r]) continue;
						const i = n[r].array,
							s = e.attributes[r],
							a = s.array,
							o = s.itemSize * t,
							l = Math.min(a.length, i.length - o);
						for (let e = 0, t = o; e < l; e++, t++) i[t] = a[e]
					}
					return this
				}
				normalizeNormals() {
					const e = this.attributes.normal;
					for (let t = 0, n = e.count; t < n; t++) Xi.fromBufferAttribute(e, t), Xi.normalize(), e.setXYZ(t, Xi.x, Xi.y, Xi.z)
				}
				toNonIndexed() {
					function e(e, t) {
						const n = e.array,
							r = e.itemSize,
							i = e.normalized,
							s = new n.constructor(t.length * r);
						let a = 0,
							o = 0;
						for (let l = 0, c = t.length; l < c; l++) {
							a = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
							for (let e = 0; e < r; e++) s[o++] = n[a++]
						}
						return new Ri(s, r, i)
					}
					if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
					const t = new qi,
						n = this.index.array,
						r = this.attributes;
					for (const a in r) {
						const i = e(r[a], n);
						t.setAttribute(a, i)
					}
					const i = this.morphAttributes;
					for (const a in i) {
						const r = [],
							s = i[a];
						for (let t = 0, i = s.length; t < i; t++) {
							const i = e(s[t], n);
							r.push(i)
						}
						t.morphAttributes[a] = r
					}
					t.morphTargetsRelative = this.morphTargetsRelative;
					const s = this.groups;
					for (let a = 0, o = s.length; a < o; a++) {
						const e = s[a];
						t.addGroup(e.start, e.count, e.materialIndex)
					}
					return t
				}
				toJSON() {
					const e = {
						metadata: {
							version: 4.5,
							type: "BufferGeometry",
							generator: "BufferGeometry.toJSON"
						}
					};
					if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
						const t = this.parameters;
						for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
						return e
					}
					e.data = {
						attributes: {}
					};
					const t = this.index;
					null !== t && (e.data.index = {
						type: t.array.constructor.name,
						array: Array.prototype.slice.call(t.array)
					});
					const n = this.attributes;
					for (const o in n) {
						const t = n[o];
						e.data.attributes[o] = t.toJSON(e.data)
					}
					const r = {};
					let i = !1;
					for (const o in this.morphAttributes) {
						const t = this.morphAttributes[o],
							n = [];
						for (let r = 0, i = t.length; r < i; r++) {
							const i = t[r];
							n.push(i.toJSON(e.data))
						}
						n.length > 0 && (r[o] = n, i = !0)
					}
					i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
					const s = this.groups;
					s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
					const a = this.boundingSphere;
					return null !== a && (e.data.boundingSphere = {
						center: a.center.toArray(),
						radius: a.radius
					}), e
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
					const t = {};
					this.name = e.name;
					const n = e.index;
					null !== n && this.setIndex(n.clone(t));
					const r = e.attributes;
					for (const l in r) {
						const e = r[l];
						this.setAttribute(l, e.clone(t))
					}
					const i = e.morphAttributes;
					for (const l in i) {
						const e = [],
							n = i[l];
						for (let r = 0, i = n.length; r < i; r++) e.push(n[r].clone(t));
						this.morphAttributes[l] = e
					}
					this.morphTargetsRelative = e.morphTargetsRelative;
					const s = e.groups;
					for (let l = 0, c = s.length; l < c; l++) {
						const e = s[l];
						this.addGroup(e.start, e.count, e.materialIndex)
					}
					const a = e.boundingBox;
					null !== a && (this.boundingBox = a.clone());
					const o = e.boundingSphere;
					return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			qi.prototype.isBufferGeometry = !0;
			const Ki = new Fr,
				Yi = new Dr,
				Qi = new Er,
				Zi = new ir,
				$i = new ir,
				es = new ir,
				ts = new ir,
				ns = new ir,
				rs = new ir,
				is = new ir,
				ss = new ir,
				as = new ir,
				os = new zn,
				ls = new zn,
				cs = new zn,
				us = new ir,
				hs = new ir;
			class ds extends ai {
				constructor(e = new qi, t = new Ti) {
					super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
				}
				copy(e) {
					return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
				}
				updateMorphTargets() {
					const e = this.geometry;
					if (e.isBufferGeometry) {
						const t = e.morphAttributes,
							n = Object.keys(t);
						if (n.length > 0) {
							const e = t[n[0]];
							if (void 0 !== e) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t].name || String(t);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
								}
							}
						}
					} else {
						const t = e.morphTargets;
						void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
				raycast(e, t) {
					const n = this.geometry,
						r = this.material,
						i = this.matrixWorld;
					if (void 0 === r) return;
					if (null === n.boundingSphere && n.computeBoundingSphere(), Qi.copy(n.boundingSphere), Qi.applyMatrix4(i), !1 === e.ray.intersectsSphere(Qi)) return;
					if (Ki.copy(i).invert(), Yi.copy(e.ray).applyMatrix4(Ki), null !== n.boundingBox && !1 === Yi.intersectsBox(n.boundingBox)) return;
					let s;
					if (n.isBufferGeometry) {
						const i = n.index,
							a = n.attributes.position,
							o = n.morphAttributes.position,
							l = n.morphTargetsRelative,
							c = n.attributes.uv,
							u = n.attributes.uv2,
							h = n.groups,
							d = n.drawRange;
						if (null !== i)
							if (Array.isArray(r))
								for (let n = 0, p = h.length; n < p; n++) {
									const p = h[n],
										f = r[p.materialIndex];
									for (let n = Math.max(p.start, d.start), r = Math.min(i.count, Math.min(p.start + p.count, d.start + d.count)); n < r; n += 3) {
										const r = i.getX(n),
											h = i.getX(n + 1),
											d = i.getX(n + 2);
										s = ps(this, f, e, Yi, a, o, l, c, u, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, t.push(s))
									}
								} else {
									for (let n = Math.max(0, d.start), h = Math.min(i.count, d.start + d.count); n < h; n += 3) {
										const h = i.getX(n),
											d = i.getX(n + 1),
											p = i.getX(n + 2);
										s = ps(this, r, e, Yi, a, o, l, c, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
									}
								} else if (void 0 !== a)
									if (Array.isArray(r))
										for (let n = 0, p = h.length; n < p; n++) {
											const i = h[n],
												p = r[i.materialIndex];
											for (let n = Math.max(i.start, d.start), r = Math.min(a.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) {
												s = ps(this, p, e, Yi, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s))
											}
										} else {
											for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) {
												s = ps(this, r, e, Yi, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
											}
										}
					} else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
			}

			function ps(e, t, n, r, i, s, a, o, l, c, u, h) {
				Zi.fromBufferAttribute(i, c), $i.fromBufferAttribute(i, u), es.fromBufferAttribute(i, h);
				const d = e.morphTargetInfluences;
				if (s && d) {
					is.set(0, 0, 0), ss.set(0, 0, 0), as.set(0, 0, 0);
					for (let e = 0, t = s.length; e < t; e++) {
						const t = d[e],
							n = s[e];
						0 !== t && (ts.fromBufferAttribute(n, c), ns.fromBufferAttribute(n, u), rs.fromBufferAttribute(n, h), a ? (is.addScaledVector(ts, t), ss.addScaledVector(ns, t), as.addScaledVector(rs, t)) : (is.addScaledVector(ts.sub(Zi), t), ss.addScaledVector(ns.sub($i), t), as.addScaledVector(rs.sub(es), t)))
					}
					Zi.add(is), $i.add(ss), es.add(as)
				}
				e.isSkinnedMesh && (e.boneTransform(c, Zi), e.boneTransform(u, $i), e.boneTransform(h, es));
				const p = function(e, t, n, r, i, s, a, o) {
					let l;
					if (l = t.side === m ? r.intersectTriangle(a, s, i, !0, o) : r.intersectTriangle(i, s, a, t.side !== g, o), null === l) return null;
					hs.copy(o), hs.applyMatrix4(e.matrixWorld);
					const c = n.ray.origin.distanceTo(hs);
					return c < n.near || c > n.far ? null : {
						distance: c,
						point: hs.clone(),
						object: e
					}
				}(e, t, n, r, Zi, $i, es, us);
				if (p) {
					o && (os.fromBufferAttribute(o, c), ls.fromBufferAttribute(o, u), cs.fromBufferAttribute(o, h), p.uv = vi.getUV(us, Zi, $i, es, os, ls, cs, new zn)), l && (os.fromBufferAttribute(l, c), ls.fromBufferAttribute(l, u), cs.fromBufferAttribute(l, h), p.uv2 = vi.getUV(us, Zi, $i, es, os, ls, cs, new zn));
					const e = {
						a: c,
						b: u,
						c: h,
						normal: new ir,
						materialIndex: 0
					};
					vi.getNormal(Zi, $i, es, e.normal), p.face = e
				}
				return p
			}
			ds.prototype.isMesh = !0;
			class fs extends qi {
				constructor(e = 1, t = 1, n = 1, r = 1, i = 1, s = 1) {
					super(), this.type = "BoxGeometry", this.parameters = {
						width: e,
						height: t,
						depth: n,
						widthSegments: r,
						heightSegments: i,
						depthSegments: s
					};
					const a = this;
					r = Math.floor(r), i = Math.floor(i), s = Math.floor(s);
					const o = [],
						l = [],
						c = [],
						u = [];
					let h = 0,
						d = 0;

					function p(e, t, n, r, i, s, p, f, m, g, v) {
						const y = s / m,
							x = p / g,
							_ = s / 2,
							b = p / 2,
							w = f / 2,
							M = m + 1,
							A = g + 1;
						let S = 0,
							E = 0;
						const T = new ir;
						for (let a = 0; a < A; a++) {
							const s = a * x - b;
							for (let o = 0; o < M; o++) {
								const h = o * y - _;
								T[e] = h * r, T[t] = s * i, T[n] = w, l.push(T.x, T.y, T.z), T[e] = 0, T[t] = 0, T[n] = f > 0 ? 1 : -1, c.push(T.x, T.y, T.z), u.push(o / m), u.push(1 - a / g), S += 1
							}
						}
						for (let a = 0; a < g; a++)
							for (let e = 0; e < m; e++) {
								const t = h + e + M * a,
									n = h + e + M * (a + 1),
									r = h + (e + 1) + M * (a + 1),
									i = h + (e + 1) + M * a;
								o.push(t, n, i), o.push(n, r, i), E += 6
							}
						a.addGroup(d, E, v), d += E, h += S
					}
					p("z", "y", "x", -1, -1, n, t, e, s, i, 0), p("z", "y", "x", 1, -1, n, t, -e, s, i, 1), p("x", "z", "y", 1, 1, e, n, t, r, s, 2), p("x", "z", "y", 1, -1, e, n, -t, r, s, 3), p("x", "y", "z", 1, -1, e, t, n, r, i, 4), p("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(o), this.setAttribute("position", new ki(l, 3)), this.setAttribute("normal", new ki(c, 3)), this.setAttribute("uv", new ki(u, 2))
				}
				static fromJSON(e) {
					return new fs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
				}
			}

			function ms(e) {
				const t = {};
				for (const n in e) {
					t[n] = {};
					for (const r in e[n]) {
						const i = e[n][r];
						i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
					}
				}
				return t
			}

			function gs(e) {
				const t = {};
				for (let n = 0; n < e.length; n++) {
					const r = ms(e[n]);
					for (const e in r) t[e] = r[e]
				}
				return t
			}
			const vs = {
				clone: ms,
				merge: gs
			};
			class ys extends xi {
				constructor(e) {
					super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
						derivatives: !1,
						fragDepth: !1,
						drawBuffers: !1,
						shaderTextureLOD: !1
					}, this.defaultAttributeValues = {
						color: [1, 1, 1],
						uv: [0, 0],
						uv2: [0, 0]
					}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
				}
				copy(e) {
					return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
				}
				toJSON(e) {
					const t = super.toJSON(e);
					t.glslVersion = this.glslVersion, t.uniforms = {};
					for (const r in this.uniforms) {
						const n = this.uniforms[r].value;
						n && n.isTexture ? t.uniforms[r] = {
							type: "t",
							value: n.toJSON(e).uuid
						} : n && n.isColor ? t.uniforms[r] = {
							type: "c",
							value: n.getHex()
						} : n && n.isVector2 ? t.uniforms[r] = {
							type: "v2",
							value: n.toArray()
						} : n && n.isVector3 ? t.uniforms[r] = {
							type: "v3",
							value: n.toArray()
						} : n && n.isVector4 ? t.uniforms[r] = {
							type: "v4",
							value: n.toArray()
						} : n && n.isMatrix3 ? t.uniforms[r] = {
							type: "m3",
							value: n.toArray()
						} : n && n.isMatrix4 ? t.uniforms[r] = {
							type: "m4",
							value: n.toArray()
						} : t.uniforms[r] = {
							value: n
						}
					}
					Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
					const n = {};
					for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0);
					return Object.keys(n).length > 0 && (t.extensions = n), t
				}
			}
			ys.prototype.isShaderMaterial = !0;
			class xs extends ai {
				constructor() {
					super(), this.type = "Camera", this.matrixWorldInverse = new Fr, this.projectionMatrix = new Fr, this.projectionMatrixInverse = new Fr
				}
				copy(e, t) {
					return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
				}
				getWorldDirection(e) {
					this.updateWorldMatrix(!0, !1);
					const t = this.matrixWorld.elements;
					return e.set(-t[8], -t[9], -t[10]).normalize()
				}
				updateMatrixWorld(e) {
					super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
				}
				updateWorldMatrix(e, t) {
					super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			xs.prototype.isCamera = !0;
			class _s extends xs {
				constructor(e = 50, t = 1, n = .1, r = 2e3) {
					super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
				}
				copy(e, t) {
					return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
				}
				setFocalLength(e) {
					const t = .5 * this.getFilmHeight() / e;
					this.fov = 2 * Pn * Math.atan(t), this.updateProjectionMatrix()
				}
				getFocalLength() {
					const e = Math.tan(.5 * In * this.fov);
					return .5 * this.getFilmHeight() / e
				}
				getEffectiveFOV() {
					return 2 * Pn * Math.atan(Math.tan(.5 * In * this.fov) / this.zoom)
				}
				getFilmWidth() {
					return this.filmGauge * Math.min(this.aspect, 1)
				}
				getFilmHeight() {
					return this.filmGauge / Math.max(this.aspect, 1)
				}
				setViewOffset(e, t, n, r, i, s) {
					this.aspect = e / t, null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
				}
				clearViewOffset() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				}
				updateProjectionMatrix() {
					const e = this.near;
					let t = e * Math.tan(.5 * In * this.fov) / this.zoom,
						n = 2 * t,
						r = this.aspect * n,
						i = -.5 * r;
					const s = this.view;
					if (null !== this.view && this.view.enabled) {
						const e = s.fullWidth,
							a = s.fullHeight;
						i += s.offsetX * r / e, t -= s.offsetY * n / a, r *= s.width / e, n *= s.height / a
					}
					const a = this.filmOffset;
					0 !== a && (i += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
				}
			}
			_s.prototype.isPerspectiveCamera = !0;
			const bs = 90;
			class ws extends ai {
				constructor(e, t, n) {
					if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
					this.renderTarget = n;
					const r = new _s(bs, 1, e, t);
					r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ir(1, 0, 0)), this.add(r);
					const i = new _s(bs, 1, e, t);
					i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ir(-1, 0, 0)), this.add(i);
					const s = new _s(bs, 1, e, t);
					s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new ir(0, 1, 0)), this.add(s);
					const a = new _s(bs, 1, e, t);
					a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new ir(0, -1, 0)), this.add(a);
					const o = new _s(bs, 1, e, t);
					o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new ir(0, 0, 1)), this.add(o);
					const l = new _s(bs, 1, e, t);
					l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ir(0, 0, -1)), this.add(l)
				}
				update(e, t) {
					null === this.parent && this.updateMatrixWorld();
					const n = this.renderTarget,
						[r, i, s, a, o, l] = this.children,
						c = e.xr.enabled,
						u = e.getRenderTarget();
					e.xr.enabled = !1;
					const h = n.texture.generateMipmaps;
					n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c
				}
			}
			class Ms extends Qn {
				constructor(e, t, n, r, i, s, a, o, l, c) {
					super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : se, n, r, i, s, a, o, l, c), this.flipY = !1
				}
				get images() {
					return this.image
				}
				set images(e) {
					this.image = e
				}
			}
			Ms.prototype.isCubeTexture = !0;
			class As extends er {
				constructor(e, t, n) {
					Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new Ms(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : xe, this.texture._needsFlipEnvMap = !1
				}
				fromEquirectangularTexture(e, t) {
					this.texture.type = t.type, this.texture.format = He, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
					const n = {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
							fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
						},
						r = new fs(5, 5, 5),
						i = new ys({
							name: "CubemapFromEquirect",
							uniforms: ms(n.uniforms),
							vertexShader: n.vertexShader,
							fragmentShader: n.fragmentShader,
							side: m,
							blending: x
						});
					i.uniforms.tEquirect.value = t;
					const s = new ds(r, i),
						a = t.minFilter;
					t.minFilter === we && (t.minFilter = xe);
					return new ws(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
				}
				clear(e, t, n, r) {
					const i = e.getRenderTarget();
					for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, n, r);
					e.setRenderTarget(i)
				}
			}
			As.prototype.isWebGLCubeRenderTarget = !0;
			const Ss = new ir,
				Es = new ir,
				Ts = new Vn;
			class Cs {
				constructor(e = new ir(1, 0, 0), t = 0) {
					this.normal = e, this.constant = t
				}
				set(e, t) {
					return this.normal.copy(e), this.constant = t, this
				}
				setComponents(e, t, n, r) {
					return this.normal.set(e, t, n), this.constant = r, this
				}
				setFromNormalAndCoplanarPoint(e, t) {
					return this.normal.copy(e), this.constant = -t.dot(this.normal), this
				}
				setFromCoplanarPoints(e, t, n) {
					const r = Ss.subVectors(n, t).cross(Es.subVectors(e, t)).normalize();
					return this.setFromNormalAndCoplanarPoint(r, e), this
				}
				copy(e) {
					return this.normal.copy(e.normal), this.constant = e.constant, this
				}
				normalize() {
					const e = 1 / this.normal.length();
					return this.normal.multiplyScalar(e), this.constant *= e, this
				}
				negate() {
					return this.constant *= -1, this.normal.negate(), this
				}
				distanceToPoint(e) {
					return this.normal.dot(e) + this.constant
				}
				distanceToSphere(e) {
					return this.distanceToPoint(e.center) - e.radius
				}
				projectPoint(e, t) {
					return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
				}
				intersectLine(e, t) {
					const n = e.delta(Ss),
						r = this.normal.dot(n);
					if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
					const i = -(e.start.dot(this.normal) + this.constant) / r;
					return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start)
				}
				intersectsLine(e) {
					const t = this.distanceToPoint(e.start),
						n = this.distanceToPoint(e.end);
					return t < 0 && n > 0 || n < 0 && t > 0
				}
				intersectsBox(e) {
					return e.intersectsPlane(this)
				}
				intersectsSphere(e) {
					return e.intersectsPlane(this)
				}
				coplanarPoint(e) {
					return e.copy(this.normal).multiplyScalar(-this.constant)
				}
				applyMatrix4(e, t) {
					const n = t || Ts.getNormalMatrix(e),
						r = this.coplanarPoint(Ss).applyMatrix4(e),
						i = this.normal.applyMatrix3(n).normalize();
					return this.constant = -r.dot(i), this
				}
				translate(e) {
					return this.constant -= e.dot(this.normal), this
				}
				equals(e) {
					return e.normal.equals(this.normal) && e.constant === this.constant
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			Cs.prototype.isPlane = !0;
			const Bs = new Er,
				Rs = new ir;
			class Ls {
				constructor(e = new Cs, t = new Cs, n = new Cs, r = new Cs, i = new Cs, s = new Cs) {
					this.planes = [e, t, n, r, i, s]
				}
				set(e, t, n, r, i, s) {
					const a = this.planes;
					return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(s), this
				}
				copy(e) {
					const t = this.planes;
					for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
					return this
				}
				setFromProjectionMatrix(e) {
					const t = this.planes,
						n = e.elements,
						r = n[0],
						i = n[1],
						s = n[2],
						a = n[3],
						o = n[4],
						l = n[5],
						c = n[6],
						u = n[7],
						h = n[8],
						d = n[9],
						p = n[10],
						f = n[11],
						m = n[12],
						g = n[13],
						v = n[14],
						y = n[15];
					return t[0].setComponents(a - r, u - o, f - h, y - m).normalize(), t[1].setComponents(a + r, u + o, f + h, y + m).normalize(), t[2].setComponents(a + i, u + l, f + d, y + g).normalize(), t[3].setComponents(a - i, u - l, f - d, y - g).normalize(), t[4].setComponents(a - s, u - c, f - p, y - v).normalize(), t[5].setComponents(a + s, u + c, f + p, y + v).normalize(), this
				}
				intersectsObject(e) {
					const t = e.geometry;
					return null === t.boundingSphere && t.computeBoundingSphere(), Bs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Bs)
				}
				intersectsSprite(e) {
					return Bs.center.set(0, 0, 0), Bs.radius = .7071067811865476, Bs.applyMatrix4(e.matrixWorld), this.intersectsSphere(Bs)
				}
				intersectsSphere(e) {
					const t = this.planes,
						n = e.center,
						r = -e.radius;
					for (let i = 0; i < 6; i++) {
						if (t[i].distanceToPoint(n) < r) return !1
					}
					return !0
				}
				intersectsBox(e) {
					const t = this.planes;
					for (let n = 0; n < 6; n++) {
						const r = t[n];
						if (Rs.x = r.normal.x > 0 ? e.max.x : e.min.x, Rs.y = r.normal.y > 0 ? e.max.y : e.min.y, Rs.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Rs) < 0) return !1
					}
					return !0
				}
				containsPoint(e) {
					const t = this.planes;
					for (let n = 0; n < 6; n++)
						if (t[n].distanceToPoint(e) < 0) return !1;
					return !0
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}

			function Is() {
				let e = null,
					t = !1,
					n = null,
					r = null;

				function i(t, s) {
					n(t, s), r = e.requestAnimationFrame(i)
				}
				return {
					start: function() {
						!0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
					},
					stop: function() {
						e.cancelAnimationFrame(r), t = !1
					},
					setAnimationLoop: function(e) {
						n = e
					},
					setContext: function(t) {
						e = t
					}
				}
			}

			function Ps(e, t) {
				const n = t.isWebGL2,
					r = new WeakMap;
				return {
					get: function(e) {
						return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
					},
					remove: function(t) {
						t.isInterleavedBufferAttribute && (t = t.data);
						const n = r.get(t);
						n && (e.deleteBuffer(n.buffer), r.delete(t))
					},
					update: function(t, i) {
						if (t.isGLBufferAttribute) {
							const e = r.get(t);
							return void((!e || e.version < t.version) && r.set(t, {
								buffer: t.buffer,
								type: t.type,
								bytesPerElement: t.elementSize,
								version: t.version
							}))
						}
						t.isInterleavedBufferAttribute && (t = t.data);
						const s = r.get(t);
						void 0 === s ? r.set(t, function(t, r) {
							const i = t.array,
								s = t.usage,
								a = e.createBuffer();
							e.bindBuffer(r, a), e.bufferData(r, i, s), t.onUploadCallback();
							let o = 5126;
							return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) && (o = 5121), {
								buffer: a,
								type: o,
								bytesPerElement: i.BYTES_PER_ELEMENT,
								version: t.version
							}
						}(t, i)) : s.version < t.version && (! function(t, r, i) {
							const s = r.array,
								a = r.updateRange;
							e.bindBuffer(i, t), -1 === a.count ? e.bufferSubData(i, 0, s) : (n ? e.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
						}(s.buffer, t, i), s.version = t.version)
					}
				}
			}
			class Ds extends qi {
				constructor(e = 1, t = 1, n = 1, r = 1) {
					super(), this.type = "PlaneGeometry", this.parameters = {
						width: e,
						height: t,
						widthSegments: n,
						heightSegments: r
					};
					const i = e / 2,
						s = t / 2,
						a = Math.floor(n),
						o = Math.floor(r),
						l = a + 1,
						c = o + 1,
						u = e / a,
						h = t / o,
						d = [],
						p = [],
						f = [],
						m = [];
					for (let g = 0; g < c; g++) {
						const e = g * h - s;
						for (let t = 0; t < l; t++) {
							const n = t * u - i;
							p.push(n, -e, 0), f.push(0, 0, 1), m.push(t / a), m.push(1 - g / o)
						}
					}
					for (let g = 0; g < o; g++)
						for (let e = 0; e < a; e++) {
							const t = e + l * g,
								n = e + l * (g + 1),
								r = e + 1 + l * (g + 1),
								i = e + 1 + l * g;
							d.push(t, n, i), d.push(n, r, i)
						}
					this.setIndex(d), this.setAttribute("position", new ki(p, 3)), this.setAttribute("normal", new ki(f, 3)), this.setAttribute("uv", new ki(m, 2))
				}
				static fromJSON(e) {
					return new Ds(e.width, e.height, e.widthSegments, e.heightSegments)
				}
			}
			const Fs = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
					alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
					bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
					common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
					envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
					lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
					lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
					lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
					map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
					normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
					normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
					normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
					normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
					normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
					clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
					clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
					clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
					output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
					transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
					transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
					uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
					meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
				},
				Os = {
					common: {
						diffuse: {
							value: new Ei(16777215)
						},
						opacity: {
							value: 1
						},
						map: {
							value: null
						},
						uvTransform: {
							value: new Vn
						},
						uv2Transform: {
							value: new Vn
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						}
					},
					specularmap: {
						specularMap: {
							value: null
						}
					},
					envmap: {
						envMap: {
							value: null
						},
						flipEnvMap: {
							value: -1
						},
						reflectivity: {
							value: 1
						},
						ior: {
							value: 1.5
						},
						refractionRatio: {
							value: .98
						}
					},
					aomap: {
						aoMap: {
							value: null
						},
						aoMapIntensity: {
							value: 1
						}
					},
					lightmap: {
						lightMap: {
							value: null
						},
						lightMapIntensity: {
							value: 1
						}
					},
					emissivemap: {
						emissiveMap: {
							value: null
						}
					},
					bumpmap: {
						bumpMap: {
							value: null
						},
						bumpScale: {
							value: 1
						}
					},
					normalmap: {
						normalMap: {
							value: null
						},
						normalScale: {
							value: new zn(1, 1)
						}
					},
					displacementmap: {
						displacementMap: {
							value: null
						},
						displacementScale: {
							value: 1
						},
						displacementBias: {
							value: 0
						}
					},
					roughnessmap: {
						roughnessMap: {
							value: null
						}
					},
					metalnessmap: {
						metalnessMap: {
							value: null
						}
					},
					gradientmap: {
						gradientMap: {
							value: null
						}
					},
					fog: {
						fogDensity: {
							value: 25e-5
						},
						fogNear: {
							value: 1
						},
						fogFar: {
							value: 2e3
						},
						fogColor: {
							value: new Ei(16777215)
						}
					},
					lights: {
						ambientLightColor: {
							value: []
						},
						lightProbe: {
							value: []
						},
						directionalLights: {
							value: [],
							properties: {
								direction: {},
								color: {}
							}
						},
						directionalLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						directionalShadowMap: {
							value: []
						},
						directionalShadowMatrix: {
							value: []
						},
						spotLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								direction: {},
								distance: {},
								coneCos: {},
								penumbraCos: {},
								decay: {}
							}
						},
						spotLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						spotShadowMap: {
							value: []
						},
						spotShadowMatrix: {
							value: []
						},
						pointLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								decay: {},
								distance: {}
							}
						},
						pointLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},
						pointShadowMap: {
							value: []
						},
						pointShadowMatrix: {
							value: []
						},
						hemisphereLights: {
							value: [],
							properties: {
								direction: {},
								skyColor: {},
								groundColor: {}
							}
						},
						rectAreaLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								width: {},
								height: {}
							}
						},
						ltc_1: {
							value: null
						},
						ltc_2: {
							value: null
						}
					},
					points: {
						diffuse: {
							value: new Ei(16777215)
						},
						opacity: {
							value: 1
						},
						size: {
							value: 1
						},
						scale: {
							value: 1
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						},
						uvTransform: {
							value: new Vn
						}
					},
					sprite: {
						diffuse: {
							value: new Ei(16777215)
						},
						opacity: {
							value: 1
						},
						center: {
							value: new zn(.5, .5)
						},
						rotation: {
							value: 0
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						},
						uvTransform: {
							value: new Vn
						}
					}
				},
				Ns = {
					basic: {
						uniforms: gs([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.fog]),
						vertexShader: Fs.meshbasic_vert,
						fragmentShader: Fs.meshbasic_frag
					},
					lambert: {
						uniforms: gs([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.fog, Os.lights, {
							emissive: {
								value: new Ei(0)
							}
						}]),
						vertexShader: Fs.meshlambert_vert,
						fragmentShader: Fs.meshlambert_frag
					},
					phong: {
						uniforms: gs([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, Os.lights, {
							emissive: {
								value: new Ei(0)
							},
							specular: {
								value: new Ei(1118481)
							},
							shininess: {
								value: 30
							}
						}]),
						vertexShader: Fs.meshphong_vert,
						fragmentShader: Fs.meshphong_frag
					},
					standard: {
						uniforms: gs([Os.common, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.roughnessmap, Os.metalnessmap, Os.fog, Os.lights, {
							emissive: {
								value: new Ei(0)
							},
							roughness: {
								value: 1
							},
							metalness: {
								value: 0
							},
							envMapIntensity: {
								value: 1
							}
						}]),
						vertexShader: Fs.meshphysical_vert,
						fragmentShader: Fs.meshphysical_frag
					},
					toon: {
						uniforms: gs([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.gradientmap, Os.fog, Os.lights, {
							emissive: {
								value: new Ei(0)
							}
						}]),
						vertexShader: Fs.meshtoon_vert,
						fragmentShader: Fs.meshtoon_frag
					},
					matcap: {
						uniforms: gs([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, {
							matcap: {
								value: null
							}
						}]),
						vertexShader: Fs.meshmatcap_vert,
						fragmentShader: Fs.meshmatcap_frag
					},
					points: {
						uniforms: gs([Os.points, Os.fog]),
						vertexShader: Fs.points_vert,
						fragmentShader: Fs.points_frag
					},
					dashed: {
						uniforms: gs([Os.common, Os.fog, {
							scale: {
								value: 1
							},
							dashSize: {
								value: 1
							},
							totalSize: {
								value: 2
							}
						}]),
						vertexShader: Fs.linedashed_vert,
						fragmentShader: Fs.linedashed_frag
					},
					depth: {
						uniforms: gs([Os.common, Os.displacementmap]),
						vertexShader: Fs.depth_vert,
						fragmentShader: Fs.depth_frag
					},
					normal: {
						uniforms: gs([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Fs.meshnormal_vert,
						fragmentShader: Fs.meshnormal_frag
					},
					sprite: {
						uniforms: gs([Os.sprite, Os.fog]),
						vertexShader: Fs.sprite_vert,
						fragmentShader: Fs.sprite_frag
					},
					background: {
						uniforms: {
							uvTransform: {
								value: new Vn
							},
							t2D: {
								value: null
							}
						},
						vertexShader: Fs.background_vert,
						fragmentShader: Fs.background_frag
					},
					cube: {
						uniforms: gs([Os.envmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Fs.cube_vert,
						fragmentShader: Fs.cube_frag
					},
					equirect: {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: Fs.equirect_vert,
						fragmentShader: Fs.equirect_frag
					},
					distanceRGBA: {
						uniforms: gs([Os.common, Os.displacementmap, {
							referencePosition: {
								value: new ir
							},
							nearDistance: {
								value: 1
							},
							farDistance: {
								value: 1e3
							}
						}]),
						vertexShader: Fs.distanceRGBA_vert,
						fragmentShader: Fs.distanceRGBA_frag
					},
					shadow: {
						uniforms: gs([Os.lights, Os.fog, {
							color: {
								value: new Ei(0)
							},
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Fs.shadow_vert,
						fragmentShader: Fs.shadow_frag
					}
				};

			function Hs(e, t, n, r, i) {
				const s = new Ei(0);
				let a, o, l = 0,
					c = null,
					u = 0,
					h = null;

				function d(e, t) {
					n.buffers.color.setClear(e.r, e.g, e.b, t, i)
				}
				return {
					getClearColor: function() {
						return s
					},
					setClearColor: function(e, t = 1) {
						s.set(e), l = t, d(s, l)
					},
					getClearAlpha: function() {
						return l
					},
					setClearAlpha: function(e) {
						l = e, d(s, l)
					},
					render: function(n, i) {
						let p = !1,
							g = !0 === i.isScene ? i.background : null;
						g && g.isTexture && (g = t.get(g));
						const v = e.xr,
							y = v.getSession && v.getSession();
						y && "additive" === y.environmentBlendMode && (g = null), null === g ? d(s, l) : g && g.isColor && (d(g, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), g && (g.isCubeTexture || g.mapping === ce) ? (void 0 === o && (o = new ds(new fs(1, 1, 1), new ys({
							name: "BackgroundCubeMaterial",
							uniforms: ms(Ns.cube.uniforms),
							vertexShader: Ns.cube.vertexShader,
							fragmentShader: Ns.cube.fragmentShader,
							side: m,
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), o.geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function(e, t, n) {
							this.matrixWorld.copyPosition(n.matrixWorld)
						}, Object.defineProperty(o.material, "envMap", {
							get: function() {
								return this.uniforms.envMap.value
							}
						}), r.update(o)), o.material.uniforms.envMap.value = g, o.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, c === g && u === g.version && h === e.toneMapping || (o.material.needsUpdate = !0, c = g, u = g.version, h = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : g && g.isTexture && (void 0 === a && (a = new ds(new Ds(2, 2), new ys({
							name: "BackgroundMaterial",
							uniforms: ms(Ns.background.uniforms),
							vertexShader: Ns.background.vertexShader,
							fragmentShader: Ns.background.fragmentShader,
							side: f,
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
							get: function() {
								return this.uniforms.t2D.value
							}
						}), r.update(a)), a.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), a.material.uniforms.uvTransform.value.copy(g.matrix), c === g && u === g.version && h === e.toneMapping || (a.material.needsUpdate = !0, c = g, u = g.version, h = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
					}
				}
			}

			function ks(e, t, n, r) {
				const i = e.getParameter(34921),
					s = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
					a = r.isWebGL2 || null !== s,
					o = {},
					l = d(null);
				let c = l;

				function u(t) {
					return r.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
				}

				function h(t) {
					return r.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
				}

				function d(e) {
					const t = [],
						n = [],
						r = [];
					for (let s = 0; s < i; s++) t[s] = 0, n[s] = 0, r[s] = 0;
					return {
						geometry: null,
						program: null,
						wireframe: !1,
						newAttributes: t,
						enabledAttributes: n,
						attributeDivisors: r,
						object: e,
						attributes: {},
						index: null
					}
				}

				function p() {
					const e = c.newAttributes;
					for (let t = 0, n = e.length; t < n; t++) e[t] = 0
				}

				function f(e) {
					m(e, 0)
				}

				function m(n, i) {
					const s = c.newAttributes,
						a = c.enabledAttributes,
						o = c.attributeDivisors;
					if (s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== i) {
						(r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), o[n] = i
					}
				}

				function g() {
					const t = c.newAttributes,
						n = c.enabledAttributes;
					for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
				}

				function v(t, n, i, s, a, o) {
					!0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, s, a, o) : e.vertexAttribIPointer(t, n, i, a, o)
				}

				function y() {
					x(), c !== l && (c = l, u(c.object))
				}

				function x() {
					l.geometry = null, l.program = null, l.wireframe = !1
				}
				return {
					setup: function(i, l, h, y, x) {
						let _ = !1;
						if (a) {
							const t = function(t, n, i) {
								const a = !0 === i.wireframe;
								let l = o[t.id];
								void 0 === l && (l = {}, o[t.id] = l);
								let c = l[n.id];
								void 0 === c && (c = {}, l[n.id] = c);
								let u = c[a];
								void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = u);
								return u
							}(y, h, l);
							c !== t && (c = t, u(c.object)), _ = function(e, t) {
								const n = c.attributes,
									r = e.attributes;
								let i = 0;
								for (const s in r) {
									const e = n[s],
										t = r[s];
									if (void 0 === e) return !0;
									if (e.attribute !== t) return !0;
									if (e.data !== t.data) return !0;
									i++
								}
								return c.attributesNum !== i || c.index !== t
							}(y, x), _ && function(e, t) {
								const n = {},
									r = e.attributes;
								let i = 0;
								for (const s in r) {
									const e = r[s],
										t = {};
									t.attribute = e, e.data && (t.data = e.data), n[s] = t, i++
								}
								c.attributes = n, c.attributesNum = i, c.index = t
							}(y, x)
						} else {
							const e = !0 === l.wireframe;
							c.geometry === y.id && c.program === h.id && c.wireframe === e || (c.geometry = y.id, c.program = h.id, c.wireframe = e, _ = !0)
						}!0 === i.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (! function(i, s, a, o) {
							if (!1 === r.isWebGL2 && (i.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
							p();
							const l = o.attributes,
								c = a.getAttributes(),
								u = s.defaultAttributeValues;
							for (const t in c) {
								const r = c[t];
								if (r.location >= 0) {
									let s = l[t];
									if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (s = i.instanceColor)), void 0 !== s) {
										const t = s.normalized,
											a = s.itemSize,
											l = n.get(s);
										if (void 0 === l) continue;
										const c = l.buffer,
											u = l.type,
											h = l.bytesPerElement;
										if (s.isInterleavedBufferAttribute) {
											const n = s.data,
												l = n.stride,
												d = s.offset;
											if (n && n.isInstancedInterleavedBuffer) {
												for (let e = 0; e < r.locationSize; e++) m(r.location + e, n.meshPerAttribute);
												!0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
											} else
												for (let e = 0; e < r.locationSize; e++) f(r.location + e);
											e.bindBuffer(34962, c);
											for (let e = 0; e < r.locationSize; e++) v(r.location + e, a / r.locationSize, u, t, l * h, (d + a / r.locationSize * e) * h)
										} else {
											if (s.isInstancedBufferAttribute) {
												for (let e = 0; e < r.locationSize; e++) m(r.location + e, s.meshPerAttribute);
												!0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
											} else
												for (let e = 0; e < r.locationSize; e++) f(r.location + e);
											e.bindBuffer(34962, c);
											for (let e = 0; e < r.locationSize; e++) v(r.location + e, a / r.locationSize, u, t, a * h, a / r.locationSize * e * h)
										}
									} else if (void 0 !== u) {
										const n = u[t];
										if (void 0 !== n) switch (n.length) {
											case 2:
												e.vertexAttrib2fv(r.location, n);
												break;
											case 3:
												e.vertexAttrib3fv(r.location, n);
												break;
											case 4:
												e.vertexAttrib4fv(r.location, n);
												break;
											default:
												e.vertexAttrib1fv(r.location, n)
										}
									}
								}
							}
							g()
						}(i, l, h, y), null !== x && e.bindBuffer(34963, n.get(x).buffer))
					},
					reset: y,
					resetDefaultState: x,
					dispose: function() {
						y();
						for (const e in o) {
							const t = o[e];
							for (const e in t) {
								const n = t[e];
								for (const e in n) h(n[e].object), delete n[e];
								delete t[e]
							}
							delete o[e]
						}
					},
					releaseStatesOfGeometry: function(e) {
						if (void 0 === o[e.id]) return;
						const t = o[e.id];
						for (const n in t) {
							const e = t[n];
							for (const t in e) h(e[t].object), delete e[t];
							delete t[n]
						}
						delete o[e.id]
					},
					releaseStatesOfProgram: function(e) {
						for (const t in o) {
							const n = o[t];
							if (void 0 === n[e.id]) continue;
							const r = n[e.id];
							for (const e in r) h(r[e].object), delete r[e];
							delete n[e.id]
						}
					},
					initAttributes: p,
					enableAttribute: f,
					disableUnusedAttributes: g
				}
			}

			function Gs(e, t, n, r) {
				const i = r.isWebGL2;
				let s;
				this.setMode = function(e) {
					s = e
				}, this.render = function(t, r) {
					e.drawArrays(s, t, r), n.update(r, s, 1)
				}, this.renderInstances = function(r, a, o) {
					if (0 === o) return;
					let l, c;
					if (i) l = e, c = "drawArraysInstanced";
					else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					l[c](s, r, a, o), n.update(a, s, o)
				}
			}

			function Us(e, t, n) {
				let r;

				function i(t) {
					if ("highp" === t) {
						if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
						t = "mediump"
					}
					return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
				}
				const s = "undefined" !== typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
				let a = void 0 !== n.precision ? n.precision : "highp";
				const o = i(a);
				o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
				const l = s || t.has("WEBGL_draw_buffers"),
					c = !0 === n.logarithmicDepthBuffer,
					u = e.getParameter(34930),
					h = e.getParameter(35660),
					d = e.getParameter(3379),
					p = e.getParameter(34076),
					f = e.getParameter(34921),
					m = e.getParameter(36347),
					g = e.getParameter(36348),
					v = e.getParameter(36349),
					y = h > 0,
					x = s || t.has("OES_texture_float");
				return {
					isWebGL2: s,
					drawBuffers: l,
					getMaxAnisotropy: function() {
						if (void 0 !== r) return r;
						if (!0 === t.has("EXT_texture_filter_anisotropic")) {
							const n = t.get("EXT_texture_filter_anisotropic");
							r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
						} else r = 0;
						return r
					},
					getMaxPrecision: i,
					precision: a,
					logarithmicDepthBuffer: c,
					maxTextures: u,
					maxVertexTextures: h,
					maxTextureSize: d,
					maxCubemapSize: p,
					maxAttributes: f,
					maxVertexUniforms: m,
					maxVaryings: g,
					maxFragmentUniforms: v,
					vertexTextures: y,
					floatFragmentTextures: x,
					floatVertexTextures: y && x,
					maxSamples: s ? e.getParameter(36183) : 0
				}
			}

			function zs(e) {
				const t = this;
				let n = null,
					r = 0,
					i = !1,
					s = !1;
				const a = new Cs,
					o = new Vn,
					l = {
						value: null,
						needsUpdate: !1
					};

				function c() {
					l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0
				}

				function u(e, n, r, i) {
					const s = null !== e ? e.length : 0;
					let c = null;
					if (0 !== s) {
						if (c = l.value, !0 !== i || null === c) {
							const t = r + 4 * s,
								i = n.matrixWorldInverse;
							o.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t));
							for (let n = 0, l = r; n !== s; ++n, l += 4) a.copy(e[n]).applyMatrix4(i, o), a.normal.toArray(c, l), c[l + 3] = a.constant
						}
						l.value = c, l.needsUpdate = !0
					}
					return t.numPlanes = s, t.numIntersection = 0, c
				}
				this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, s) {
					const a = 0 !== e.length || t || 0 !== r || i;
					return i = t, n = u(e, s, 0), r = e.length, a
				}, this.beginShadows = function() {
					s = !0, u(null)
				}, this.endShadows = function() {
					s = !1, c()
				}, this.setState = function(t, a, o) {
					const h = t.clippingPlanes,
						d = t.clipIntersection,
						p = t.clipShadows,
						f = e.get(t);
					if (!i || null === h || 0 === h.length || s && !p) s ? u(null) : c();
					else {
						const e = s ? 0 : r,
							t = 4 * e;
						let i = f.clippingState || null;
						l.value = i, i = u(h, a, t, o);
						for (let r = 0; r !== t; ++r) i[r] = n[r];
						f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
					}
				}
			}

			function Vs(e) {
				let t = new WeakMap;

				function n(e, t) {
					return t === oe ? e.mapping = se : t === le && (e.mapping = ae), e
				}

				function r(e) {
					const n = e.target;
					n.removeEventListener("dispose", r);
					const i = t.get(n);
					void 0 !== i && (t.delete(n), i.dispose())
				}
				return {
					get: function(i) {
						if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
							const s = i.mapping;
							if (s === oe || s === le) {
								if (t.has(i)) {
									return n(t.get(i).texture, i.mapping)
								} {
									const s = i.image;
									if (s && s.height > 0) {
										const a = e.getRenderTarget(),
											o = new As(s.height / 2);
										return o.fromEquirectangularTexture(e, i), t.set(i, o), e.setRenderTarget(a), i.addEventListener("dispose", r), n(o.texture, i.mapping)
									}
									return null
								}
							}
						}
						return i
					},
					dispose: function() {
						t = new WeakMap
					}
				}
			}
			Ns.physical = {
				uniforms: gs([Ns.standard.uniforms, {
					clearcoat: {
						value: 0
					},
					clearcoatMap: {
						value: null
					},
					clearcoatRoughness: {
						value: 0
					},
					clearcoatRoughnessMap: {
						value: null
					},
					clearcoatNormalScale: {
						value: new zn(1, 1)
					},
					clearcoatNormalMap: {
						value: null
					},
					sheen: {
						value: 0
					},
					sheenColor: {
						value: new Ei(0)
					},
					sheenColorMap: {
						value: null
					},
					sheenRoughness: {
						value: 0
					},
					sheenRoughnessMap: {
						value: null
					},
					transmission: {
						value: 0
					},
					transmissionMap: {
						value: null
					},
					transmissionSamplerSize: {
						value: new zn
					},
					transmissionSamplerMap: {
						value: null
					},
					thickness: {
						value: 0
					},
					thicknessMap: {
						value: null
					},
					attenuationDistance: {
						value: 0
					},
					attenuationColor: {
						value: new Ei(0)
					},
					specularIntensity: {
						value: 0
					},
					specularIntensityMap: {
						value: null
					},
					specularColor: {
						value: new Ei(1, 1, 1)
					},
					specularColorMap: {
						value: null
					}
				}]),
				vertexShader: Fs.meshphysical_vert,
				fragmentShader: Fs.meshphysical_frag
			};
			class Ws extends xs {
				constructor(e = -1, t = 1, n = 1, r = -1, i = .1, s = 2e3) {
					super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix()
				}
				copy(e, t) {
					return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
				}
				setViewOffset(e, t, n, r, i, s) {
					null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
				}
				clearViewOffset() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				}
				updateProjectionMatrix() {
					const e = (this.right - this.left) / (2 * this.zoom),
						t = (this.top - this.bottom) / (2 * this.zoom),
						n = (this.right + this.left) / 2,
						r = (this.top + this.bottom) / 2;
					let i = n - e,
						s = n + e,
						a = r + t,
						o = r - t;
					if (null !== this.view && this.view.enabled) {
						const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
							t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
						i += e * this.view.offsetX, s = i + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
					}
					this.projectionMatrix.makeOrthographic(i, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
				}
			}
			Ws.prototype.isOrthographicCamera = !0;
			class js extends ys {
				constructor(e) {
					super(e), this.type = "RawShaderMaterial"
				}
			}
			js.prototype.isRawShaderMaterial = !0;
			const Js = Math.pow(2, 8),
				Xs = [.125, .215, .35, .446, .526, .582],
				qs = 5 + Xs.length,
				Ks = 20,
				Ys = {
					[Kt]: 0,
					[Yt]: 1
				},
				Qs = new Ws,
				{
					_lodPlanes: Zs,
					_sizeLods: $s,
					_sigmas: ea
				} = oa(),
				ta = new Ei;
			let na = null;
			const ra = (1 + Math.sqrt(5)) / 2,
				ia = 1 / ra,
				sa = [new ir(1, 1, 1), new ir(-1, 1, 1), new ir(1, 1, -1), new ir(-1, 1, -1), new ir(0, ra, ia), new ir(0, ra, -ia), new ir(ia, 0, ra), new ir(-ia, 0, ra), new ir(ra, ia, 0), new ir(-ra, ia, 0)];
			class aa {
				constructor(e) {
					this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function(e) {
						const t = new Float32Array(e),
							n = new ir(0, 1, 0);
						return new js({
							name: "SphericalGaussianBlur",
							defines: {
								n: e
							},
							uniforms: {
								envMap: {
									value: null
								},
								samples: {
									value: 1
								},
								weights: {
									value: t
								},
								latitudinal: {
									value: !1
								},
								dTheta: {
									value: 0
								},
								mipInt: {
									value: 0
								},
								poleAxis: {
									value: n
								}
							},
							vertexShader: da(),
							fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${pa()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,
							blending: x,
							depthTest: !1,
							depthWrite: !1
						})
					}(Ks), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
				}
				fromScene(e, t = 0, n = .1, r = 100) {
					na = this._renderer.getRenderTarget();
					const i = this._allocateTargets();
					return this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
				}
				fromEquirectangular(e) {
					return this._fromTexture(e)
				}
				fromCubemap(e) {
					return this._fromTexture(e)
				}
				compileCubemapShader() {
					null === this._cubemapShader && (this._cubemapShader = ha(), this._compileMaterial(this._cubemapShader))
				}
				compileEquirectangularShader() {
					null === this._equirectShader && (this._equirectShader = ua(), this._compileMaterial(this._equirectShader))
				}
				dispose() {
					this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
					for (let e = 0; e < Zs.length; e++) Zs[e].dispose()
				}
				_cleanup(e) {
					this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(na), e.scissorTest = !1, ca(e, 0, 0, e.width, e.height)
				}
				_fromTexture(e) {
					na = this._renderer.getRenderTarget();
					const t = this._allocateTargets(e);
					return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
				}
				_allocateTargets(e) {
					const t = {
							magFilter: xe,
							minFilter: xe,
							generateMipmaps: !1,
							type: Le,
							format: He,
							encoding: Kt,
							depthBuffer: !1
						},
						n = la(t);
					return n.depthBuffer = !e, this._pingPongRenderTarget = la(t), n
				}
				_compileMaterial(e) {
					const t = new ds(Zs[0], e);
					this._renderer.compile(t, Qs)
				}
				_sceneToCubeUV(e, t, n, r) {
					const i = new _s(90, 1, t, n),
						s = [1, -1, 1, 1, 1, 1],
						a = [1, 1, 1, -1, -1, -1],
						o = this._renderer,
						l = o.autoClear,
						c = o.toneMapping;
					o.getClearColor(ta), o.toneMapping = Z, o.autoClear = !1;
					const u = new Ti({
							name: "PMREM.Background",
							side: m,
							depthWrite: !1,
							depthTest: !1
						}),
						h = new ds(new fs, u);
					let d = !1;
					const p = e.background;
					p ? p.isColor && (u.color.copy(p), e.background = null, d = !0) : (u.color.copy(ta), d = !0);
					for (let f = 0; f < 6; f++) {
						const t = f % 3;
						0 == t ? (i.up.set(0, s[f], 0), i.lookAt(a[f], 0, 0)) : 1 == t ? (i.up.set(0, 0, s[f]), i.lookAt(0, a[f], 0)) : (i.up.set(0, s[f], 0), i.lookAt(0, 0, a[f])), ca(r, t * Js, f > 2 ? Js : 0, Js, Js), o.setRenderTarget(r), d && o.render(h, i), o.render(e, i)
					}
					h.geometry.dispose(), h.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p
				}
				_setEncoding(e, t) {
					!0 === this._renderer.capabilities.isWebGL2 && t.format === He && t.type === Ae && t.encoding === Yt ? e.value = Ys[Kt] : e.value = Ys[t.encoding]
				}
				_textureToCubeUV(e, t) {
					const n = this._renderer,
						r = e.mapping === se || e.mapping === ae;
					r ? null == this._cubemapShader && (this._cubemapShader = ha()) : null == this._equirectShader && (this._equirectShader = ua());
					const i = r ? this._cubemapShader : this._equirectShader,
						s = new ds(Zs[0], i),
						a = i.uniforms;
					a.envMap.value = e, r || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(a.inputEncoding, e), ca(t, 0, 0, 3 * Js, 2 * Js), n.setRenderTarget(t), n.render(s, Qs)
				}
				_applyPMREM(e) {
					const t = this._renderer,
						n = t.autoClear;
					t.autoClear = !1;
					for (let r = 1; r < qs; r++) {
						const t = Math.sqrt(ea[r] * ea[r] - ea[r - 1] * ea[r - 1]),
							n = sa[(r - 1) % sa.length];
						this._blur(e, r - 1, r, t, n)
					}
					t.autoClear = n
				}
				_blur(e, t, n, r, i) {
					const s = this._pingPongRenderTarget;
					this._halfBlur(e, s, t, n, r, "latitudinal", i), this._halfBlur(s, e, n, n, r, "longitudinal", i)
				}
				_halfBlur(e, t, n, r, i, s, a) {
					const o = this._renderer,
						l = this._blurMaterial;
					"latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
					const c = new ds(Zs[r], l),
						u = l.uniforms,
						h = $s[n] - 1,
						d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
						p = i / d,
						f = isFinite(i) ? 1 + Math.floor(3 * p) : Ks;
					f > Ks && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
					const m = [];
					let g = 0;
					for (let y = 0; y < Ks; ++y) {
						const e = y / p,
							t = Math.exp(-e * e / 2);
						m.push(t), 0 == y ? g += t : y < f && (g += 2 * t)
					}
					for (let y = 0; y < m.length; y++) m[y] = m[y] / g;
					u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, a && (u.poleAxis.value = a), u.dTheta.value = d, u.mipInt.value = 8 - n;
					const v = $s[r];
					ca(t, 3 * Math.max(0, Js - 2 * v), (0 === r ? 0 : 2 * Js) + 2 * v * (r > 4 ? r - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, Qs)
				}
			}

			function oa() {
				const e = [],
					t = [],
					n = [];
				let r = 8;
				for (let i = 0; i < qs; i++) {
					const s = Math.pow(2, r);
					t.push(s);
					let a = 1 / s;
					i > 4 ? a = Xs[i - 8 + 4 - 1] : 0 == i && (a = 0), n.push(a);
					const o = 1 / (s - 1),
						l = -o / 2,
						c = 1 + o / 2,
						u = [l, l, c, l, c, c, l, l, c, c, l, c],
						h = 6,
						d = 6,
						p = 3,
						f = 2,
						m = 1,
						g = new Float32Array(p * d * h),
						v = new Float32Array(f * d * h),
						y = new Float32Array(m * d * h);
					for (let e = 0; e < h; e++) {
						const t = e % 3 * 2 / 3 - 1,
							n = e > 2 ? 0 : -1,
							r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
						g.set(r, p * d * e), v.set(u, f * d * e);
						const i = [e, e, e, e, e, e];
						y.set(i, m * d * e)
					}
					const x = new qi;
					x.setAttribute("position", new Ri(g, p)), x.setAttribute("uv", new Ri(v, f)), x.setAttribute("faceIndex", new Ri(y, m)), e.push(x), r > 4 && r--
				}
				return {
					_lodPlanes: e,
					_sizeLods: t,
					_sigmas: n
				}
			}

			function la(e) {
				const t = new er(3 * Js, 3 * Js, e);
				return t.texture.mapping = ce, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
			}

			function ca(e, t, n, r, i) {
				e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
			}

			function ua() {
				const e = new zn(1, 1);
				return new js({
					name: "EquirectangularToCubeUV",
					uniforms: {
						envMap: {
							value: null
						},
						texelSize: {
							value: e
						},
						inputEncoding: {
							value: Ys[Kt]
						}
					},
					vertexShader: da(),
					fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${pa()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t`,
					blending: x,
					depthTest: !1,
					depthWrite: !1
				})
			}

			function ha() {
				return new js({
					name: "CubemapToCubeUV",
					uniforms: {
						envMap: {
							value: null
						},
						inputEncoding: {
							value: Ys[Kt]
						}
					},
					vertexShader: da(),
					fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${pa()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n\t\t\t}\n\t\t`,
					blending: x,
					depthTest: !1,
					depthWrite: !1
				})
			}

			function da() {
				return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
			}

			function pa() {
				return "\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
			}

			function fa(e) {
				let t = new WeakMap,
					n = null;

				function r(e) {
					const n = e.target;
					n.removeEventListener("dispose", r);
					const i = t.get(n);
					void 0 !== i && (t.delete(n), i.dispose())
				}
				return {
					get: function(i) {
						if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
							const s = i.mapping,
								a = s === oe || s === le,
								o = s === se || s === ae;
							if (a || o) {
								if (t.has(i)) return t.get(i).texture; {
									const s = i.image;
									if (a && s && s.height > 0 || o && s && function(e) {
											let t = 0;
											const n = 6;
											for (let r = 0; r < n; r++) void 0 !== e[r] && t++;
											return t === n
										}(s)) {
										const s = e.getRenderTarget();
										null === n && (n = new aa(e));
										const o = a ? n.fromEquirectangular(i) : n.fromCubemap(i);
										return t.set(i, o), e.setRenderTarget(s), i.addEventListener("dispose", r), o.texture
									}
									return null
								}
							}
						}
						return i
					},
					dispose: function() {
						t = new WeakMap, null !== n && (n.dispose(), n = null)
					}
				}
			}

			function ma(e) {
				const t = {};

				function n(n) {
					if (void 0 !== t[n]) return t[n];
					let r;
					switch (n) {
						case "WEBGL_depth_texture":
							r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
							break;
						case "EXT_texture_filter_anisotropic":
							r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
							break;
						case "WEBGL_compressed_texture_s3tc":
							r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
							break;
						case "WEBGL_compressed_texture_pvrtc":
							r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
							break;
						default:
							r = e.getExtension(n)
					}
					return t[n] = r, r
				}
				return {
					has: function(e) {
						return null !== n(e)
					},
					init: function(e) {
						e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
					},
					get: function(e) {
						const t = n(e);
						return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
					}
				}
			}

			function ga(e, t, n, r) {
				const i = {},
					s = new WeakMap;

				function a(e) {
					const o = e.target;
					null !== o.index && t.remove(o.index);
					for (const n in o.attributes) t.remove(o.attributes[n]);
					o.removeEventListener("dispose", a), delete i[o.id];
					const l = s.get(o);
					l && (t.remove(l), s.delete(o)), r.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
				}

				function o(e) {
					const n = [],
						r = e.index,
						i = e.attributes.position;
					let a = 0;
					if (null !== r) {
						const e = r.array;
						a = r.version;
						for (let t = 0, r = e.length; t < r; t += 3) {
							const r = e[t + 0],
								i = e[t + 1],
								s = e[t + 2];
							n.push(r, i, i, s, s, r)
						}
					} else {
						const e = i.array;
						a = i.version;
						for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
							const e = t + 0,
								r = t + 1,
								i = t + 2;
							n.push(e, r, r, i, i, e)
						}
					}
					const o = new(Wn(n) > 65535 ? Ni : Fi)(n, 1);
					o.version = a;
					const l = s.get(e);
					l && t.remove(l), s.set(e, o)
				}
				return {
					get: function(e, t) {
						return !0 === i[t.id] || (t.addEventListener("dispose", a), i[t.id] = !0, n.memory.geometries++), t
					},
					update: function(e) {
						const n = e.attributes;
						for (const i in n) t.update(n[i], 34962);
						const r = e.morphAttributes;
						for (const i in r) {
							const e = r[i];
							for (let n = 0, r = e.length; n < r; n++) t.update(e[n], 34962)
						}
					},
					getWireframeAttribute: function(e) {
						const t = s.get(e);
						if (t) {
							const n = e.index;
							null !== n && t.version < n.version && o(e)
						} else o(e);
						return s.get(e)
					}
				}
			}

			function va(e, t, n, r) {
				const i = r.isWebGL2;
				let s, a, o;
				this.setMode = function(e) {
					s = e
				}, this.setIndex = function(e) {
					a = e.type, o = e.bytesPerElement
				}, this.render = function(t, r) {
					e.drawElements(s, r, a, t * o), n.update(r, s, 1)
				}, this.renderInstances = function(r, l, c) {
					if (0 === c) return;
					let u, h;
					if (i) u = e, h = "drawElementsInstanced";
					else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					u[h](s, l, a, r * o, c), n.update(l, s, c)
				}
			}

			function ya(e) {
				const t = {
					frame: 0,
					calls: 0,
					triangles: 0,
					points: 0,
					lines: 0
				};
				return {
					memory: {
						geometries: 0,
						textures: 0
					},
					render: t,
					programs: null,
					autoReset: !0,
					reset: function() {
						t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
					},
					update: function(e, n, r) {
						switch (t.calls++, n) {
							case 4:
								t.triangles += r * (e / 3);
								break;
							case 1:
								t.lines += r * (e / 2);
								break;
							case 3:
								t.lines += r * (e - 1);
								break;
							case 2:
								t.lines += r * e;
								break;
							case 0:
								t.points += r * e;
								break;
							default:
								console.error("THREE.WebGLInfo: Unknown draw mode:", n)
						}
					}
				}
			}
			class xa extends Qn {
				constructor(e = null, t = 1, n = 1, r = 1) {
					super(null), this.image = {
						data: e,
						width: t,
						height: n,
						depth: r
					}, this.magFilter = fe, this.minFilter = fe, this.wrapR = de, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}

			function _a(e, t) {
				return e[0] - t[0]
			}

			function ba(e, t) {
				return Math.abs(t[1]) - Math.abs(e[1])
			}

			function wa(e, t) {
				let n = 1;
				const r = t.isInterleavedBufferAttribute ? t.data.array : t.array;
				r instanceof Int8Array ? n = 127 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), e.divideScalar(n)
			}

			function Ma(e, t, n) {
				const r = {},
					i = new Float32Array(8),
					s = new WeakMap,
					a = new ir,
					o = [];
				for (let l = 0; l < 8; l++) o[l] = [l, 0];
				return {
					update: function(l, c, u, h) {
						const d = l.morphTargetInfluences;
						if (!0 === t.isWebGL2) {
							const r = c.morphAttributes.position.length;
							let i = s.get(c);
							if (void 0 === i || i.count !== r) {
								void 0 !== i && i.texture.dispose();
								const e = void 0 !== c.morphAttributes.normal,
									n = c.morphAttributes.position,
									o = c.morphAttributes.normal || [],
									l = !0 === e ? 2 : 1;
								let u = c.attributes.position.count * l,
									h = 1;
								u > t.maxTextureSize && (h = Math.ceil(u / t.maxTextureSize), u = t.maxTextureSize);
								const d = new Float32Array(u * h * 4 * r),
									p = new xa(d, u, h, r);
								p.format = He, p.type = Re, p.needsUpdate = !0;
								const f = 4 * l;
								for (let t = 0; t < r; t++) {
									const r = n[t],
										i = o[t],
										s = u * h * 4 * t;
									for (let t = 0; t < r.count; t++) {
										a.fromBufferAttribute(r, t), !0 === r.normalized && wa(a, r);
										const n = t * f;
										d[s + n + 0] = a.x, d[s + n + 1] = a.y, d[s + n + 2] = a.z, d[s + n + 3] = 0, !0 === e && (a.fromBufferAttribute(i, t), !0 === i.normalized && wa(a, i), d[s + n + 4] = a.x, d[s + n + 5] = a.y, d[s + n + 6] = a.z, d[s + n + 7] = 0)
									}
								}
								i = {
									count: r,
									texture: p,
									size: new zn(u, h)
								}, s.set(c, i)
							}
							let o = 0;
							for (let e = 0; e < d.length; e++) o += d[e];
							const l = c.morphTargetsRelative ? 1 : 1 - o;
							h.getUniforms().setValue(e, "morphTargetBaseInfluence", l), h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", i.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", i.size)
						} else {
							const t = void 0 === d ? 0 : d.length;
							let n = r[c.id];
							if (void 0 === n || n.length !== t) {
								n = [];
								for (let e = 0; e < t; e++) n[e] = [e, 0];
								r[c.id] = n
							}
							for (let e = 0; e < t; e++) {
								const t = n[e];
								t[0] = e, t[1] = d[e]
							}
							n.sort(ba);
							for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
							o.sort(_a);
							const s = c.morphAttributes.position,
								a = c.morphAttributes.normal;
							let l = 0;
							for (let e = 0; e < 8; e++) {
								const t = o[e],
									n = t[0],
									r = t[1];
								n !== Number.MAX_SAFE_INTEGER && r ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]), i[e] = r, l += r) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), i[e] = 0)
							}
							const u = c.morphTargetsRelative ? 1 : 1 - l;
							h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", i)
						}
					}
				}
			}

			function Aa(e, t, n, r) {
				let i = new WeakMap;

				function s(e) {
					const t = e.target;
					t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
				}
				return {
					update: function(e) {
						const a = r.render.frame,
							o = e.geometry,
							l = t.get(e, o);
						return i.get(l) !== a && (t.update(l), i.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
					},
					dispose: function() {
						i = new WeakMap
					}
				}
			}
			xa.prototype.isDataTexture2DArray = !0;
			class Sa extends Qn {
				constructor(e = null, t = 1, n = 1, r = 1) {
					super(null), this.image = {
						data: e,
						width: t,
						height: n,
						depth: r
					}, this.magFilter = fe, this.minFilter = fe, this.wrapR = de, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}
			Sa.prototype.isDataTexture3D = !0;
			const Ea = new Qn,
				Ta = new xa,
				Ca = new Sa,
				Ba = new Ms,
				Ra = [],
				La = [],
				Ia = new Float32Array(16),
				Pa = new Float32Array(9),
				Da = new Float32Array(4);

			function Fa(e, t, n) {
				const r = e[0];
				if (r <= 0 || r > 0) return e;
				const i = t * n;
				let s = Ra[i];
				if (void 0 === s && (s = new Float32Array(i), Ra[i] = s), 0 !== t) {
					r.toArray(s, 0);
					for (let r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(s, i)
				}
				return s
			}

			function Oa(e, t) {
				if (e.length !== t.length) return !1;
				for (let n = 0, r = e.length; n < r; n++)
					if (e[n] !== t[n]) return !1;
				return !0
			}

			function Na(e, t) {
				for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
			}

			function Ha(e, t) {
				let n = La[t];
				void 0 === n && (n = new Int32Array(t), La[t] = n);
				for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
				return n
			}

			function ka(e, t) {
				const n = this.cache;
				n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
			}

			function Ga(e, t) {
				const n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
				else {
					if (Oa(n, t)) return;
					e.uniform2fv(this.addr, t), Na(n, t)
				}
			}

			function Ua(e, t) {
				const n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
				else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
				else {
					if (Oa(n, t)) return;
					e.uniform3fv(this.addr, t), Na(n, t)
				}
			}

			function za(e, t) {
				const n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
				else {
					if (Oa(n, t)) return;
					e.uniform4fv(this.addr, t), Na(n, t)
				}
			}

			function Va(e, t) {
				const n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (Oa(n, t)) return;
					e.uniformMatrix2fv(this.addr, !1, t), Na(n, t)
				} else {
					if (Oa(n, r)) return;
					Da.set(r), e.uniformMatrix2fv(this.addr, !1, Da), Na(n, r)
				}
			}

			function Wa(e, t) {
				const n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (Oa(n, t)) return;
					e.uniformMatrix3fv(this.addr, !1, t), Na(n, t)
				} else {
					if (Oa(n, r)) return;
					Pa.set(r), e.uniformMatrix3fv(this.addr, !1, Pa), Na(n, r)
				}
			}

			function ja(e, t) {
				const n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (Oa(n, t)) return;
					e.uniformMatrix4fv(this.addr, !1, t), Na(n, t)
				} else {
					if (Oa(n, r)) return;
					Ia.set(r), e.uniformMatrix4fv(this.addr, !1, Ia), Na(n, r)
				}
			}

			function Ja(e, t) {
				const n = this.cache;
				n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
			}

			function Xa(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform2iv(this.addr, t), Na(n, t))
			}

			function qa(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform3iv(this.addr, t), Na(n, t))
			}

			function Ka(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform4iv(this.addr, t), Na(n, t))
			}

			function Ya(e, t) {
				const n = this.cache;
				n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
			}

			function Qa(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform2uiv(this.addr, t), Na(n, t))
			}

			function Za(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform3uiv(this.addr, t), Na(n, t))
			}

			function $a(e, t) {
				const n = this.cache;
				Oa(n, t) || (e.uniform4uiv(this.addr, t), Na(n, t))
			}

			function eo(e, t, n) {
				const r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || Ea, i)
			}

			function to(e, t, n) {
				const r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Ca, i)
			}

			function no(e, t, n) {
				const r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || Ba, i)
			}

			function ro(e, t, n) {
				const r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Ta, i)
			}

			function io(e, t) {
				e.uniform1fv(this.addr, t)
			}

			function so(e, t) {
				const n = Fa(t, this.size, 2);
				e.uniform2fv(this.addr, n)
			}

			function ao(e, t) {
				const n = Fa(t, this.size, 3);
				e.uniform3fv(this.addr, n)
			}

			function oo(e, t) {
				const n = Fa(t, this.size, 4);
				e.uniform4fv(this.addr, n)
			}

			function lo(e, t) {
				const n = Fa(t, this.size, 4);
				e.uniformMatrix2fv(this.addr, !1, n)
			}

			function co(e, t) {
				const n = Fa(t, this.size, 9);
				e.uniformMatrix3fv(this.addr, !1, n)
			}

			function uo(e, t) {
				const n = Fa(t, this.size, 16);
				e.uniformMatrix4fv(this.addr, !1, n)
			}

			function ho(e, t) {
				e.uniform1iv(this.addr, t)
			}

			function po(e, t) {
				e.uniform2iv(this.addr, t)
			}

			function fo(e, t) {
				e.uniform3iv(this.addr, t)
			}

			function mo(e, t) {
				e.uniform4iv(this.addr, t)
			}

			function go(e, t) {
				e.uniform1uiv(this.addr, t)
			}

			function vo(e, t) {
				e.uniform2uiv(this.addr, t)
			}

			function yo(e, t) {
				e.uniform3uiv(this.addr, t)
			}

			function xo(e, t) {
				e.uniform4uiv(this.addr, t)
			}

			function _o(e, t, n) {
				const r = t.length,
					i = Ha(n, r);
				e.uniform1iv(this.addr, i);
				for (let s = 0; s !== r; ++s) n.safeSetTexture2D(t[s] || Ea, i[s])
			}

			function bo(e, t, n) {
				const r = t.length,
					i = Ha(n, r);
				e.uniform1iv(this.addr, i);
				for (let s = 0; s !== r; ++s) n.setTexture3D(t[s] || Ca, i[s])
			}

			function wo(e, t, n) {
				const r = t.length,
					i = Ha(n, r);
				e.uniform1iv(this.addr, i);
				for (let s = 0; s !== r; ++s) n.safeSetTextureCube(t[s] || Ba, i[s])
			}

			function Mo(e, t, n) {
				const r = t.length,
					i = Ha(n, r);
				e.uniform1iv(this.addr, i);
				for (let s = 0; s !== r; ++s) n.setTexture2DArray(t[s] || Ta, i[s])
			}

			function Ao(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
					switch (e) {
						case 5126:
							return ka;
						case 35664:
							return Ga;
						case 35665:
							return Ua;
						case 35666:
							return za;
						case 35674:
							return Va;
						case 35675:
							return Wa;
						case 35676:
							return ja;
						case 5124:
						case 35670:
							return Ja;
						case 35667:
						case 35671:
							return Xa;
						case 35668:
						case 35672:
							return qa;
						case 35669:
						case 35673:
							return Ka;
						case 5125:
							return Ya;
						case 36294:
							return Qa;
						case 36295:
							return Za;
						case 36296:
							return $a;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return eo;
						case 35679:
						case 36299:
						case 36307:
							return to;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return no;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return ro
					}
				}(t.type)
			}

			function So(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
					switch (e) {
						case 5126:
							return io;
						case 35664:
							return so;
						case 35665:
							return ao;
						case 35666:
							return oo;
						case 35674:
							return lo;
						case 35675:
							return co;
						case 35676:
							return uo;
						case 5124:
						case 35670:
							return ho;
						case 35667:
						case 35671:
							return po;
						case 35668:
						case 35672:
							return fo;
						case 35669:
						case 35673:
							return mo;
						case 5125:
							return go;
						case 36294:
							return vo;
						case 36295:
							return yo;
						case 36296:
							return xo;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return _o;
						case 35679:
						case 36299:
						case 36307:
							return bo;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return wo;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return Mo
					}
				}(t.type)
			}

			function Eo(e) {
				this.id = e, this.seq = [], this.map = {}
			}
			So.prototype.updateCache = function(e) {
				const t = this.cache;
				e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Na(t, e)
			}, Eo.prototype.setValue = function(e, t, n) {
				const r = this.seq;
				for (let i = 0, s = r.length; i !== s; ++i) {
					const s = r[i];
					s.setValue(e, t[s.id], n)
				}
			};
			const To = /(\w+)(\])?(\[|\.)?/g;

			function Co(e, t) {
				e.seq.push(t), e.map[t.id] = t
			}

			function Bo(e, t, n) {
				const r = e.name,
					i = r.length;
				for (To.lastIndex = 0;;) {
					const s = To.exec(r),
						a = To.lastIndex;
					let o = s[1];
					const l = "]" === s[2],
						c = s[3];
					if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === i) {
						Co(n, void 0 === c ? new Ao(o, e, t) : new So(o, e, t));
						break
					} {
						let e = n.map[o];
						void 0 === e && (e = new Eo(o), Co(n, e)), n = e
					}
				}
			}

			function Ro(e, t) {
				this.seq = [], this.map = {};
				const n = e.getProgramParameter(t, 35718);
				for (let r = 0; r < n; ++r) {
					const n = e.getActiveUniform(t, r);
					Bo(n, e.getUniformLocation(t, n.name), this)
				}
			}

			function Lo(e, t, n) {
				const r = e.createShader(t);
				return e.shaderSource(r, n), e.compileShader(r), r
			}
			Ro.prototype.setValue = function(e, t, n, r) {
				const i = this.map[t];
				void 0 !== i && i.setValue(e, n, r)
			}, Ro.prototype.setOptional = function(e, t, n) {
				const r = t[n];
				void 0 !== r && this.setValue(e, n, r)
			}, Ro.upload = function(e, t, n, r) {
				for (let i = 0, s = t.length; i !== s; ++i) {
					const s = t[i],
						a = n[s.id];
					!1 !== a.needsUpdate && s.setValue(e, a.value, r)
				}
			}, Ro.seqWithValue = function(e, t) {
				const n = [];
				for (let r = 0, i = e.length; r !== i; ++r) {
					const i = e[r];
					i.id in t && n.push(i)
				}
				return n
			};
			let Io = 0;

			function Po(e) {
				switch (e) {
					case Kt:
						return ["Linear", "( value )"];
					case Yt:
						return ["sRGB", "( value )"];
					default:
						return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
				}
			}

			function Do(e, t, n) {
				const r = e.getShaderParameter(t, 35713),
					i = e.getShaderInfoLog(t).trim();
				return r && "" === i ? "" : n.toUpperCase() + "\n\n" + i + "\n\n" + function(e) {
					const t = e.split("\n");
					for (let n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
					return t.join("\n")
				}(e.getShaderSource(t))
			}

			function Fo(e, t) {
				const n = Po(t);
				return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
			}

			function Oo(e, t) {
				const n = Po(t);
				return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
			}

			function No(e, t) {
				let n;
				switch (t) {
					case $:
						n = "Linear";
						break;
					case ee:
						n = "Reinhard";
						break;
					case te:
						n = "OptimizedCineon";
						break;
					case ne:
						n = "ACESFilmic";
						break;
					case re:
						n = "Custom";
						break;
					default:
						console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
				}
				return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
			}

			function Ho(e) {
				return "" !== e
			}

			function ko(e, t) {
				return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
			}

			function Go(e, t) {
				return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
			}
			const Uo = /^[ \t]*#include +<([\w\d./]+)>/gm;

			function zo(e) {
				return e.replace(Uo, Vo)
			}

			function Vo(e, t) {
				const n = Fs[t];
				if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
				return zo(n)
			}
			const Wo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
				jo = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

			function Jo(e) {
				return e.replace(jo, qo).replace(Wo, Xo)
			}

			function Xo(e, t, n, r) {
				return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), qo(e, t, n, r)
			}

			function qo(e, t, n, r) {
				let i = "";
				for (let s = parseInt(t); s < parseInt(n); s++) i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
				return i
			}

			function Ko(e) {
				let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
				return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
			}

			function Yo(e, t, n, r) {
				const i = e.getContext(),
					s = n.defines;
				let a = n.vertexShader,
					o = n.fragmentShader;
				const l = function(e) {
						let t = "SHADOWMAP_TYPE_BASIC";
						return e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === d ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === p && (t = "SHADOWMAP_TYPE_VSM"), t
					}(n),
					c = function(e) {
						let t = "ENVMAP_TYPE_CUBE";
						if (e.envMap) switch (e.envMapMode) {
							case se:
							case ae:
								t = "ENVMAP_TYPE_CUBE";
								break;
							case ce:
							case ue:
								t = "ENVMAP_TYPE_CUBE_UV"
						}
						return t
					}(n),
					u = function(e) {
						let t = "ENVMAP_MODE_REFLECTION";
						if (e.envMap) switch (e.envMapMode) {
							case ae:
							case ue:
								t = "ENVMAP_MODE_REFRACTION"
						}
						return t
					}(n),
					f = function(e) {
						let t = "ENVMAP_BLENDING_NONE";
						if (e.envMap) switch (e.combine) {
							case K:
								t = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case Y:
								t = "ENVMAP_BLENDING_MIX";
								break;
							case Q:
								t = "ENVMAP_BLENDING_ADD"
						}
						return t
					}(n),
					m = n.isWebGL2 ? "" : function(e) {
						return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ho).join("\n")
					}(n),
					g = function(e) {
						const t = [];
						for (const n in e) {
							const r = e[n];
							!1 !== r && t.push("#define " + n + " " + r)
						}
						return t.join("\n")
					}(s),
					v = i.createProgram();
				let y, x, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
				n.isRawShaderMaterial ? (y = [g].filter(Ho).join("\n"), y.length > 0 && (y += "\n"), x = [m, g].filter(Ho).join("\n"), x.length > 0 && (x += "\n")) : (y = [Ko(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ho).join("\n"), x = [m, Ko(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Z ? "#define TONE_MAPPING" : "", n.toneMapping !== Z ? Fs.tonemapping_pars_fragment : "", n.toneMapping !== Z ? No("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === Ne ? "#define OPAQUE" : "", Fs.encodings_pars_fragment, n.map ? Fo("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Fo("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Fo("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Fo("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? Fo("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? Fo("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? Fo("lightMapTexelToLinear", n.lightMapEncoding) : "", Oo("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ho).join("\n")), a = zo(a), a = ko(a, n), a = Go(a, n), o = zo(o), o = ko(o, n), o = Go(o, n), a = Jo(a), o = Jo(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["#define varying in", n.glslVersion === Cn ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Cn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
				const b = _ + x + o,
					w = Lo(i, 35633, _ + y + a),
					M = Lo(i, 35632, b);
				if (i.attachShader(v, w), i.attachShader(v, M), void 0 !== n.index0AttributeName ? i.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v), e.debug.checkShaderErrors) {
					const e = i.getProgramInfoLog(v).trim(),
						t = i.getShaderInfoLog(w).trim(),
						n = i.getShaderInfoLog(M).trim();
					let r = !0,
						s = !0;
					if (!1 === i.getProgramParameter(v, 35714)) {
						r = !1;
						const t = Do(i, w, "vertex"),
							n = Do(i, M, "fragment");
						console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
					} else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1);
					s && (this.diagnostics = {
						runnable: r,
						programLog: e,
						vertexShader: {
							log: t,
							prefix: y
						},
						fragmentShader: {
							log: n,
							prefix: x
						}
					})
				}
				let A, S;
				return i.deleteShader(w), i.deleteShader(M), this.getUniforms = function() {
					return void 0 === A && (A = new Ro(i, v)), A
				}, this.getAttributes = function() {
					return void 0 === S && (S = function(e, t) {
						const n = {},
							r = e.getProgramParameter(t, 35721);
						for (let i = 0; i < r; i++) {
							const r = e.getActiveAttrib(t, i),
								s = r.name;
							let a = 1;
							35674 === r.type && (a = 2), 35675 === r.type && (a = 3), 35676 === r.type && (a = 4), n[s] = {
								type: r.type,
								location: e.getAttribLocation(t, s),
								locationSize: a
							}
						}
						return n
					}(i, v)), S
				}, this.destroy = function() {
					r.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0
				}, this.name = n.shaderName, this.id = Io++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = w, this.fragmentShader = M, this
			}
			let Qo = 0;
			class Zo {
				constructor() {
					this.shaderCache = new Map, this.materialCache = new Map
				}
				update(e) {
					const t = e.vertexShader,
						n = e.fragmentShader,
						r = this._getShaderStage(t),
						i = this._getShaderStage(n),
						s = this._getShaderCacheForMaterial(e);
					return !1 === s.has(r) && (s.add(r), r.usedTimes++), !1 === s.has(i) && (s.add(i), i.usedTimes++), this
				}
				remove(e) {
					const t = this.materialCache.get(e);
					for (const n of t) n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n);
					return this.materialCache.delete(e), this
				}
				getVertexShaderID(e) {
					return this._getShaderStage(e.vertexShader).id
				}
				getFragmentShaderID(e) {
					return this._getShaderStage(e.fragmentShader).id
				}
				dispose() {
					this.shaderCache.clear(), this.materialCache.clear()
				}
				_getShaderCacheForMaterial(e) {
					const t = this.materialCache;
					return !1 === t.has(e) && t.set(e, new Set), t.get(e)
				}
				_getShaderStage(e) {
					const t = this.shaderCache;
					if (!1 === t.has(e)) {
						const n = new $o;
						t.set(e, n)
					}
					return t.get(e)
				}
			}
			class $o {
				constructor() {
					this.id = Qo++, this.usedTimes = 0
				}
			}

			function el(e, t, n, r, i, s, a) {
				const o = new Jr,
					l = new Zo,
					c = [],
					u = i.isWebGL2,
					h = i.logarithmicDepthBuffer,
					d = i.floatVertexTextures,
					p = i.maxVertexUniforms,
					f = i.vertexTextures;
				let v = i.precision;
				const y = {
					MeshDepthMaterial: "depth",
					MeshDistanceMaterial: "distanceRGBA",
					MeshNormalMaterial: "normal",
					MeshBasicMaterial: "basic",
					MeshLambertMaterial: "lambert",
					MeshPhongMaterial: "phong",
					MeshToonMaterial: "toon",
					MeshStandardMaterial: "physical",
					MeshPhysicalMaterial: "physical",
					MeshMatcapMaterial: "matcap",
					LineBasicMaterial: "basic",
					LineDashedMaterial: "dashed",
					PointsMaterial: "points",
					ShadowMaterial: "shadow",
					SpriteMaterial: "sprite"
				};

				function x(e) {
					let t;
					return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = Kt, u && e && e.isTexture && e.format === He && e.type === Ae && e.encoding === Yt && (t = Kt), t
				}
				return {
					getParameters: function(s, o, c, _, b) {
						const w = _.fog,
							M = s.isMeshStandardMaterial ? _.environment : null,
							A = (s.isMeshStandardMaterial ? n : t).get(s.envMap || M),
							S = y[s.type],
							E = b.isSkinnedMesh ? function(e) {
								const t = e.skeleton.bones;
								if (d) return 1024; {
									const e = p,
										n = Math.floor((e - 20) / 4),
										r = Math.min(n, t.length);
									return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r
								}
							}(b) : 0;
						let T, C, B, R;
						if (null !== s.precision && (v = i.getMaxPrecision(s.precision), v !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", v, "instead.")), S) {
							const e = Ns[S];
							T = e.vertexShader, C = e.fragmentShader
						} else T = s.vertexShader, C = s.fragmentShader, l.update(s), B = l.getVertexShaderID(s), R = l.getFragmentShaderID(s);
						const L = e.getRenderTarget(),
							I = s.alphaTest > 0,
							P = s.clearcoat > 0;
						return {
							isWebGL2: u,
							shaderID: S,
							shaderName: s.type,
							vertexShader: T,
							fragmentShader: C,
							defines: s.defines,
							customVertexShaderID: B,
							customFragmentShaderID: R,
							isRawShaderMaterial: !0 === s.isRawShaderMaterial,
							glslVersion: s.glslVersion,
							precision: v,
							instancing: !0 === b.isInstancedMesh,
							instancingColor: !0 === b.isInstancedMesh && null !== b.instanceColor,
							supportsVertexTextures: f,
							outputEncoding: null !== L ? x(L.texture) : e.outputEncoding,
							map: !!s.map,
							mapEncoding: x(s.map),
							matcap: !!s.matcap,
							matcapEncoding: x(s.matcap),
							envMap: !!A,
							envMapMode: A && A.mapping,
							envMapEncoding: x(A),
							envMapCubeUV: !!A && (A.mapping === ce || A.mapping === ue),
							lightMap: !!s.lightMap,
							lightMapEncoding: x(s.lightMap),
							aoMap: !!s.aoMap,
							emissiveMap: !!s.emissiveMap,
							emissiveMapEncoding: x(s.emissiveMap),
							bumpMap: !!s.bumpMap,
							normalMap: !!s.normalMap,
							objectSpaceNormalMap: s.normalMapType === en,
							tangentSpaceNormalMap: s.normalMapType === $t,
							clearcoat: P,
							clearcoatMap: P && !!s.clearcoatMap,
							clearcoatRoughnessMap: P && !!s.clearcoatRoughnessMap,
							clearcoatNormalMap: P && !!s.clearcoatNormalMap,
							displacementMap: !!s.displacementMap,
							roughnessMap: !!s.roughnessMap,
							metalnessMap: !!s.metalnessMap,
							specularMap: !!s.specularMap,
							specularIntensityMap: !!s.specularIntensityMap,
							specularColorMap: !!s.specularColorMap,
							specularColorMapEncoding: x(s.specularColorMap),
							alphaMap: !!s.alphaMap,
							alphaTest: I,
							gradientMap: !!s.gradientMap,
							sheen: s.sheen > 0,
							sheenColorMap: !!s.sheenColorMap,
							sheenColorMapEncoding: x(s.sheenColorMap),
							sheenRoughnessMap: !!s.sheenRoughnessMap,
							transmission: s.transmission > 0,
							transmissionMap: !!s.transmissionMap,
							thicknessMap: !!s.thicknessMap,
							combine: s.combine,
							vertexTangents: !!s.normalMap && !!b.geometry && !!b.geometry.attributes.tangent,
							vertexColors: s.vertexColors,
							vertexAlphas: !0 === s.vertexColors && !!b.geometry && !!b.geometry.attributes.color && 4 === b.geometry.attributes.color.itemSize,
							vertexUvs: !!s.map || !!s.bumpMap || !!s.normalMap || !!s.specularMap || !!s.alphaMap || !!s.emissiveMap || !!s.roughnessMap || !!s.metalnessMap || !!s.clearcoatMap || !!s.clearcoatRoughnessMap || !!s.clearcoatNormalMap || !!s.displacementMap || !!s.transmissionMap || !!s.thicknessMap || !!s.specularIntensityMap || !!s.specularColorMap || !!s.sheenColorMap || !!s.sheenRoughnessMap,
							uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap) && !!s.displacementMap,
							fog: !!w,
							useFog: s.fog,
							fogExp2: w && w.isFogExp2,
							flatShading: !!s.flatShading,
							sizeAttenuation: s.sizeAttenuation,
							logarithmicDepthBuffer: h,
							skinning: !0 === b.isSkinnedMesh && E > 0,
							maxBones: E,
							useVertexTexture: d,
							morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position,
							morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal,
							morphTargetsCount: b.geometry && b.geometry.morphAttributes.position ? b.geometry.morphAttributes.position.length : 0,
							numDirLights: o.directional.length,
							numPointLights: o.point.length,
							numSpotLights: o.spot.length,
							numRectAreaLights: o.rectArea.length,
							numHemiLights: o.hemi.length,
							numDirLightShadows: o.directionalShadowMap.length,
							numPointLightShadows: o.pointShadowMap.length,
							numSpotLightShadows: o.spotShadowMap.length,
							numClippingPlanes: a.numPlanes,
							numClipIntersection: a.numIntersection,
							format: s.format,
							dithering: s.dithering,
							shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
							shadowMapType: e.shadowMap.type,
							toneMapping: s.toneMapped ? e.toneMapping : Z,
							physicallyCorrectLights: e.physicallyCorrectLights,
							premultipliedAlpha: s.premultipliedAlpha,
							doubleSided: s.side === g,
							flipSided: s.side === m,
							depthPacking: void 0 !== s.depthPacking && s.depthPacking,
							index0AttributeName: s.index0AttributeName,
							extensionDerivatives: s.extensions && s.extensions.derivatives,
							extensionFragDepth: s.extensions && s.extensions.fragDepth,
							extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
							extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
							rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
							rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
							rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
							customProgramCacheKey: s.customProgramCacheKey()
						}
					},
					getProgramCacheKey: function(t) {
						const n = [];
						if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
							for (const e in t.defines) n.push(e), n.push(t.defines[e]);
						return !1 === t.isRawShaderMaterial && (! function(e, t) {
							e.push(t.precision), e.push(t.outputEncoding), e.push(t.mapEncoding), e.push(t.matcapEncoding), e.push(t.envMapMode), e.push(t.envMapEncoding), e.push(t.lightMapEncoding), e.push(t.emissiveMapEncoding), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.maxBones), e.push(t.morphTargetsCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.format), e.push(t.specularColorMapEncoding), e.push(t.sheenColorMapEncoding)
						}(n, t), function(e, t) {
							o.disableAll(), t.isWebGL2 && o.enable(0);
							t.supportsVertexTextures && o.enable(1);
							t.instancing && o.enable(2);
							t.instancingColor && o.enable(3);
							t.map && o.enable(4);
							t.matcap && o.enable(5);
							t.envMap && o.enable(6);
							t.envMapCubeUV && o.enable(7);
							t.lightMap && o.enable(8);
							t.aoMap && o.enable(9);
							t.emissiveMap && o.enable(10);
							t.bumpMap && o.enable(11);
							t.normalMap && o.enable(12);
							t.objectSpaceNormalMap && o.enable(13);
							t.tangentSpaceNormalMap && o.enable(14);
							t.clearcoat && o.enable(15);
							t.clearcoatMap && o.enable(16);
							t.clearcoatRoughnessMap && o.enable(17);
							t.clearcoatNormalMap && o.enable(18);
							t.displacementMap && o.enable(19);
							t.specularMap && o.enable(20);
							t.roughnessMap && o.enable(21);
							t.metalnessMap && o.enable(22);
							t.gradientMap && o.enable(23);
							t.alphaMap && o.enable(24);
							t.alphaTest && o.enable(25);
							t.vertexColors && o.enable(26);
							t.vertexAlphas && o.enable(27);
							t.vertexUvs && o.enable(28);
							t.vertexTangents && o.enable(29);
							t.uvsVertexOnly && o.enable(30);
							t.fog && o.enable(31);
							e.push(o.mask), o.disableAll(), t.useFog && o.enable(0);
							t.flatShading && o.enable(1);
							t.logarithmicDepthBuffer && o.enable(2);
							t.skinning && o.enable(3);
							t.useVertexTexture && o.enable(4);
							t.morphTargets && o.enable(5);
							t.morphNormals && o.enable(6);
							t.premultipliedAlpha && o.enable(7);
							t.shadowMapEnabled && o.enable(8);
							t.physicallyCorrectLights && o.enable(9);
							t.doubleSided && o.enable(10);
							t.flipSided && o.enable(11);
							t.depthPacking && o.enable(12);
							t.dithering && o.enable(13);
							t.specularIntensityMap && o.enable(14);
							t.specularColorMap && o.enable(15);
							t.transmission && o.enable(16);
							t.transmissionMap && o.enable(17);
							t.thicknessMap && o.enable(18);
							t.sheen && o.enable(19);
							t.sheenColorMap && o.enable(20);
							t.sheenRoughnessMap && o.enable(21);
							e.push(o.mask)
						}(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join()
					},
					getUniforms: function(e) {
						const t = y[e.type];
						let n;
						if (t) {
							const e = Ns[t];
							n = vs.clone(e.uniforms)
						} else n = e.uniforms;
						return n
					},
					acquireProgram: function(t, n) {
						let r;
						for (let e = 0, i = c.length; e < i; e++) {
							const t = c[e];
							if (t.cacheKey === n) {
								r = t, ++r.usedTimes;
								break
							}
						}
						return void 0 === r && (r = new Yo(e, n, t, s), c.push(r)), r
					},
					releaseProgram: function(e) {
						if (0 === --e.usedTimes) {
							const t = c.indexOf(e);
							c[t] = c[c.length - 1], c.pop(), e.destroy()
						}
					},
					releaseShaderCache: function(e) {
						l.remove(e)
					},
					programs: c,
					dispose: function() {
						l.dispose()
					}
				}
			}

			function tl() {
				let e = new WeakMap;
				return {
					get: function(t) {
						let n = e.get(t);
						return void 0 === n && (n = {}, e.set(t, n)), n
					},
					remove: function(t) {
						e.delete(t)
					},
					update: function(t, n, r) {
						e.get(t)[n] = r
					},
					dispose: function() {
						e = new WeakMap
					}
				}
			}

			function nl(e, t) {
				return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
			}

			function rl(e, t) {
				return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
			}

			function il() {
				const e = [];
				let t = 0;
				const n = [],
					r = [],
					i = [];

				function s(n, r, i, s, a, o) {
					let l = e[t];
					return void 0 === l ? (l = {
						id: n.id,
						object: n,
						geometry: r,
						material: i,
						groupOrder: s,
						renderOrder: n.renderOrder,
						z: a,
						group: o
					}, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), t++, l
				}
				return {
					opaque: n,
					transmissive: r,
					transparent: i,
					init: function() {
						t = 0, n.length = 0, r.length = 0, i.length = 0
					},
					push: function(e, t, a, o, l, c) {
						const u = s(e, t, a, o, l, c);
						a.transmission > 0 ? r.push(u) : !0 === a.transparent ? i.push(u) : n.push(u)
					},
					unshift: function(e, t, a, o, l, c) {
						const u = s(e, t, a, o, l, c);
						a.transmission > 0 ? r.unshift(u) : !0 === a.transparent ? i.unshift(u) : n.unshift(u)
					},
					finish: function() {
						for (let n = t, r = e.length; n < r; n++) {
							const t = e[n];
							if (null === t.id) break;
							t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
						}
					},
					sort: function(e, t) {
						n.length > 1 && n.sort(e || nl), r.length > 1 && r.sort(t || rl), i.length > 1 && i.sort(t || rl)
					}
				}
			}

			function sl() {
				let e = new WeakMap;
				return {
					get: function(t, n) {
						let r;
						return !1 === e.has(t) ? (r = new il, e.set(t, [r])) : n >= e.get(t).length ? (r = new il, e.get(t).push(r)) : r = e.get(t)[n], r
					},
					dispose: function() {
						e = new WeakMap
					}
				}
			}

			function al() {
				const e = {};
				return {
					get: function(t) {
						if (void 0 !== e[t.id]) return e[t.id];
						let n;
						switch (t.type) {
							case "DirectionalLight":
								n = {
									direction: new ir,
									color: new Ei
								};
								break;
							case "SpotLight":
								n = {
									position: new ir,
									direction: new ir,
									color: new Ei,
									distance: 0,
									coneCos: 0,
									penumbraCos: 0,
									decay: 0
								};
								break;
							case "PointLight":
								n = {
									position: new ir,
									color: new Ei,
									distance: 0,
									decay: 0
								};
								break;
							case "HemisphereLight":
								n = {
									direction: new ir,
									skyColor: new Ei,
									groundColor: new Ei
								};
								break;
							case "RectAreaLight":
								n = {
									color: new Ei,
									position: new ir,
									halfWidth: new ir,
									halfHeight: new ir
								}
						}
						return e[t.id] = n, n
					}
				}
			}
			let ol = 0;

			function ll(e, t) {
				return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
			}

			function cl(e, t) {
				const n = new al,
					r = function() {
						const e = {};
						return {
							get: function(t) {
								if (void 0 !== e[t.id]) return e[t.id];
								let n;
								switch (t.type) {
									case "DirectionalLight":
									case "SpotLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new zn
										};
										break;
									case "PointLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new zn,
											shadowCameraNear: 1,
											shadowCameraFar: 1e3
										}
								}
								return e[t.id] = n, n
							}
						}
					}(),
					i = {
						version: 0,
						hash: {
							directionalLength: -1,
							pointLength: -1,
							spotLength: -1,
							rectAreaLength: -1,
							hemiLength: -1,
							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						},
						ambient: [0, 0, 0],
						probe: [],
						directional: [],
						directionalShadow: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadow: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						rectAreaLTC1: null,
						rectAreaLTC2: null,
						point: [],
						pointShadow: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					};
				for (let l = 0; l < 9; l++) i.probe.push(new ir);
				const s = new ir,
					a = new Fr,
					o = new Fr;
				return {
					setup: function(s, a) {
						let o = 0,
							l = 0,
							c = 0;
						for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
						let u = 0,
							h = 0,
							d = 0,
							p = 0,
							f = 0,
							m = 0,
							g = 0,
							v = 0;
						s.sort(ll);
						const y = !0 !== a ? Math.PI : 1;
						for (let e = 0, t = s.length; e < t; e++) {
							const t = s[e],
								a = t.color,
								x = t.intensity,
								_ = t.distance,
								b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
							if (t.isAmbientLight) o += a.r * x * y, l += a.g * x * y, c += a.b * x * y;
							else if (t.isLightProbe)
								for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(t.sh.coefficients[e], x);
							else if (t.isDirectionalLight) {
								const e = n.get(t);
								if (e.color.copy(t.color).multiplyScalar(t.intensity * y), t.castShadow) {
									const e = t.shadow,
										n = r.get(t);
									n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = b, i.directionalShadowMatrix[u] = t.shadow.matrix, m++
								}
								i.directional[u] = e, u++
							} else if (t.isSpotLight) {
								const e = n.get(t);
								if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(x * y), e.distance = _, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
									const e = t.shadow,
										n = r.get(t);
									n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.spotShadow[d] = n, i.spotShadowMap[d] = b, i.spotShadowMatrix[d] = t.shadow.matrix, v++
								}
								i.spot[d] = e, d++
							} else if (t.isRectAreaLight) {
								const e = n.get(t);
								e.color.copy(a).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[p] = e, p++
							} else if (t.isPointLight) {
								const e = n.get(t);
								if (e.color.copy(t.color).multiplyScalar(t.intensity * y), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
									const e = t.shadow,
										n = r.get(t);
									n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[h] = n, i.pointShadowMap[h] = b, i.pointShadowMatrix[h] = t.shadow.matrix, g++
								}
								i.point[h] = e, h++
							} else if (t.isHemisphereLight) {
								const e = n.get(t);
								e.skyColor.copy(t.color).multiplyScalar(x * y), e.groundColor.copy(t.groundColor).multiplyScalar(x * y), i.hemi[f] = e, f++
							}
						}
						p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Os.LTC_FLOAT_1, i.rectAreaLTC2 = Os.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Os.LTC_HALF_1, i.rectAreaLTC2 = Os.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = o, i.ambient[1] = l, i.ambient[2] = c;
						const x = i.hash;
						x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (i.directional.length = u, i.spot.length = d, i.rectArea.length = p, i.point.length = h, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotShadowMatrix.length = v, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, i.version = ol++)
					},
					setupView: function(e, t) {
						let n = 0,
							r = 0,
							l = 0,
							c = 0,
							u = 0;
						const h = t.matrixWorldInverse;
						for (let d = 0, p = e.length; d < p; d++) {
							const t = e[d];
							if (t.isDirectionalLight) {
								const e = i.directional[n];
								e.direction.setFromMatrixPosition(t.matrixWorld), s.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), n++
							} else if (t.isSpotLight) {
								const e = i.spot[l];
								e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(t.matrixWorld), s.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), l++
							} else if (t.isRectAreaLight) {
								const e = i.rectArea[c];
								e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), o.identity(), a.copy(t.matrixWorld), a.premultiply(h), o.extractRotation(a), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
							} else if (t.isPointLight) {
								const e = i.point[r];
								e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), r++
							} else if (t.isHemisphereLight) {
								const e = i.hemi[u];
								e.direction.setFromMatrixPosition(t.matrixWorld), e.direction.transformDirection(h), e.direction.normalize(), u++
							}
						}
					},
					state: i
				}
			}

			function ul(e, t) {
				const n = new cl(e, t),
					r = [],
					i = [];
				return {
					init: function() {
						r.length = 0, i.length = 0
					},
					state: {
						lightsArray: r,
						shadowsArray: i,
						lights: n
					},
					setupLights: function(e) {
						n.setup(r, e)
					},
					setupLightsView: function(e) {
						n.setupView(r, e)
					},
					pushLight: function(e) {
						r.push(e)
					},
					pushShadow: function(e) {
						i.push(e)
					}
				}
			}

			function hl(e, t) {
				let n = new WeakMap;
				return {
					get: function(r, i = 0) {
						let s;
						return !1 === n.has(r) ? (s = new ul(e, t), n.set(r, [s])) : i >= n.get(r).length ? (s = new ul(e, t), n.get(r).push(s)) : s = n.get(r)[i], s
					},
					dispose: function() {
						n = new WeakMap
					}
				}
			}
			class dl extends xi {
				constructor(e) {
					super(), this.type = "MeshDepthMaterial", this.depthPacking = Qt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
				}
			}
			dl.prototype.isMeshDepthMaterial = !0;
			class pl extends xi {
				constructor(e) {
					super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ir, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
				}
			}
			pl.prototype.isMeshDistanceMaterial = !0;

			function fl(e, t, n) {
				let r = new Ls;
				const i = new zn,
					s = new zn,
					a = new $n,
					o = new dl({
						depthPacking: Zt
					}),
					l = new pl,
					c = {},
					u = n.maxTextureSize,
					d = {
						0: m,
						1: f,
						2: g
					},
					v = new ys({
						defines: {
							VSM_SAMPLES: 8
						},
						uniforms: {
							shadow_pass: {
								value: null
							},
							resolution: {
								value: new zn
							},
							radius: {
								value: 4
							}
						},
						vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
						fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
					}),
					y = v.clone();
				y.defines.HORIZONTAL_PASS = 1;
				const _ = new qi;
				_.setAttribute("position", new Ri(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
				const b = new ds(_, v),
					w = this;

				function M(n, r) {
					const i = t.update(b);
					v.defines.VSM_SAMPLES !== n.blurSamples && (v.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, v.needsUpdate = !0, y.needsUpdate = !0), v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, v, b, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, y, b, null)
				}

				function A(t, n, r, i, s, a, u) {
					let h = null;
					const f = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
					if (h = void 0 !== f ? f : !0 === i.isPointLight ? l : o, e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) {
						const e = h.uuid,
							t = r.uuid;
						let n = c[e];
						void 0 === n && (n = {}, c[e] = n);
						let i = n[t];
						void 0 === i && (i = h.clone(), n[t] = i), h = i
					}
					return h.visible = r.visible, h.wireframe = r.wireframe, h.side = u === p ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : d[r.side], h.alphaMap = r.alphaMap, h.alphaTest = r.alphaTest, h.clipShadows = r.clipShadows, h.clippingPlanes = r.clippingPlanes, h.clipIntersection = r.clipIntersection, h.displacementMap = r.displacementMap, h.displacementScale = r.displacementScale, h.displacementBias = r.displacementBias, h.wireframeLinewidth = r.wireframeLinewidth, h.linewidth = r.linewidth, !0 === i.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(i.matrixWorld), h.nearDistance = s, h.farDistance = a), h
				}

				function S(n, i, s, a, o) {
					if (!1 === n.visible) return;
					if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === p) && (!n.frustumCulled || r.intersectsObject(n))) {
						n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
						const r = t.update(n),
							i = n.material;
						if (Array.isArray(i)) {
							const t = r.groups;
							for (let l = 0, c = t.length; l < c; l++) {
								const c = t[l],
									u = i[c.materialIndex];
								if (u && u.visible) {
									const t = A(n, 0, u, a, s.near, s.far, o);
									e.renderBufferDirect(s, null, r, t, n, c)
								}
							}
						} else if (i.visible) {
							const t = A(n, 0, i, a, s.near, s.far, o);
							e.renderBufferDirect(s, null, r, t, n, null)
						}
					}
					const l = n.children;
					for (let e = 0, t = l.length; e < t; e++) S(l[e], i, s, a, o)
				}
				this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = h, this.render = function(t, n, o) {
					if (!1 === w.enabled) return;
					if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
					if (0 === t.length) return;
					const l = e.getRenderTarget(),
						c = e.getActiveCubeFace(),
						h = e.getActiveMipmapLevel(),
						d = e.state;
					d.setBlending(x), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
					for (let f = 0, m = t.length; f < m; f++) {
						const l = t[f],
							c = l.shadow;
						if (void 0 === c) {
							console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
							continue
						}
						if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
						i.copy(c.mapSize);
						const h = c.getFrameExtents();
						if (i.multiply(h), s.copy(c.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / h.x), i.x = s.x * h.x, c.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / h.y), i.y = s.y * h.y, c.mapSize.y = s.y)), null === c.map && !c.isPointLightShadow && this.type === p) {
							const e = {
								minFilter: xe,
								magFilter: xe,
								format: He
							};
							c.map = new er(i.x, i.y, e), c.map.texture.name = l.name + ".shadowMap", c.mapPass = new er(i.x, i.y, e), c.camera.updateProjectionMatrix()
						}
						if (null === c.map) {
							const e = {
								minFilter: fe,
								magFilter: fe,
								format: He
							};
							c.map = new er(i.x, i.y, e), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
						}
						e.setRenderTarget(c.map), e.clear();
						const m = c.getViewportCount();
						for (let e = 0; e < m; e++) {
							const t = c.getViewport(e);
							a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), c.updateMatrices(l, e), r = c.getFrustum(), S(n, o, c.camera, l, this.type)
						}
						c.isPointLightShadow || this.type !== p || M(c, o), c.needsUpdate = !1
					}
					w.needsUpdate = !1, e.setRenderTarget(l, c, h)
				}
			}

			function ml(e, t, n) {
				const r = n.isWebGL2;
				const i = new function() {
						let t = !1;
						const n = new $n;
						let r = null;
						const i = new $n(0, 0, 0, 0);
						return {
							setMask: function(n) {
								r === n || t || (e.colorMask(n, n, n, n), r = n)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t, r, s, a, o) {
								!0 === o && (t *= a, r *= a, s *= a), n.set(t, r, s, a), !1 === i.equals(n) && (e.clearColor(t, r, s, a), i.copy(n))
							},
							reset: function() {
								t = !1, r = null, i.set(-1, 0, 0, 0)
							}
						}
					},
					s = new function() {
						let t = !1,
							n = null,
							r = null,
							i = null;
						return {
							setTest: function(e) {
								e ? ve(2929) : ye(2929)
							},
							setMask: function(r) {
								n === r || t || (e.depthMask(r), n = r)
							},
							setFunc: function(t) {
								if (r !== t) {
									if (t) switch (t) {
										case U:
											e.depthFunc(512);
											break;
										case z:
											e.depthFunc(519);
											break;
										case V:
											e.depthFunc(513);
											break;
										case W:
											e.depthFunc(515);
											break;
										case j:
											e.depthFunc(514);
											break;
										case J:
											e.depthFunc(518);
											break;
										case X:
											e.depthFunc(516);
											break;
										case q:
											e.depthFunc(517);
											break;
										default:
											e.depthFunc(515)
									} else e.depthFunc(515);
									r = t
								}
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								i !== t && (e.clearDepth(t), i = t)
							},
							reset: function() {
								t = !1, n = null, r = null, i = null
							}
						}
					},
					c = new function() {
						let t = !1,
							n = null,
							r = null,
							i = null,
							s = null,
							a = null,
							o = null,
							l = null,
							c = null;
						return {
							setTest: function(e) {
								t || (e ? ve(2960) : ye(2960))
							},
							setMask: function(r) {
								n === r || t || (e.stencilMask(r), n = r)
							},
							setFunc: function(t, n, a) {
								r === t && i === n && s === a || (e.stencilFunc(t, n, a), r = t, i = n, s = a)
							},
							setOp: function(t, n, r) {
								a === t && o === n && l === r || (e.stencilOp(t, n, r), a = t, o = n, l = r)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								c !== t && (e.clearStencil(t), c = t)
							},
							reset: function() {
								t = !1, n = null, r = null, i = null, s = null, a = null, o = null, l = null, c = null
							}
						}
					};
				let u = {},
					h = {},
					d = null,
					p = !1,
					f = null,
					v = null,
					y = null,
					K = null,
					Y = null,
					Q = null,
					Z = null,
					$ = !1,
					ee = null,
					te = null,
					ne = null,
					re = null,
					ie = null;
				const se = e.getParameter(35661);
				let ae = !1,
					oe = 0;
				const le = e.getParameter(7938); - 1 !== le.indexOf("WebGL") ? (oe = parseFloat(/^WebGL (\d)/.exec(le)[1]), ae = oe >= 1) : -1 !== le.indexOf("OpenGL ES") && (oe = parseFloat(/^OpenGL ES (\d)/.exec(le)[1]), ae = oe >= 2);
				let ce = null,
					ue = {};
				const he = e.getParameter(3088),
					de = e.getParameter(2978),
					pe = (new $n).fromArray(he),
					fe = (new $n).fromArray(de);

				function me(t, n, r) {
					const i = new Uint8Array(4),
						s = e.createTexture();
					e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
					for (let a = 0; a < r; a++) e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
					return s
				}
				const ge = {};

				function ve(t) {
					!0 !== u[t] && (e.enable(t), u[t] = !0)
				}

				function ye(t) {
					!1 !== u[t] && (e.disable(t), u[t] = !1)
				}
				ge[3553] = me(3553, 3553, 1), ge[34067] = me(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), c.setClear(0), ve(2929), s.setFunc(W), we(!1), Me(o), ve(2884), be(x);
				const xe = {
					[S]: 32774,
					[E]: 32778,
					[T]: 32779
				};
				if (r) xe[C] = 32775, xe[B] = 32776;
				else {
					const e = t.get("EXT_blend_minmax");
					null !== e && (xe[C] = e.MIN_EXT, xe[B] = e.MAX_EXT)
				}
				const _e = {
					[R]: 0,
					[L]: 1,
					[I]: 768,
					[D]: 770,
					[G]: 776,
					[H]: 774,
					[O]: 772,
					[P]: 769,
					[F]: 771,
					[k]: 775,
					[N]: 773
				};

				function be(t, n, r, i, s, a, o, l) {
					if (t !== x) {
						if (!1 === p && (ve(3042), p = !0), t === A) s = s || n, a = a || r, o = o || i, n === v && s === Y || (e.blendEquationSeparate(xe[n], xe[s]), v = n, Y = s), r === y && i === K && a === Q && o === Z || (e.blendFuncSeparate(_e[r], _e[i], _e[a], _e[o]), y = r, K = i, Q = a, Z = o), f = t, $ = null;
						else if (t !== f || l !== $) {
							if (v === S && Y === S || (e.blendEquation(32774), v = S, Y = S), l) switch (t) {
								case _:
									e.blendFuncSeparate(1, 771, 1, 771);
									break;
								case b:
									e.blendFunc(1, 1);
									break;
								case w:
									e.blendFuncSeparate(0, 0, 769, 771);
									break;
								case M:
									e.blendFuncSeparate(0, 768, 0, 770);
									break;
								default:
									console.error("THREE.WebGLState: Invalid blending: ", t)
							} else switch (t) {
								case _:
									e.blendFuncSeparate(770, 771, 1, 771);
									break;
								case b:
									e.blendFunc(770, 1);
									break;
								case w:
									e.blendFunc(0, 769);
									break;
								case M:
									e.blendFunc(0, 768);
									break;
								default:
									console.error("THREE.WebGLState: Invalid blending: ", t)
							}
							y = null, K = null, Q = null, Z = null, f = t, $ = l
						}
					} else !0 === p && (ye(3042), p = !1)
				}

				function we(t) {
					ee !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ee = t)
				}

				function Me(t) {
					t !== a ? (ve(2884), t !== te && (t === o ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : ye(2884), te = t
				}

				function Ae(t, n, r) {
					t ? (ve(32823), re === n && ie === r || (e.polygonOffset(n, r), re = n, ie = r)) : ye(32823)
				}

				function Se(t) {
					void 0 === t && (t = 33984 + se - 1), ce !== t && (e.activeTexture(t), ce = t)
				}
				return {
					buffers: {
						color: i,
						depth: s,
						stencil: c
					},
					enable: ve,
					disable: ye,
					bindFramebuffer: function(t, n) {
						return h[t] !== n && (e.bindFramebuffer(t, n), h[t] = n, r && (36009 === t && (h[36160] = n), 36160 === t && (h[36009] = n)), !0)
					},
					useProgram: function(t) {
						return d !== t && (e.useProgram(t), d = t, !0)
					},
					setBlending: be,
					setMaterial: function(e, t) {
						e.side === g ? ye(2884) : ve(2884);
						let n = e.side === m;
						t && (n = !n), we(n), e.blending === _ && !1 === e.transparent ? be(x) : be(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), i.setMask(e.colorWrite);
						const r = e.stencilWrite;
						c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Ae(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ve(32926) : ye(32926)
					},
					setFlipSided: we,
					setCullFace: Me,
					setLineWidth: function(t) {
						t !== ne && (ae && e.lineWidth(t), ne = t)
					},
					setPolygonOffset: Ae,
					setScissorTest: function(e) {
						e ? ve(3089) : ye(3089)
					},
					activeTexture: Se,
					bindTexture: function(t, n) {
						null === ce && Se();
						let r = ue[ce];
						void 0 === r && (r = {
							type: void 0,
							texture: void 0
						}, ue[ce] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || ge[t]), r.type = t, r.texture = n)
					},
					unbindTexture: function() {
						const t = ue[ce];
						void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
					},
					compressedTexImage2D: function() {
						try {
							e.compressedTexImage2D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texImage2D: function() {
						try {
							e.texImage2D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texImage3D: function() {
						try {
							e.texImage3D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texStorage2D: function() {
						try {
							e.texStorage2D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texStorage3D: function() {
						try {
							e.texStorage3D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texSubImage2D: function() {
						try {
							e.texSubImage2D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texSubImage3D: function() {
						try {
							e.texSubImage3D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					compressedTexSubImage2D: function() {
						try {
							e.compressedTexSubImage2D.apply(e, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					scissor: function(t) {
						!1 === pe.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), pe.copy(t))
					},
					viewport: function(t) {
						!1 === fe.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), fe.copy(t))
					},
					reset: function() {
						e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), u = {}, ce = null, ue = {}, h = {}, d = null, p = !1, f = null, v = null, y = null, K = null, Y = null, Q = null, Z = null, $ = !1, ee = null, te = null, ne = null, re = null, ie = null, pe.set(0, 0, e.canvas.width, e.canvas.height), fe.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), s.reset(), c.reset()
					}
				}
			}

			function gl(e, t, n, r, i, s, a) {
				const o = i.isWebGL2,
					l = i.maxTextures,
					c = i.maxCubemapSize,
					u = i.maxTextureSize,
					h = i.maxSamples,
					d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : void 0,
					p = new WeakMap;
				let f, m = !1;
				try {
					m = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
				} catch (G) {}

				function g(e, t) {
					return m ? new OffscreenCanvas(e, t) : Xn("canvas")
				}

				function v(e, t, n, r) {
					let i = 1;
					if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
						if ("undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap) {
							const r = t ? Gn : Math.floor,
								s = r(i * e.width),
								a = r(i * e.height);
							void 0 === f && (f = g(s, a));
							const o = n ? g(s, a) : f;
							o.width = s, o.height = a;
							return o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o
						}
						return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
					}
					return e
				}

				function y(e) {
					return Hn(e.width) && Hn(e.height)
				}

				function x(e, t) {
					return e.generateMipmaps && t && e.minFilter !== fe && e.minFilter !== xe
				}

				function _(t) {
					e.generateMipmap(t)
				}

				function b(n, r, i, s) {
					if (!1 === o) return r;
					if (null !== n) {
						if (void 0 !== e[n]) return e[n];
						console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
					}
					let a = r;
					return 6403 === r && (5126 === i && (a = 33326), 5131 === i && (a = 33325), 5121 === i && (a = 33321)), 6407 === r && (5126 === i && (a = 34837), 5131 === i && (a = 34843), 5121 === i && (a = 32849)), 6408 === r && (5126 === i && (a = 34836), 5131 === i && (a = 34842), 5121 === i && (a = s === Yt ? 35907 : 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a
				}

				function w(e, t, n) {
					return !0 === x(e, n) || e.isFramebufferTexture && e.minFilter !== fe && e.minFilter !== xe ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
				}

				function M(e) {
					return e === fe || e === me || e === ve ? 9728 : 9729
				}

				function A(t) {
					const n = t.target;
					n.removeEventListener("dispose", A),
						function(t) {
							const n = r.get(t);
							if (void 0 === n.__webglInit) return;
							e.deleteTexture(n.__webglTexture), r.remove(t)
						}(n), n.isVideoTexture && p.delete(n), a.memory.textures--
				}

				function S(t) {
					const n = t.target;
					n.removeEventListener("dispose", S),
						function(t) {
							const n = t.texture,
								i = r.get(t),
								s = r.get(n);
							if (!t) return;
							void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--);
							t.depthTexture && t.depthTexture.dispose();
							if (t.isWebGLCubeRenderTarget)
								for (let r = 0; r < 6; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
							else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && e.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
							if (t.isWebGLMultipleRenderTargets)
								for (let o = 0, l = n.length; o < l; o++) {
									const t = r.get(n[o]);
									t.__webglTexture && (e.deleteTexture(t.__webglTexture), a.memory.textures--), r.remove(n[o])
								}
							r.remove(n), r.remove(t)
						}(n)
				}
				let E = 0;

				function T(e, t) {
					const i = r.get(e);
					if (e.isVideoTexture && function(e) {
							const t = a.render.frame;
							p.get(e) !== t && (p.set(e, t), e.update())
						}(e), e.version > 0 && i.__version !== e.version) {
						const n = e.image;
						if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
						else {
							if (!1 !== n.complete) return void P(i, e, t);
							console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
						}
					}
					n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture)
				}

				function C(t, i) {
					const a = r.get(t);
					t.version > 0 && a.__version !== t.version ? function(t, r, i) {
						if (6 !== r.image.length) return;
						I(t, r), n.activeTexture(33984 + i), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
						const a = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
							l = r.image[0] && r.image[0].isDataTexture,
							u = [];
						for (let e = 0; e < 6; e++) u[e] = a || l ? l ? r.image[e].image : r.image[e] : v(r.image[e], !1, !0, c);
						const h = u[0],
							d = y(h) || o,
							p = s.convert(r.format),
							f = s.convert(r.type),
							m = b(r.internalFormat, p, f, r.encoding),
							g = o && !0 !== r.isVideoTexture,
							M = void 0 === t.__version;
						let A, S = w(r, h, d);
						if (L(34067, r, d), a) {
							g && M && n.texStorage2D(34067, S, m, h.width, h.height);
							for (let e = 0; e < 6; e++) {
								A = u[e].mipmaps;
								for (let t = 0; t < A.length; t++) {
									const i = A[t];
									r.format !== He && r.format !== Ne ? null !== p ? g ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, i.width, i.height, p, i.data) : n.compressedTexImage2D(34069 + e, t, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + e, t, 0, 0, i.width, i.height, p, f, i.data) : n.texImage2D(34069 + e, t, m, i.width, i.height, 0, p, f, i.data)
								}
							}
						} else {
							A = r.mipmaps, g && M && (A.length > 0 && S++, n.texStorage2D(34067, S, m, u[0].width, u[0].height));
							for (let e = 0; e < 6; e++)
								if (l) {
									g ? n.texSubImage2D(34069 + e, 0, 0, 0, u[e].width, u[e].height, p, f, u[e].data) : n.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, p, f, u[e].data);
									for (let t = 0; t < A.length; t++) {
										const r = A[t].image[e].image;
										g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, r.width, r.height, p, f, r.data) : n.texImage2D(34069 + e, t + 1, m, r.width, r.height, 0, p, f, r.data)
									}
								} else {
									g ? n.texSubImage2D(34069 + e, 0, 0, 0, p, f, u[e]) : n.texImage2D(34069 + e, 0, m, p, f, u[e]);
									for (let t = 0; t < A.length; t++) {
										const r = A[t];
										g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, p, f, r.image[e]) : n.texImage2D(34069 + e, t + 1, m, p, f, r.image[e])
									}
								}
						}
						x(r, d) && _(34067);
						t.__version = r.version, r.onUpdate && r.onUpdate(r)
					}(a, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, a.__webglTexture))
				}
				const B = {
						[he]: 10497,
						[de]: 33071,
						[pe]: 33648
					},
					R = {
						[fe]: 9728,
						[me]: 9984,
						[ve]: 9986,
						[xe]: 9729,
						[_e]: 9985,
						[we]: 9987
					};

				function L(n, s, a) {
					if (a ? (e.texParameteri(n, 10242, B[s.wrapS]), e.texParameteri(n, 10243, B[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, B[s.wrapR]), e.texParameteri(n, 10240, R[s.magFilter]), e.texParameteri(n, 10241, R[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === de && s.wrapT === de || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, M(s.magFilter)), e.texParameteri(n, 10241, M(s.minFilter)), s.minFilter !== fe && s.minFilter !== xe && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
						const a = t.get("EXT_texture_filter_anisotropic");
						if (s.type === Re && !1 === t.has("OES_texture_float_linear")) return;
						if (!1 === o && s.type === Le && !1 === t.has("OES_texture_half_float_linear")) return;
						(s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy)
					}
				}

				function I(t, n) {
					void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", A), t.__webglTexture = e.createTexture(), a.memory.textures++)
				}

				function P(t, r, i) {
					let a = 3553;
					r.isDataTexture2DArray && (a = 35866), r.isDataTexture3D && (a = 32879), I(t, r), n.activeTexture(33984 + i), n.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
					const l = function(e) {
							return !o && (e.wrapS !== de || e.wrapT !== de || e.minFilter !== fe && e.minFilter !== xe)
						}(r) && !1 === y(r.image),
						c = v(r.image, l, !1, u),
						h = y(c) || o,
						d = s.convert(r.format);
					let p, f = s.convert(r.type),
						m = b(r.internalFormat, d, f, r.encoding);
					L(a, r, h);
					const g = r.mipmaps,
						M = o && !0 !== r.isVideoTexture,
						A = void 0 === t.__version,
						S = w(r, c, h);
					if (r.isDepthTexture) m = 6402, o ? m = r.type === Re ? 36012 : r.type === Be ? 33190 : r.type === Fe ? 35056 : 33189 : r.type === Re && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Ue && 6402 === m && r.type !== Te && r.type !== Be && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Te, f = s.convert(r.type)), r.format === ze && 6402 === m && (m = 34041, r.type !== Fe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Fe, f = s.convert(r.type))), M && A ? n.texStorage2D(3553, 1, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
					else if (r.isDataTexture)
						if (g.length > 0 && h) {
							M && A && n.texStorage2D(3553, S, m, g[0].width, g[0].height);
							for (let e = 0, t = g.length; e < t; e++) p = g[e], M ? n.texSubImage2D(3553, 0, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
							r.generateMipmaps = !1
						} else M ? (A && n.texStorage2D(3553, S, m, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, d, f, c.data)) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data);
					else if (r.isCompressedTexture) {
						M && A && n.texStorage2D(3553, S, m, g[0].width, g[0].height);
						for (let e = 0, t = g.length; e < t; e++) p = g[e], r.format !== He && r.format !== Ne ? null !== d ? M ? n.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data)
					} else if (r.isDataTexture2DArray) M ? (A && n.texStorage3D(35866, S, m, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, d, f, c.data)) : n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data);
					else if (r.isDataTexture3D) M ? (A && n.texStorage3D(32879, S, m, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, d, f, c.data)) : n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data);
					else if (r.isFramebufferTexture) M && A ? n.texStorage2D(3553, S, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
					else if (g.length > 0 && h) {
						M && A && n.texStorage2D(3553, S, m, g[0].width, g[0].height);
						for (let e = 0, t = g.length; e < t; e++) p = g[e], M ? n.texSubImage2D(3553, e, 0, 0, d, f, p) : n.texImage2D(3553, e, m, d, f, p);
						r.generateMipmaps = !1
					} else M ? (A && n.texStorage2D(3553, S, m, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, d, f, c)) : n.texImage2D(3553, 0, m, d, f, c);
					x(r, h) && _(a), t.__version = r.version, r.onUpdate && r.onUpdate(r)
				}

				function D(t, i, a, o, l) {
					const c = s.convert(a.format),
						u = s.convert(a.type),
						h = b(a.internalFormat, c, u, a.encoding);
					r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, c, u, null) : n.texImage2D(l, 0, h, i.width, i.height, 0, c, u, null)), n.bindFramebuffer(36160, t), i.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, o, l, r.get(a).__webglTexture, 0, N(i)) : e.framebufferTexture2D(36160, o, l, r.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
				}

				function F(t, n, r) {
					if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
						let i = 33189;
						if (r || n.useRenderToTexture) {
							const t = n.depthTexture;
							t && t.isDepthTexture && (t.type === Re ? i = 36012 : t.type === Be && (i = 33190));
							const r = N(n);
							n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, i, n.width, n.height) : e.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
						} else e.renderbufferStorage(36161, i, n.width, n.height);
						e.framebufferRenderbuffer(36160, 36096, 36161, t)
					} else if (n.depthBuffer && n.stencilBuffer) {
						const i = N(n);
						r && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, i, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
					} else {
						const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
							i = s.convert(t.format),
							a = s.convert(t.type),
							o = b(t.internalFormat, i, a, t.encoding),
							l = N(n);
						r && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : e.renderbufferStorage(36161, o, n.width, n.height)
					}
					e.bindRenderbuffer(36161, null)
				}

				function O(t) {
					const i = r.get(t),
						s = !0 === t.isWebGLCubeRenderTarget;
					if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
						if (s) throw new Error("target.depthTexture not supported in Cube render targets");
						! function(t, i) {
							if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
							if (n.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
							r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), T(i.depthTexture, 0);
							const s = r.get(i.depthTexture).__webglTexture,
								a = N(i);
							if (i.depthTexture.format === Ue) i.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
							else {
								if (i.depthTexture.format !== ze) throw new Error("Unknown depthTexture format");
								i.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
							}
						}(i.__webglFramebuffer, t)
					} else if (s) {
						i.__webglDepthbuffer = [];
						for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), F(i.__webglDepthbuffer[r], t, !1)
					} else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), F(i.__webglDepthbuffer, t, !1);
					n.bindFramebuffer(36160, null)
				}

				function N(e) {
					return o && (e.useRenderbuffer || e.useRenderToTexture) ? Math.min(h, e.samples) : 0
				}
				let H = !1,
					k = !1;
				this.allocateTextureUnit = function() {
					const e = E;
					return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), E += 1, e
				}, this.resetTextureUnits = function() {
					E = 0
				}, this.setTexture2D = T, this.setTexture2DArray = function(e, t) {
					const i = r.get(e);
					e.version > 0 && i.__version !== e.version ? P(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture))
				}, this.setTexture3D = function(e, t) {
					const i = r.get(e);
					e.version > 0 && i.__version !== e.version ? P(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture))
				}, this.setTextureCube = C, this.rebindTextures = function(e, t, n) {
					const i = r.get(e);
					void 0 !== t && D(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && O(e)
				}, this.setupRenderTarget = function(t) {
					const l = t.texture,
						c = r.get(t),
						u = r.get(l);
					t.addEventListener("dispose", S), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, a.memory.textures++);
					const h = !0 === t.isWebGLCubeRenderTarget,
						d = !0 === t.isWebGLMultipleRenderTargets,
						p = l.isDataTexture3D || l.isDataTexture2DArray,
						f = y(t) || o;
					if (!o || l.format !== Ne || l.type !== Re && l.type !== Le || (l.format = He, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
						c.__webglFramebuffer = [];
						for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
					} else if (c.__webglFramebuffer = e.createFramebuffer(), d)
						if (i.drawBuffers) {
							const n = t.texture;
							for (let t = 0, i = n.length; t < i; t++) {
								const i = r.get(n[t]);
								void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), a.memory.textures++)
							}
						} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
					else if (t.useRenderbuffer)
						if (o) {
							c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
							const r = s.convert(l.format),
								i = s.convert(l.type),
								a = b(l.internalFormat, r, i, l.encoding),
								o = N(t);
							e.renderbufferStorageMultisample(36161, o, a, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), F(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
						} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
					if (h) {
						n.bindTexture(34067, u.__webglTexture), L(34067, l, f);
						for (let e = 0; e < 6; e++) D(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
						x(l, f) && _(34067), n.unbindTexture()
					} else if (d) {
						const e = t.texture;
						for (let i = 0, s = e.length; i < s; i++) {
							const s = e[i],
								a = r.get(s);
							n.bindTexture(3553, a.__webglTexture), L(3553, s, f), D(c.__webglFramebuffer, t, s, 36064 + i, 3553), x(s, f) && _(3553)
						}
						n.unbindTexture()
					} else {
						let e = 3553;
						if (p)
							if (o) {
								e = l.isDataTexture3D ? 32879 : 35866
							} else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
						n.bindTexture(e, u.__webglTexture), L(e, l, f), D(c.__webglFramebuffer, t, l, 36064, e), x(l, f) && _(e), n.unbindTexture()
					}
					t.depthBuffer && O(t)
				}, this.updateRenderTargetMipmap = function(e) {
					const t = y(e) || o,
						i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
					for (let s = 0, a = i.length; s < a; s++) {
						const a = i[s];
						if (x(a, t)) {
							const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
								i = r.get(a).__webglTexture;
							n.bindTexture(t, i), _(t), n.unbindTexture()
						}
					}
				}, this.updateMultisampleRenderTarget = function(t) {
					if (t.useRenderbuffer)
						if (o) {
							const i = t.width,
								s = t.height;
							let a = 16384;
							const o = [36064],
								l = t.stencilBuffer ? 33306 : 36096;
							t.depthBuffer && o.push(l), t.ignoreDepthForMultisampleCopy || (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024));
							const c = r.get(t);
							n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), t.ignoreDepthForMultisampleCopy && (e.invalidateFramebuffer(36008, [l]), e.invalidateFramebuffer(36009, [l])), e.blitFramebuffer(0, 0, i, s, 0, 0, i, s, a, 9728), e.invalidateFramebuffer(36008, o), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
						} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
				}, this.setupDepthRenderbuffer = O, this.setupFrameBufferTexture = D, this.safeSetTexture2D = function(e, t) {
					e && e.isWebGLRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), H = !0), e = e.texture), T(e, t)
				}, this.safeSetTextureCube = function(e, t) {
					e && e.isWebGLCubeRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k = !0), e = e.texture), C(e, t)
				}
			}

			function vl(e, t, n) {
				const r = n.isWebGL2;
				return {
					convert: function(e) {
						let n;
						if (e === Ae) return 5121;
						if (e === Ie) return 32819;
						if (e === Pe) return 32820;
						if (e === De) return 33635;
						if (e === Se) return 5120;
						if (e === Ee) return 5122;
						if (e === Te) return 5123;
						if (e === Ce) return 5124;
						if (e === Be) return 5125;
						if (e === Re) return 5126;
						if (e === Le) return r ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
						if (e === Oe) return 6406;
						if (e === Ne) return 6407;
						if (e === He) return 6408;
						if (e === ke) return 6409;
						if (e === Ge) return 6410;
						if (e === Ue) return 6402;
						if (e === ze) return 34041;
						if (e === Ve) return 6403;
						if (e === We) return 36244;
						if (e === je) return 33319;
						if (e === Je) return 33320;
						if (e === Xe) return 36248;
						if (e === qe) return 36249;
						if (e === Ke || e === Ye || e === Qe || e === Ze) {
							if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
							if (e === Ke) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
							if (e === Ye) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							if (e === Qe) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							if (e === Ze) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if (e === $e || e === et || e === tt || e === nt) {
							if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
							if (e === $e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (e === et) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (e === tt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (e === nt) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (e === rt) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
						if ((e === it || e === st) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) {
							if (e === it) return n.COMPRESSED_RGB8_ETC2;
							if (e === st) return n.COMPRESSED_RGBA8_ETC2_EAC
						}
						return e === at || e === ot || e === lt || e === ct || e === ut || e === ht || e === dt || e === pt || e === ft || e === mt || e === gt || e === vt || e === yt || e === xt || e === bt || e === wt || e === Mt || e === At || e === St || e === Et || e === Tt || e === Ct || e === Bt || e === Rt || e === Lt || e === It || e === Pt || e === Dt ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : e === _t ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : e === Fe ? r ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
					}
				}
			}
			class yl extends _s {
				constructor(e = []) {
					super(), this.cameras = e
				}
			}
			yl.prototype.isArrayCamera = !0;
			class xl extends ai {
				constructor() {
					super(), this.type = "Group"
				}
			}
			xl.prototype.isGroup = !0;
			const _l = {
				type: "move"
			};
			class bl {
				constructor() {
					this._targetRay = null, this._grip = null, this._hand = null
				}
				getHandSpace() {
					return null === this._hand && (this._hand = new xl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
						pinching: !1
					}), this._hand
				}
				getTargetRaySpace() {
					return null === this._targetRay && (this._targetRay = new xl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ir, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ir), this._targetRay
				}
				getGripSpace() {
					return null === this._grip && (this._grip = new xl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ir, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ir), this._grip
				}
				dispatchEvent(e) {
					return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
				}
				disconnect(e) {
					return this.dispatchEvent({
						type: "disconnected",
						data: e
					}), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
				}
				update(e, t, n) {
					let r = null,
						i = null,
						s = null;
					const a = this._targetRay,
						o = this._grip,
						l = this._hand;
					if (e && "visible-blurred" !== t.session.visibilityState)
						if (null !== a && (r = t.getPose(e.targetRaySpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(_l))), l && e.hand) {
							s = !0;
							for (const s of e.hand.values()) {
								const e = t.getJointPose(s, n);
								if (void 0 === l.joints[s.jointName]) {
									const e = new xl;
									e.matrixAutoUpdate = !1, e.visible = !1, l.joints[s.jointName] = e, l.add(e)
								}
								const r = l.joints[s.jointName];
								null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
							}
							const r = l.joints["index-finger-tip"],
								i = l.joints["thumb-tip"],
								a = r.position.distanceTo(i.position),
								o = .02,
								c = .005;
							l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
								type: "pinchend",
								handedness: e.handedness,
								target: this
							})) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
								type: "pinchstart",
								handedness: e.handedness,
								target: this
							}))
						} else null !== o && e.gripSpace && (i = t.getPose(e.gripSpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1));
					return null !== a && (a.visible = null !== r), null !== o && (o.visible = null !== i), null !== l && (l.visible = null !== s), this
				}
			}
			class wl extends Qn {
				constructor(e, t, n, r, i, s, a, o, l, c) {
					if ((c = void 0 !== c ? c : Ue) !== Ue && c !== ze) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
					void 0 === n && c === Ue && (n = Te), void 0 === n && c === ze && (n = Fe), super(null, r, i, s, a, o, c, n, l), this.image = {
						width: e,
						height: t
					}, this.magFilter = void 0 !== a ? a : fe, this.minFilter = void 0 !== o ? o : fe, this.flipY = !1, this.generateMipmaps = !1
				}
			}
			wl.prototype.isDepthTexture = !0;
			class Ml extends Bn {
				constructor(e, t) {
					super();
					const n = this;
					let r = null,
						i = 1,
						s = null,
						a = "local-floor";
					const o = e.extensions.has("WEBGL_multisampled_render_to_texture");
					let l = null,
						c = null,
						u = null,
						h = null,
						d = !1,
						p = null;
					const f = t.getContextAttributes();
					let m = null,
						g = null;
					const v = [],
						y = new Map,
						x = new _s;
					x.layers.enable(1), x.viewport = new $n;
					const _ = new _s;
					_.layers.enable(2), _.viewport = new $n;
					const b = [x, _],
						w = new yl;
					w.layers.enable(1), w.layers.enable(2);
					let M = null,
						A = null;

					function S(e) {
						const t = y.get(e.inputSource);
						t && t.dispatchEvent({
							type: e.type,
							data: e.inputSource
						})
					}

					function E() {
						y.forEach((function(e, t) {
							e.disconnect(t)
						})), y.clear(), M = null, A = null, e.setRenderTarget(m), h = null, u = null, c = null, r = null, g = null, I.stop(), n.isPresenting = !1, n.dispatchEvent({
							type: "sessionend"
						})
					}

					function T(e) {
						const t = r.inputSources;
						for (let n = 0; n < v.length; n++) y.set(t[n], v[n]);
						for (let n = 0; n < e.removed.length; n++) {
							const t = e.removed[n],
								r = y.get(t);
							r && (r.dispatchEvent({
								type: "disconnected",
								data: t
							}), y.delete(t))
						}
						for (let n = 0; n < e.added.length; n++) {
							const t = e.added[n],
								r = y.get(t);
							r && r.dispatchEvent({
								type: "connected",
								data: t
							})
						}
					}
					this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
						let t = v[e];
						return void 0 === t && (t = new bl, v[e] = t), t.getTargetRaySpace()
					}, this.getControllerGrip = function(e) {
						let t = v[e];
						return void 0 === t && (t = new bl, v[e] = t), t.getGripSpace()
					}, this.getHand = function(e) {
						let t = v[e];
						return void 0 === t && (t = new bl, v[e] = t), t.getHandSpace()
					}, this.setFramebufferScaleFactor = function(e) {
						i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
					}, this.setReferenceSpaceType = function(e) {
						a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
					}, this.getReferenceSpace = function() {
						return s
					}, this.getBaseLayer = function() {
						return null !== u ? u : h
					}, this.getBinding = function() {
						return c
					}, this.getFrame = function() {
						return p
					}, this.getSession = function() {
						return r
					}, this.setSession = async function(l) {
						if (r = l, null !== r) {
							if (m = e.getRenderTarget(), r.addEventListener("select", S), r.addEventListener("selectstart", S), r.addEventListener("selectend", S), r.addEventListener("squeeze", S), r.addEventListener("squeezestart", S), r.addEventListener("squeezeend", S), r.addEventListener("end", E), r.addEventListener("inputsourceschange", T), !0 !== f.xrCompatible && await t.makeXRCompatible(), void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
								const n = {
									antialias: void 0 !== r.renderState.layers || f.antialias,
									alpha: f.alpha,
									depth: f.depth,
									stencil: f.stencil,
									framebufferScaleFactor: i
								};
								h = new XRWebGLLayer(r, t, n), r.updateRenderState({
									baseLayer: h
								}), g = new er(h.framebufferWidth, h.framebufferHeight, {
									format: He,
									type: Ae,
									encoding: e.outputEncoding
								})
							} else {
								d = f.antialias;
								let n = null,
									s = null,
									a = null;
								f.depth && (a = f.stencil ? 35056 : 33190, n = f.stencil ? ze : Ue, s = f.stencil ? Fe : Te);
								const l = {
									colorFormat: f.alpha || d ? 32856 : 32849,
									depthFormat: a,
									scaleFactor: i
								};
								c = new XRWebGLBinding(r, t), u = c.createProjectionLayer(l), r.updateRenderState({
									layers: [u]
								}), g = d ? new nr(u.textureWidth, u.textureHeight, {
									format: He,
									type: Ae,
									depthTexture: new wl(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
									stencilBuffer: f.stencil,
									ignoreDepth: u.ignoreDepthValues,
									useRenderToTexture: o,
									encoding: e.outputEncoding
								}) : new er(u.textureWidth, u.textureHeight, {
									format: f.alpha ? He : Ne,
									type: Ae,
									depthTexture: new wl(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
									stencilBuffer: f.stencil,
									ignoreDepth: u.ignoreDepthValues,
									encoding: e.outputEncoding
								})
							}
							this.setFoveation(1), s = await r.requestReferenceSpace(a), I.setContext(r), I.start(), n.isPresenting = !0, n.dispatchEvent({
								type: "sessionstart"
							})
						}
					};
					const C = new ir,
						B = new ir;

					function R(e, t) {
						null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
					}
					this.updateCamera = function(e) {
						if (null === r) return;
						w.near = _.near = x.near = e.near, w.far = _.far = x.far = e.far, M === w.near && A === w.far || (r.updateRenderState({
							depthNear: w.near,
							depthFar: w.far
						}), M = w.near, A = w.far);
						const t = e.parent,
							n = w.cameras;
						R(w, t);
						for (let r = 0; r < n.length; r++) R(n[r], t);
						w.matrixWorld.decompose(w.position, w.quaternion, w.scale), e.position.copy(w.position), e.quaternion.copy(w.quaternion), e.scale.copy(w.scale), e.matrix.copy(w.matrix), e.matrixWorld.copy(w.matrixWorld);
						const i = e.children;
						for (let r = 0, s = i.length; r < s; r++) i[r].updateMatrixWorld(!0);
						2 === n.length ? function(e, t, n) {
							C.setFromMatrixPosition(t.matrixWorld), B.setFromMatrixPosition(n.matrixWorld);
							const r = C.distanceTo(B),
								i = t.projectionMatrix.elements,
								s = n.projectionMatrix.elements,
								a = i[14] / (i[10] - 1),
								o = i[14] / (i[10] + 1),
								l = (i[9] + 1) / i[5],
								c = (i[9] - 1) / i[5],
								u = (i[8] - 1) / i[0],
								h = (s[8] + 1) / s[0],
								d = a * u,
								p = a * h,
								f = r / (-u + h),
								m = f * -u;
							t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
							const g = a + f,
								v = o + f,
								y = d - m,
								x = p + (r - m),
								_ = l * o / v * g,
								b = c * o / v * g;
							e.projectionMatrix.makePerspective(y, x, _, b, g, v)
						}(w, x, _) : w.projectionMatrix.copy(x.projectionMatrix)
					}, this.getCamera = function() {
						return w
					}, this.getFoveation = function() {
						return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0
					}, this.setFoveation = function(e) {
						null !== u && (u.fixedFoveation = e), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e)
					};
					let L = null;
					const I = new Is;
					I.setAnimationLoop((function(t, n) {
						if (l = n.getViewerPose(s), p = n, null !== l) {
							const t = l.views;
							null !== h && (e.setRenderTargetFramebuffer(g, h.framebuffer), e.setRenderTarget(g));
							let n = !1;
							t.length !== w.cameras.length && (w.cameras.length = 0, n = !0);
							for (let r = 0; r < t.length; r++) {
								const i = t[r];
								let s = null;
								if (null !== h) s = h.getViewport(i);
								else {
									const t = c.getViewSubImage(u, i);
									s = t.viewport, 0 === r && (e.setRenderTargetTextures(g, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(g))
								}
								const a = b[r];
								a.matrix.fromArray(i.transform.matrix), a.projectionMatrix.fromArray(i.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === r && w.matrix.copy(a.matrix), !0 === n && w.cameras.push(a)
							}
						}
						const i = r.inputSources;
						for (let e = 0; e < v.length; e++) {
							const t = v[e],
								r = i[e];
							t.update(r, n, s)
						}
						L && L(t, n), p = null
					})), this.setAnimationLoop = function(e) {
						L = e
					}, this.dispose = function() {}
				}
			}

			function Al(e) {
				function t(t, n) {
					t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
					const r = e.get(n).envMap;
					let i, s;
					r && (t.envMap.value = r, t.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? i = n.clearcoatRoughnessMap : n.specularIntensityMap ? i = n.specularIntensityMap : n.specularColorMap ? i = n.specularColorMap : n.transmissionMap ? i = n.transmissionMap : n.thicknessMap ? i = n.thicknessMap : n.sheenColorMap ? i = n.sheenColorMap : n.sheenRoughnessMap && (i = n.sheenRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix))
				}

				function n(t, n) {
					t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === m && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), n.side === m && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias);
					e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
				}
				return {
					refreshFogUniforms: function(e, t) {
						e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
					},
					refreshMaterialUniforms: function(e, r, i, s, a) {
						r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r), function(e, t) {
							t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
						}(e, r)) : r.isMeshToonMaterial ? (t(e, r), function(e, t) {
							t.gradientMap && (e.gradientMap.value = t.gradientMap);
							t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
							t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === m && (e.bumpScale.value *= -1));
							t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === m && e.normalScale.value.negate());
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
						}(e, r)) : r.isMeshPhongMaterial ? (t(e, r), function(e, t) {
							e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
							t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === m && (e.bumpScale.value *= -1));
							t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === m && e.normalScale.value.negate());
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
						}(e, r)) : r.isMeshStandardMaterial ? (t(e, r), r.isMeshPhysicalMaterial ? function(e, t, r) {
							n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
							t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === m && e.clearcoatNormalScale.value.negate()));
							t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
							e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
							t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
						}(e, r, a) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r), function(e, t) {
							t.matcap && (e.matcap.value = t.matcap);
							t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === m && (e.bumpScale.value *= -1));
							t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === m && e.normalScale.value.negate());
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
						}(e, r)) : r.isMeshDepthMaterial ? (t(e, r), function(e, t) {
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
						}(e, r)) : r.isMeshDistanceMaterial ? (t(e, r), function(e, t) {
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
							e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
						}(e, r)) : r.isMeshNormalMaterial ? (t(e, r), function(e, t) {
							t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === m && (e.bumpScale.value *= -1));
							t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === m && e.normalScale.value.negate());
							t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
						}(e, r)) : r.isLineBasicMaterial ? (function(e, t) {
							e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
						}(e, r), r.isLineDashedMaterial && function(e, t) {
							e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
						}(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
							e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map);
							t.alphaMap && (e.alphaMap.value = t.alphaMap);
							t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
							let i;
							t.map ? i = t.map : t.alphaMap && (i = t.alphaMap);
							void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
						}(e, r, i, s) : r.isSpriteMaterial ? function(e, t) {
							e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
							t.alphaMap && (e.alphaMap.value = t.alphaMap);
							t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
							let n;
							t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
							void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
						}(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
					}
				}
			}

			function Sl(e = {}) {
				const t = void 0 !== e.canvas ? e.canvas : function() {
						const e = Xn("canvas");
						return e.style.display = "block", e
					}(),
					n = void 0 !== e.context ? e.context : null,
					i = void 0 !== e.alpha && e.alpha,
					s = void 0 === e.depth || e.depth,
					a = void 0 === e.stencil || e.stencil,
					o = void 0 !== e.antialias && e.antialias,
					l = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
					c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
					u = void 0 !== e.powerPreference ? e.powerPreference : "default",
					h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
				let d = null,
					p = null;
				const v = [],
					y = [];
				this.domElement = t, this.debug = {
					checkShaderErrors: !0
				}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Kt, this.physicallyCorrectLights = !1, this.toneMapping = Z, this.toneMappingExposure = 1;
				const x = this;
				let _ = !1,
					b = 0,
					w = 0,
					M = null,
					A = -1,
					S = null;
				const E = new $n,
					T = new $n;
				let C = null,
					B = t.width,
					R = t.height,
					L = 1,
					I = null,
					P = null;
				const D = new $n(0, 0, B, R),
					F = new $n(0, 0, B, R);
				let O = !1;
				const N = [],
					H = new Ls;
				let k = !1,
					G = !1,
					U = null;
				const z = new Fr,
					V = new ir,
					W = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: !0
					};

				function j() {
					return null === M ? L : 1
				}
				let J, X, q, K, Y, Q, $, ee, te, ne, re, ie, se, ae, oe, le, ce, ue, he, pe, me, ge, ve, ye = n;

				function xe(e, n) {
					for (let r = 0; r < e.length; r++) {
						const i = e[r],
							s = t.getContext(i, n);
						if (null !== s) return s
					}
					return null
				}
				try {
					const e = {
						alpha: i,
						depth: s,
						stencil: a,
						antialias: o,
						premultipliedAlpha: l,
						preserveDrawingBuffer: c,
						powerPreference: u,
						failIfMajorPerformanceCaveat: h
					};
					if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${r}`), t.addEventListener("webglcontextlost", Me, !1), t.addEventListener("webglcontextrestored", Se, !1), null === ye) {
						const t = ["webgl2", "webgl", "experimental-webgl"];
						if (!0 === x.isWebGL1Renderer && t.shift(), ye = xe(t, e), null === ye) throw xe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
					}
					void 0 === ye.getShaderPrecisionFormat && (ye.getShaderPrecisionFormat = function() {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					})
				} catch (Ge) {
					throw console.error("THREE.WebGLRenderer: " + Ge.message), Ge
				}

				function _e() {
					J = new ma(ye), X = new Us(ye, J, e), J.init(X), ge = new vl(ye, J, X), q = new ml(ye, J, X), N[0] = 1029, K = new ya(ye), Y = new tl, Q = new gl(ye, J, q, Y, X, ge, K), $ = new Vs(x), ee = new fa(x), te = new Ps(ye, X), ve = new ks(ye, J, te, X), ne = new ga(ye, te, K, ve), re = new Aa(ye, ne, te, K), he = new Ma(ye, X, Q), le = new zs(Y), ie = new el(x, $, ee, J, X, ve, le), se = new Al(Y), ae = new sl, oe = new hl(J, X), ue = new Hs(x, $, q, re, l), ce = new fl(x, re, X), pe = new Gs(ye, J, K, X), me = new va(ye, J, K, X), K.programs = ie.programs, x.capabilities = X, x.extensions = J, x.properties = Y, x.renderLists = ae, x.shadowMap = ce, x.state = q, x.info = K
				}
				_e();
				const be = new Ml(x, ye);

				function Me(e) {
					e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
				}

				function Se() {
					console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
					const e = K.autoReset,
						t = ce.enabled,
						n = ce.autoUpdate,
						r = ce.needsUpdate,
						i = ce.type;
					_e(), K.autoReset = e, ce.enabled = t, ce.autoUpdate = n, ce.needsUpdate = r, ce.type = i
				}

				function Ee(e) {
					const t = e.target;
					t.removeEventListener("dispose", Ee),
						function(e) {
							(function(e) {
								const t = Y.get(e).programs;
								void 0 !== t && (t.forEach((function(e) {
									ie.releaseProgram(e)
								})), e.isShaderMaterial && ie.releaseShaderCache(e))
							})(e), Y.remove(e)
						}(t)
				}
				this.xr = be, this.getContext = function() {
					return ye
				}, this.getContextAttributes = function() {
					return ye.getContextAttributes()
				}, this.forceContextLoss = function() {
					const e = J.get("WEBGL_lose_context");
					e && e.loseContext()
				}, this.forceContextRestore = function() {
					const e = J.get("WEBGL_lose_context");
					e && e.restoreContext()
				}, this.getPixelRatio = function() {
					return L
				}, this.setPixelRatio = function(e) {
					void 0 !== e && (L = e, this.setSize(B, R, !1))
				}, this.getSize = function(e) {
					return e.set(B, R)
				}, this.setSize = function(e, n, r) {
					be.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = e, R = n, t.width = Math.floor(e * L), t.height = Math.floor(n * L), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
				}, this.getDrawingBufferSize = function(e) {
					return e.set(B * L, R * L).floor()
				}, this.setDrawingBufferSize = function(e, n, r) {
					B = e, R = n, L = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n)
				}, this.getCurrentViewport = function(e) {
					return e.copy(E)
				}, this.getViewport = function(e) {
					return e.copy(D)
				}, this.setViewport = function(e, t, n, r) {
					e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r), q.viewport(E.copy(D).multiplyScalar(L).floor())
				}, this.getScissor = function(e) {
					return e.copy(F)
				}, this.setScissor = function(e, t, n, r) {
					e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, r), q.scissor(T.copy(F).multiplyScalar(L).floor())
				}, this.getScissorTest = function() {
					return O
				}, this.setScissorTest = function(e) {
					q.setScissorTest(O = e)
				}, this.setOpaqueSort = function(e) {
					I = e
				}, this.setTransparentSort = function(e) {
					P = e
				}, this.getClearColor = function(e) {
					return e.copy(ue.getClearColor())
				}, this.setClearColor = function() {
					ue.setClearColor.apply(ue, arguments)
				}, this.getClearAlpha = function() {
					return ue.getClearAlpha()
				}, this.setClearAlpha = function() {
					ue.setClearAlpha.apply(ue, arguments)
				}, this.clear = function(e, t, n) {
					let r = 0;
					(void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === n || n) && (r |= 1024), ye.clear(r)
				}, this.clearColor = function() {
					this.clear(!0, !1, !1)
				}, this.clearDepth = function() {
					this.clear(!1, !0, !1)
				}, this.clearStencil = function() {
					this.clear(!1, !1, !0)
				}, this.dispose = function() {
					t.removeEventListener("webglcontextlost", Me, !1), t.removeEventListener("webglcontextrestored", Se, !1), ae.dispose(), oe.dispose(), Y.dispose(), $.dispose(), ee.dispose(), re.dispose(), ve.dispose(), ie.dispose(), be.dispose(), be.removeEventListener("sessionstart", Ce), be.removeEventListener("sessionend", Be), U && (U.dispose(), U = null), Ie.stop()
				}, this.renderBufferDirect = function(e, t, n, r, i, s) {
					null === t && (t = W);
					const a = i.isMesh && i.matrixWorld.determinant() < 0,
						o = function(e, t, n, r, i) {
							!0 !== t.isScene && (t = W);
							Q.resetTextureUnits();
							const s = t.fog,
								a = r.isMeshStandardMaterial ? t.environment : null,
								o = null === M ? x.outputEncoding : M.texture.encoding,
								l = (r.isMeshStandardMaterial ? ee : $).get(r.envMap || a),
								c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
								u = !!r.normalMap && !!n.attributes.tangent,
								h = !!n.morphAttributes.position,
								d = !!n.morphAttributes.normal,
								f = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
								m = r.toneMapped ? x.toneMapping : Z,
								g = Y.get(r),
								v = p.state.lights;
							if (!0 === k && (!0 === G || e !== S)) {
								const t = e === S && r.id === A;
								le.setState(r, e, t)
							}
							let y = !1;
							r.version === g.__version ? g.needsLights && g.lightsStateVersion !== v.state.version || g.outputEncoding !== o || i.isInstancedMesh && !1 === g.instancing ? y = !0 : i.isInstancedMesh || !0 !== g.instancing ? i.isSkinnedMesh && !1 === g.skinning ? y = !0 : i.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || r.fog && g.fog !== s ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === le.numPlanes && g.numIntersection === le.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== u || g.morphTargets !== h || g.morphNormals !== d || g.toneMapping !== m || !0 === X.isWebGL2 && g.morphTargetsCount !== f) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, g.__version = r.version);
							let _ = g.currentProgram;
							!0 === y && (_ = Ne(r, t, i));
							let b = !1,
								w = !1,
								E = !1;
							const T = _.getUniforms(),
								C = g.uniforms;
							q.useProgram(_.program) && (b = !0, w = !0, E = !0);
							r.id !== A && (A = r.id, w = !0);
							if (b || S !== e) {
								if (T.setValue(ye, "projectionMatrix", e.projectionMatrix), X.logarithmicDepthBuffer && T.setValue(ye, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), S !== e && (S = e, w = !0, E = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
									const t = T.map.cameraPosition;
									void 0 !== t && t.setValue(ye, V.setFromMatrixPosition(e.matrixWorld))
								}(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && T.setValue(ye, "isOrthographic", !0 === e.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && T.setValue(ye, "viewMatrix", e.matrixWorldInverse)
							}
							if (i.isSkinnedMesh) {
								T.setOptional(ye, i, "bindMatrix"), T.setOptional(ye, i, "bindMatrixInverse");
								const e = i.skeleton;
								e && (X.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), T.setValue(ye, "boneTexture", e.boneTexture, Q), T.setValue(ye, "boneTextureSize", e.boneTextureSize)) : T.setOptional(ye, e, "boneMatrices"))
							}!n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || he.update(i, n, r, _);
							(w || g.receiveShadow !== i.receiveShadow) && (g.receiveShadow = i.receiveShadow, T.setValue(ye, "receiveShadow", i.receiveShadow));
							w && (T.setValue(ye, "toneMappingExposure", x.toneMappingExposure), g.needsLights && (I = E, (B = C).ambientLightColor.needsUpdate = I, B.lightProbe.needsUpdate = I, B.directionalLights.needsUpdate = I, B.directionalLightShadows.needsUpdate = I, B.pointLights.needsUpdate = I, B.pointLightShadows.needsUpdate = I, B.spotLights.needsUpdate = I, B.spotLightShadows.needsUpdate = I, B.rectAreaLights.needsUpdate = I, B.hemisphereLights.needsUpdate = I), s && r.fog && se.refreshFogUniforms(C, s), se.refreshMaterialUniforms(C, r, L, R, U), Ro.upload(ye, g.uniformsList, C, Q));
							var B, I;
							r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Ro.upload(ye, g.uniformsList, C, Q), r.uniformsNeedUpdate = !1);
							r.isSpriteMaterial && T.setValue(ye, "center", i.center);
							return T.setValue(ye, "modelViewMatrix", i.modelViewMatrix), T.setValue(ye, "normalMatrix", i.normalMatrix), T.setValue(ye, "modelMatrix", i.matrixWorld), _
						}(e, t, n, r, i);
					q.setMaterial(r, a);
					let l = n.index;
					const c = n.attributes.position;
					if (null === l) {
						if (void 0 === c || 0 === c.count) return
					} else if (0 === l.count) return;
					let u, h = 1;
					!0 === r.wireframe && (l = ne.getWireframeAttribute(n), h = 2), ve.setup(i, r, o, n, l);
					let d = pe;
					null !== l && (u = te.get(l), d = me, d.setIndex(u));
					const f = null !== l ? l.count : c.count,
						m = n.drawRange.start * h,
						g = n.drawRange.count * h,
						v = null !== s ? s.start * h : 0,
						y = null !== s ? s.count * h : 1 / 0,
						_ = Math.max(m, v),
						b = Math.min(f, m + g, v + y) - 1,
						w = Math.max(0, b - _ + 1);
					if (0 !== w) {
						if (i.isMesh) !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * j()), d.setMode(1)) : d.setMode(4);
						else if (i.isLine) {
							let e = r.linewidth;
							void 0 === e && (e = 1), q.setLineWidth(e * j()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
						} else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
						if (i.isInstancedMesh) d.renderInstances(_, w, i.count);
						else if (n.isInstancedBufferGeometry) {
							const e = Math.min(n.instanceCount, n._maxInstanceCount);
							d.renderInstances(_, w, e)
						} else d.render(_, w)
					}
				}, this.compile = function(e, t) {
					p = oe.get(e), p.init(), y.push(p), e.traverseVisible((function(e) {
						e.isLight && e.layers.test(t.layers) && (p.pushLight(e), e.castShadow && p.pushShadow(e))
					})), p.setupLights(x.physicallyCorrectLights), e.traverse((function(t) {
						const n = t.material;
						if (n)
							if (Array.isArray(n))
								for (let r = 0; r < n.length; r++) {
									Ne(n[r], e, t)
								} else Ne(n, e, t)
					})), y.pop(), p = null
				};
				let Te = null;

				function Ce() {
					Ie.stop()
				}

				function Be() {
					Ie.start()
				}
				const Ie = new Is;

				function Pe(e, t, n, r) {
					if (!1 === e.visible) return;
					if (e.layers.test(t.layers))
						if (e.isGroup) n = e.renderOrder;
						else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
					else if (e.isLight) p.pushLight(e), e.castShadow && p.pushShadow(e);
					else if (e.isSprite) {
						if (!e.frustumCulled || H.intersectsSprite(e)) {
							r && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
							const t = re.update(e),
								i = e.material;
							i.visible && d.push(e, t, i, n, V.z, null)
						}
					} else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== K.render.frame && (e.skeleton.update(), e.skeleton.frame = K.render.frame), !e.frustumCulled || H.intersectsObject(e))) {
						r && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
						const t = re.update(e),
							i = e.material;
						if (Array.isArray(i)) {
							const r = t.groups;
							for (let s = 0, a = r.length; s < a; s++) {
								const a = r[s],
									o = i[a.materialIndex];
								o && o.visible && d.push(e, t, o, n, V.z, a)
							}
						} else i.visible && d.push(e, t, i, n, V.z, null)
					}
					const i = e.children;
					for (let s = 0, a = i.length; s < a; s++) Pe(i[s], t, n, r)
				}

				function De(e, t, n, r) {
					const i = e.opaque,
						s = e.transmissive,
						a = e.transparent;
					p.setupLightsView(n), s.length > 0 && function(e, t, n) {
						if (null === U) {
							const e = !0 === o && !0 === X.isWebGL2;
							U = new(e ? nr : er)(1024, 1024, {
								generateMipmaps: !0,
								type: null !== ge.convert(Le) ? Le : Ae,
								minFilter: we,
								magFilter: fe,
								wrapS: de,
								wrapT: de,
								useRenderToTexture: J.has("WEBGL_multisampled_render_to_texture")
							})
						}
						const r = x.getRenderTarget();
						x.setRenderTarget(U), x.clear();
						const i = x.toneMapping;
						x.toneMapping = Z, Fe(e, t, n), x.toneMapping = i, Q.updateMultisampleRenderTarget(U), Q.updateRenderTargetMipmap(U), x.setRenderTarget(r)
					}(i, t, n), r && q.viewport(E.copy(r)), i.length > 0 && Fe(i, t, n), s.length > 0 && Fe(s, t, n), a.length > 0 && Fe(a, t, n)
				}

				function Fe(e, t, n) {
					const r = !0 === t.isScene ? t.overrideMaterial : null;
					for (let i = 0, s = e.length; i < s; i++) {
						const s = e[i],
							a = s.object,
							o = s.geometry,
							l = null === r ? s.material : r,
							c = s.group;
						a.layers.test(n.layers) && Oe(a, t, n, o, l, c)
					}
				}

				function Oe(e, t, n, r, i, s) {
					e.onBeforeRender(x, t, n, r, i, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(x, t, n, r, e, s), !0 === i.transparent && i.side === g ? (i.side = m, i.needsUpdate = !0, x.renderBufferDirect(n, t, r, i, e, s), i.side = f, i.needsUpdate = !0, x.renderBufferDirect(n, t, r, i, e, s), i.side = g) : x.renderBufferDirect(n, t, r, i, e, s), e.onAfterRender(x, t, n, r, i, s)
				}

				function Ne(e, t, n) {
					!0 !== t.isScene && (t = W);
					const r = Y.get(e),
						i = p.state.lights,
						s = p.state.shadowsArray,
						a = i.state.version,
						o = ie.getParameters(e, i.state, s, t, n),
						l = ie.getProgramCacheKey(o);
					let c = r.programs;
					r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ee : $).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", Ee), c = new Map, r.programs = c);
					let u = c.get(l);
					if (void 0 !== u) {
						if (r.currentProgram === u && r.lightsStateVersion === a) return ke(e, o), u
					} else o.uniforms = ie.getUniforms(e), e.onBuild(n, o, x), e.onBeforeCompile(o, x), u = ie.acquireProgram(o, l), c.set(l, u), r.uniforms = o.uniforms;
					const h = r.uniforms;
					(e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = le.uniform), ke(e, o), r.needsLights = function(e) {
						return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
					}(e), r.lightsStateVersion = a, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
					const d = u.getUniforms(),
						f = Ro.seqWithValue(d.seq, h);
					return r.currentProgram = u, r.uniformsList = f, u
				}

				function ke(e, t) {
					const n = Y.get(e);
					n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
				}
				Ie.setAnimationLoop((function(e) {
					Te && Te(e)
				})), "undefined" !== typeof window && Ie.setContext(window), this.setAnimationLoop = function(e) {
					Te = e, be.setAnimationLoop(e), null === e ? Ie.stop() : Ie.start()
				}, be.addEventListener("sessionstart", Ce), be.addEventListener("sessionend", Be), this.render = function(e, t) {
					if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
					if (!0 === _) return;
					!0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === be.enabled && !0 === be.isPresenting && (!0 === be.cameraAutoUpdate && be.updateCamera(t), t = be.getCamera()), !0 === e.isScene && e.onBeforeRender(x, e, t, M), p = oe.get(e, y.length), p.init(), y.push(p), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), H.setFromProjectionMatrix(z), G = this.localClippingEnabled, k = le.init(this.clippingPlanes, G, t), d = ae.get(e, v.length), d.init(), v.push(d), Pe(e, t, 0, x.sortObjects), d.finish(), !0 === x.sortObjects && d.sort(I, P), !0 === k && le.beginShadows();
					const n = p.state.shadowsArray;
					if (ce.render(n, e, t), !0 === k && le.endShadows(), !0 === this.info.autoReset && this.info.reset(), ue.render(d, e), p.setupLights(x.physicallyCorrectLights), t.isArrayCamera) {
						const n = t.cameras;
						for (let t = 0, r = n.length; t < r; t++) {
							const r = n[t];
							De(d, e, r, r.viewport)
						}
					} else De(d, e, t);
					null !== M && (Q.updateMultisampleRenderTarget(M), Q.updateRenderTargetMipmap(M)), !0 === e.isScene && e.onAfterRender(x, e, t), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1), ve.resetDefaultState(), A = -1, S = null, y.pop(), p = y.length > 0 ? y[y.length - 1] : null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null
				}, this.getActiveCubeFace = function() {
					return b
				}, this.getActiveMipmapLevel = function() {
					return w
				}, this.getRenderTarget = function() {
					return M
				}, this.setRenderTargetTextures = function(e, t, n) {
					Y.get(e.texture).__webglTexture = t, Y.get(e.depthTexture).__webglTexture = n;
					const r = Y.get(e);
					r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || e.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), e.useRenderToTexture = !1, e.useRenderbuffer = !0))
				}, this.setRenderTargetFramebuffer = function(e, t) {
					const n = Y.get(e);
					n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
				}, this.setRenderTarget = function(e, t = 0, n = 0) {
					M = e, b = t, w = n;
					let r = !0;
					if (e) {
						const t = Y.get(e);
						void 0 !== t.__useDefaultFramebuffer ? (q.bindFramebuffer(36160, null), r = !1) : void 0 === t.__webglFramebuffer ? Q.setupRenderTarget(e) : t.__hasExternalTextures && Q.rebindTextures(e, Y.get(e.texture).__webglTexture, Y.get(e.depthTexture).__webglTexture)
					}
					let i = null,
						s = !1,
						a = !1;
					if (e) {
						const n = e.texture;
						(n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
						const r = Y.get(e).__webglFramebuffer;
						e.isWebGLCubeRenderTarget ? (i = r[t], s = !0) : i = e.useRenderbuffer ? Y.get(e).__webglMultisampledFramebuffer : r, E.copy(e.viewport), T.copy(e.scissor), C = e.scissorTest
					} else E.copy(D).multiplyScalar(L).floor(), T.copy(F).multiplyScalar(L).floor(), C = O;
					if (q.bindFramebuffer(36160, i) && X.drawBuffers && r) {
						let t = !1;
						if (e)
							if (e.isWebGLMultipleRenderTargets) {
								const n = e.texture;
								if (N.length !== n.length || 36064 !== N[0]) {
									for (let e = 0, t = n.length; e < t; e++) N[e] = 36064 + e;
									N.length = n.length, t = !0
								}
							} else 1 === N.length && 36064 === N[0] || (N[0] = 36064, N.length = 1, t = !0);
						else 1 === N.length && 1029 === N[0] || (N[0] = 1029, N.length = 1, t = !0);
						t && (X.isWebGL2 ? ye.drawBuffers(N) : J.get("WEBGL_draw_buffers").drawBuffersWEBGL(N))
					}
					if (q.viewport(E), q.scissor(T), q.setScissorTest(C), s) {
						const r = Y.get(e.texture);
						ye.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, n)
					} else if (a) {
						const r = Y.get(e.texture),
							i = t || 0;
						ye.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
					}
					A = -1
				}, this.readRenderTargetPixels = function(e, t, n, r, i, s, a) {
					if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
					let o = Y.get(e).__webglFramebuffer;
					if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
						q.bindFramebuffer(36160, o);
						try {
							const a = e.texture,
								o = a.format,
								l = a.type;
							if (o !== He && ge.convert(o) !== ye.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
							const c = l === Le && (J.has("EXT_color_buffer_half_float") || X.isWebGL2 && J.has("EXT_color_buffer_float"));
							if (l !== Ae && ge.convert(l) !== ye.getParameter(35738) && (l !== Re || !(X.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float"))) && !c) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
							36053 === ye.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ye.readPixels(t, n, r, i, ge.convert(o), ge.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
						} finally {
							const e = null !== M ? Y.get(M).__webglFramebuffer : null;
							q.bindFramebuffer(36160, e)
						}
					}
				}, this.copyFramebufferToTexture = function(e, t, n = 0) {
					if (!0 !== t.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
					const r = Math.pow(2, -n),
						i = Math.floor(t.image.width * r),
						s = Math.floor(t.image.height * r);
					Q.setTexture2D(t, 0), ye.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, i, s), q.unbindTexture()
				}, this.copyTextureToTexture = function(e, t, n, r = 0) {
					const i = t.image.width,
						s = t.image.height,
						a = ge.convert(n.format),
						o = ge.convert(n.type);
					Q.setTexture2D(n, 0), ye.pixelStorei(37440, n.flipY), ye.pixelStorei(37441, n.premultiplyAlpha), ye.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ye.texSubImage2D(3553, r, e.x, e.y, i, s, a, o, t.image.data) : t.isCompressedTexture ? ye.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ye.texSubImage2D(3553, r, e.x, e.y, a, o, t.image), 0 === r && n.generateMipmaps && ye.generateMipmap(3553), q.unbindTexture()
				}, this.copyTextureToTexture3D = function(e, t, n, r, i = 0) {
					if (x.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
					const s = e.max.x - e.min.x + 1,
						a = e.max.y - e.min.y + 1,
						o = e.max.z - e.min.z + 1,
						l = ge.convert(r.format),
						c = ge.convert(r.type);
					let u;
					if (r.isDataTexture3D) Q.setTexture3D(r, 0), u = 32879;
					else {
						if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
						Q.setTexture2DArray(r, 0), u = 35866
					}
					ye.pixelStorei(37440, r.flipY), ye.pixelStorei(37441, r.premultiplyAlpha), ye.pixelStorei(3317, r.unpackAlignment);
					const h = ye.getParameter(3314),
						d = ye.getParameter(32878),
						p = ye.getParameter(3316),
						f = ye.getParameter(3315),
						m = ye.getParameter(32877),
						g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
					ye.pixelStorei(3314, g.width), ye.pixelStorei(32878, g.height), ye.pixelStorei(3316, e.min.x), ye.pixelStorei(3315, e.min.y), ye.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? ye.texSubImage3D(u, i, t.x, t.y, t.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ye.compressedTexSubImage3D(u, i, t.x, t.y, t.z, s, a, o, l, g.data)) : ye.texSubImage3D(u, i, t.x, t.y, t.z, s, a, o, l, c, g), ye.pixelStorei(3314, h), ye.pixelStorei(32878, d), ye.pixelStorei(3316, p), ye.pixelStorei(3315, f), ye.pixelStorei(32877, m), 0 === i && r.generateMipmaps && ye.generateMipmap(u), q.unbindTexture()
				}, this.initTexture = function(e) {
					Q.setTexture2D(e, 0), q.unbindTexture()
				}, this.resetState = function() {
					b = 0, w = 0, M = null, q.reset(), ve.reset()
				}, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
					detail: this
				}))
			}
			Sl.prototype.isWebGLRenderer = !0;
			class El extends Sl {}
			El.prototype.isWebGL1Renderer = !0;
			class Tl {
				constructor(e, t = 25e-5) {
					this.name = "", this.color = new Ei(e), this.density = t
				}
				clone() {
					return new Tl(this.color, this.density)
				}
				toJSON() {
					return {
						type: "FogExp2",
						color: this.color.getHex(),
						density: this.density
					}
				}
			}
			Tl.prototype.isFogExp2 = !0;
			class Cl {
				constructor(e, t = 1, n = 1e3) {
					this.name = "", this.color = new Ei(e), this.near = t, this.far = n
				}
				clone() {
					return new Cl(this.color, this.near, this.far)
				}
				toJSON() {
					return {
						type: "Fog",
						color: this.color.getHex(),
						near: this.near,
						far: this.far
					}
				}
			}
			Cl.prototype.isFog = !0;
			class Bl extends ai {
				constructor() {
					super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
						detail: this
					}))
				}
				copy(e, t) {
					return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
				}
			}
			Bl.prototype.isScene = !0;
			class Rl {
				constructor(e, t) {
					this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = yn, this.updateRange = {
						offset: 0,
						count: -1
					}, this.version = 0, this.uuid = Dn()
				}
				onUploadCallback() {}
				set needsUpdate(e) {
					!0 === e && this.version++
				}
				setUsage(e) {
					return this.usage = e, this
				}
				copy(e) {
					return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
				}
				copyAt(e, t, n) {
					e *= this.stride, n *= t.stride;
					for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
					return this
				}
				set(e, t = 0) {
					return this.array.set(e, t), this
				}
				clone(e) {
					void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Dn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
					const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
						n = new this.constructor(t, this.stride);
					return n.setUsage(this.usage), n
				}
				onUpload(e) {
					return this.onUploadCallback = e, this
				}
				toJSON(e) {
					return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Dn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
						uuid: this.uuid,
						buffer: this.array.buffer._uuid,
						type: this.array.constructor.name,
						stride: this.stride
					}
				}
			}
			Rl.prototype.isInterleavedBuffer = !0;
			const Ll = new ir;
			class Il {
				constructor(e, t, n, r = !1) {
					this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
				}
				get count() {
					return this.data.count
				}
				get array() {
					return this.data.array
				}
				set needsUpdate(e) {
					this.data.needsUpdate = e
				}
				applyMatrix4(e) {
					for (let t = 0, n = this.data.count; t < n; t++) Ll.x = this.getX(t), Ll.y = this.getY(t), Ll.z = this.getZ(t), Ll.applyMatrix4(e), this.setXYZ(t, Ll.x, Ll.y, Ll.z);
					return this
				}
				applyNormalMatrix(e) {
					for (let t = 0, n = this.count; t < n; t++) Ll.x = this.getX(t), Ll.y = this.getY(t), Ll.z = this.getZ(t), Ll.applyNormalMatrix(e), this.setXYZ(t, Ll.x, Ll.y, Ll.z);
					return this
				}
				transformDirection(e) {
					for (let t = 0, n = this.count; t < n; t++) Ll.x = this.getX(t), Ll.y = this.getY(t), Ll.z = this.getZ(t), Ll.transformDirection(e), this.setXYZ(t, Ll.x, Ll.y, Ll.z);
					return this
				}
				setX(e, t) {
					return this.data.array[e * this.data.stride + this.offset] = t, this
				}
				setY(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 1] = t, this
				}
				setZ(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 2] = t, this
				}
				setW(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 3] = t, this
				}
				getX(e) {
					return this.data.array[e * this.data.stride + this.offset]
				}
				getY(e) {
					return this.data.array[e * this.data.stride + this.offset + 1]
				}
				getZ(e) {
					return this.data.array[e * this.data.stride + this.offset + 2]
				}
				getW(e) {
					return this.data.array[e * this.data.stride + this.offset + 3]
				}
				setXY(e, t, n) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
				}
				setXYZ(e, t, n, r) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
				}
				setXYZW(e, t, n, r, i) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
				}
				clone(e) {
					if (void 0 === e) {
						console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
						const e = [];
						for (let t = 0; t < this.count; t++) {
							const n = t * this.data.stride + this.offset;
							for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
						}
						return new Ri(new this.array.constructor(e), this.itemSize, this.normalized)
					}
					return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Il(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
				}
				toJSON(e) {
					if (void 0 === e) {
						console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
						const e = [];
						for (let t = 0; t < this.count; t++) {
							const n = t * this.data.stride + this.offset;
							for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
						}
						return {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: e,
							normalized: this.normalized
						}
					}
					return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
						isInterleavedBufferAttribute: !0,
						itemSize: this.itemSize,
						data: this.data.uuid,
						offset: this.offset,
						normalized: this.normalized
					}
				}
			}
			Il.prototype.isInterleavedBufferAttribute = !0;
			class Pl extends xi {
				constructor(e) {
					super(), this.type = "SpriteMaterial", this.color = new Ei(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
				}
			}
			let Dl;
			Pl.prototype.isSpriteMaterial = !0;
			const Fl = new ir,
				Ol = new ir,
				Nl = new ir,
				Hl = new zn,
				kl = new zn,
				Gl = new Fr,
				Ul = new ir,
				zl = new ir,
				Vl = new ir,
				Wl = new zn,
				jl = new zn,
				Jl = new zn;
			class Xl extends ai {
				constructor(e) {
					if (super(), this.type = "Sprite", void 0 === Dl) {
						Dl = new qi;
						const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
							t = new Rl(e, 5);
						Dl.setIndex([0, 1, 2, 0, 2, 3]), Dl.setAttribute("position", new Il(t, 3, 0, !1)), Dl.setAttribute("uv", new Il(t, 2, 3, !1))
					}
					this.geometry = Dl, this.material = void 0 !== e ? e : new Pl, this.center = new zn(.5, .5)
				}
				raycast(e, t) {
					null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ol.setFromMatrixScale(this.matrixWorld), Gl.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Nl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ol.multiplyScalar(-Nl.z);
					const n = this.material.rotation;
					let r, i;
					0 !== n && (i = Math.cos(n), r = Math.sin(n));
					const s = this.center;
					ql(Ul.set(-.5, -.5, 0), Nl, s, Ol, r, i), ql(zl.set(.5, -.5, 0), Nl, s, Ol, r, i), ql(Vl.set(.5, .5, 0), Nl, s, Ol, r, i), Wl.set(0, 0), jl.set(1, 0), Jl.set(1, 1);
					let a = e.ray.intersectTriangle(Ul, zl, Vl, !1, Fl);
					if (null === a && (ql(zl.set(-.5, .5, 0), Nl, s, Ol, r, i), jl.set(0, 1), a = e.ray.intersectTriangle(Ul, Vl, zl, !1, Fl), null === a)) return;
					const o = e.ray.origin.distanceTo(Fl);
					o < e.near || o > e.far || t.push({
						distance: o,
						point: Fl.clone(),
						uv: vi.getUV(Fl, Ul, zl, Vl, Wl, jl, Jl, new zn),
						face: null,
						object: this
					})
				}
				copy(e) {
					return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
				}
			}

			function ql(e, t, n, r, i, s) {
				Hl.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (kl.x = s * Hl.x - i * Hl.y, kl.y = i * Hl.x + s * Hl.y) : kl.copy(Hl), e.copy(t), e.x += kl.x, e.y += kl.y, e.applyMatrix4(Gl)
			}
			Xl.prototype.isSprite = !0;
			const Kl = new ir,
				Yl = new ir;
			class Ql extends ai {
				constructor() {
					super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
						levels: {
							enumerable: !0,
							value: []
						},
						isLOD: {
							value: !0
						}
					}), this.autoUpdate = !0
				}
				copy(e) {
					super.copy(e, !1);
					const t = e.levels;
					for (let n = 0, r = t.length; n < r; n++) {
						const e = t[n];
						this.addLevel(e.object.clone(), e.distance)
					}
					return this.autoUpdate = e.autoUpdate, this
				}
				addLevel(e, t = 0) {
					t = Math.abs(t);
					const n = this.levels;
					let r;
					for (r = 0; r < n.length && !(t < n[r].distance); r++);
					return n.splice(r, 0, {
						distance: t,
						object: e
					}), this.add(e), this
				}
				getCurrentLevel() {
					return this._currentLevel
				}
				getObjectForDistance(e) {
					const t = this.levels;
					if (t.length > 0) {
						let n, r;
						for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
						return t[n - 1].object
					}
					return null
				}
				raycast(e, t) {
					if (this.levels.length > 0) {
						Kl.setFromMatrixPosition(this.matrixWorld);
						const n = e.ray.origin.distanceTo(Kl);
						this.getObjectForDistance(n).raycast(e, t)
					}
				}
				update(e) {
					const t = this.levels;
					if (t.length > 1) {
						Kl.setFromMatrixPosition(e.matrixWorld), Yl.setFromMatrixPosition(this.matrixWorld);
						const n = Kl.distanceTo(Yl) / e.zoom;
						let r, i;
						for (t[0].object.visible = !0, r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
						for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1
					}
				}
				toJSON(e) {
					const t = super.toJSON(e);
					!1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
					const n = this.levels;
					for (let r = 0, i = n.length; r < i; r++) {
						const e = n[r];
						t.object.levels.push({
							object: e.object.uuid,
							distance: e.distance
						})
					}
					return t
				}
			}
			const Zl = new ir,
				$l = new $n,
				ec = new $n,
				tc = new ir,
				nc = new Fr;
			class rc extends ds {
				constructor(e, t) {
					super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Fr, this.bindMatrixInverse = new Fr
				}
				copy(e) {
					return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
				}
				bind(e, t) {
					this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
				}
				pose() {
					this.skeleton.pose()
				}
				normalizeSkinWeights() {
					const e = new $n,
						t = this.geometry.attributes.skinWeight;
					for (let n = 0, r = t.count; n < r; n++) {
						e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
						const r = 1 / e.manhattanLength();
						r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
					}
				}
				updateMatrixWorld(e) {
					super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
				}
				boneTransform(e, t) {
					const n = this.skeleton,
						r = this.geometry;
					$l.fromBufferAttribute(r.attributes.skinIndex, e), ec.fromBufferAttribute(r.attributes.skinWeight, e), Zl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
					for (let i = 0; i < 4; i++) {
						const e = ec.getComponent(i);
						if (0 !== e) {
							const r = $l.getComponent(i);
							nc.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(tc.copy(Zl).applyMatrix4(nc), e)
						}
					}
					return t.applyMatrix4(this.bindMatrixInverse)
				}
			}
			rc.prototype.isSkinnedMesh = !0;
			class ic extends ai {
				constructor() {
					super(), this.type = "Bone"
				}
			}
			ic.prototype.isBone = !0;
			class sc extends Qn {
				constructor(e = null, t = 1, n = 1, r, i, s, a, o, l = fe, c = fe, u, h) {
					super(null, s, a, o, l, c, r, i, u, h), this.image = {
						data: e,
						width: t,
						height: n
					}, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}
			sc.prototype.isDataTexture = !0;
			const ac = new Fr,
				oc = new Fr;
			class lc {
				constructor(e = [], t = []) {
					this.uuid = Dn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
				}
				init() {
					const e = this.bones,
						t = this.boneInverses;
					if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
					else if (e.length !== t.length) {
						console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
						for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Fr)
					}
				}
				calculateInverses() {
					this.boneInverses.length = 0;
					for (let e = 0, t = this.bones.length; e < t; e++) {
						const t = new Fr;
						this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
					}
				}
				pose() {
					for (let e = 0, t = this.bones.length; e < t; e++) {
						const t = this.bones[e];
						t && t.matrixWorld.copy(this.boneInverses[e]).invert()
					}
					for (let e = 0, t = this.bones.length; e < t; e++) {
						const t = this.bones[e];
						t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
					}
				}
				update() {
					const e = this.bones,
						t = this.boneInverses,
						n = this.boneMatrices,
						r = this.boneTexture;
					for (let i = 0, s = e.length; i < s; i++) {
						const r = e[i] ? e[i].matrixWorld : oc;
						ac.multiplyMatrices(r, t[i]), ac.toArray(n, 16 * i)
					}
					null !== r && (r.needsUpdate = !0)
				}
				clone() {
					return new lc(this.bones, this.boneInverses)
				}
				computeBoneTexture() {
					let e = Math.sqrt(4 * this.bones.length);
					e = kn(e), e = Math.max(e, 4);
					const t = new Float32Array(e * e * 4);
					t.set(this.boneMatrices);
					const n = new sc(t, e, e, He, Re);
					return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
				}
				getBoneByName(e) {
					for (let t = 0, n = this.bones.length; t < n; t++) {
						const n = this.bones[t];
						if (n.name === e) return n
					}
				}
				dispose() {
					null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
				}
				fromJSON(e, t) {
					this.uuid = e.uuid;
					for (let n = 0, r = e.bones.length; n < r; n++) {
						const r = e.bones[n];
						let i = t[r];
						void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new ic), this.bones.push(i), this.boneInverses.push((new Fr).fromArray(e.boneInverses[n]))
					}
					return this.init(), this
				}
				toJSON() {
					const e = {
						metadata: {
							version: 4.5,
							type: "Skeleton",
							generator: "Skeleton.toJSON"
						},
						bones: [],
						boneInverses: []
					};
					e.uuid = this.uuid;
					const t = this.bones,
						n = this.boneInverses;
					for (let r = 0, i = t.length; r < i; r++) {
						const i = t[r];
						e.bones.push(i.uuid);
						const s = n[r];
						e.boneInverses.push(s.toArray())
					}
					return e
				}
			}
			class cc extends Ri {
				constructor(e, t, n, r = 1) {
					"number" === typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = r
				}
				copy(e) {
					return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
				}
				toJSON() {
					const e = super.toJSON();
					return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
				}
			}
			cc.prototype.isInstancedBufferAttribute = !0;
			const uc = new Fr,
				hc = new Fr,
				dc = [],
				pc = new ds;
			class fc extends ds {
				constructor(e, t, n) {
					super(e, t), this.instanceMatrix = new cc(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
				}
				copy(e) {
					return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
				}
				getColorAt(e, t) {
					t.fromArray(this.instanceColor.array, 3 * e)
				}
				getMatrixAt(e, t) {
					t.fromArray(this.instanceMatrix.array, 16 * e)
				}
				raycast(e, t) {
					const n = this.matrixWorld,
						r = this.count;
					if (pc.geometry = this.geometry, pc.material = this.material, void 0 !== pc.material)
						for (let i = 0; i < r; i++) {
							this.getMatrixAt(i, uc), hc.multiplyMatrices(n, uc), pc.matrixWorld = hc, pc.raycast(e, dc);
							for (let e = 0, n = dc.length; e < n; e++) {
								const n = dc[e];
								n.instanceId = i, n.object = this, t.push(n)
							}
							dc.length = 0
						}
				}
				setColorAt(e, t) {
					null === this.instanceColor && (this.instanceColor = new cc(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
				}
				setMatrixAt(e, t) {
					t.toArray(this.instanceMatrix.array, 16 * e)
				}
				updateMorphTargets() {}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			fc.prototype.isInstancedMesh = !0;
			class mc extends xi {
				constructor(e) {
					super(), this.type = "LineBasicMaterial", this.color = new Ei(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
				}
			}
			mc.prototype.isLineBasicMaterial = !0;
			const gc = new ir,
				vc = new ir,
				yc = new Fr,
				xc = new Dr,
				_c = new Er;
			class bc extends ai {
				constructor(e = new qi, t = new mc) {
					super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
				}
				copy(e) {
					return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
				}
				computeLineDistances() {
					const e = this.geometry;
					if (e.isBufferGeometry)
						if (null === e.index) {
							const t = e.attributes.position,
								n = [0];
							for (let e = 1, r = t.count; e < r; e++) gc.fromBufferAttribute(t, e - 1), vc.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += gc.distanceTo(vc);
							e.setAttribute("lineDistance", new ki(n, 1))
						} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
					else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					return this
				}
				raycast(e, t) {
					const n = this.geometry,
						r = this.matrixWorld,
						i = e.params.Line.threshold,
						s = n.drawRange;
					if (null === n.boundingSphere && n.computeBoundingSphere(), _c.copy(n.boundingSphere), _c.applyMatrix4(r), _c.radius += i, !1 === e.ray.intersectsSphere(_c)) return;
					yc.copy(r).invert(), xc.copy(e.ray).applyMatrix4(yc);
					const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						o = a * a,
						l = new ir,
						c = new ir,
						u = new ir,
						h = new ir,
						d = this.isLineSegments ? 2 : 1;
					if (n.isBufferGeometry) {
						const r = n.index,
							i = n.attributes.position;
						if (null !== r) {
							for (let n = Math.max(0, s.start), a = Math.min(r.count, s.start + s.count) - 1; n < a; n += d) {
								const s = r.getX(n),
									a = r.getX(n + 1);
								l.fromBufferAttribute(i, s), c.fromBufferAttribute(i, a);
								if (xc.distanceSqToSegment(l, c, h, u) > o) continue;
								h.applyMatrix4(this.matrixWorld);
								const d = e.ray.origin.distanceTo(h);
								d < e.near || d > e.far || t.push({
									distance: d,
									point: u.clone().applyMatrix4(this.matrixWorld),
									index: n,
									face: null,
									faceIndex: null,
									object: this
								})
							}
						} else {
							for (let n = Math.max(0, s.start), r = Math.min(i.count, s.start + s.count) - 1; n < r; n += d) {
								l.fromBufferAttribute(i, n), c.fromBufferAttribute(i, n + 1);
								if (xc.distanceSqToSegment(l, c, h, u) > o) continue;
								h.applyMatrix4(this.matrixWorld);
								const r = e.ray.origin.distanceTo(h);
								r < e.near || r > e.far || t.push({
									distance: r,
									point: u.clone().applyMatrix4(this.matrixWorld),
									index: n,
									face: null,
									faceIndex: null,
									object: this
								})
							}
						}
					} else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
				updateMorphTargets() {
					const e = this.geometry;
					if (e.isBufferGeometry) {
						const t = e.morphAttributes,
							n = Object.keys(t);
						if (n.length > 0) {
							const e = t[n[0]];
							if (void 0 !== e) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t].name || String(t);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
								}
							}
						}
					} else {
						const t = e.morphTargets;
						void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
			}
			bc.prototype.isLine = !0;
			const wc = new ir,
				Mc = new ir;
			class Ac extends bc {
				constructor(e, t) {
					super(e, t), this.type = "LineSegments"
				}
				computeLineDistances() {
					const e = this.geometry;
					if (e.isBufferGeometry)
						if (null === e.index) {
							const t = e.attributes.position,
								n = [];
							for (let e = 0, r = t.count; e < r; e += 2) wc.fromBufferAttribute(t, e), Mc.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + wc.distanceTo(Mc);
							e.setAttribute("lineDistance", new ki(n, 1))
						} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
					else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					return this
				}
			}
			Ac.prototype.isLineSegments = !0;
			class Sc extends bc {
				constructor(e, t) {
					super(e, t), this.type = "LineLoop"
				}
			}
			Sc.prototype.isLineLoop = !0;
			class Ec extends xi {
				constructor(e) {
					super(), this.type = "PointsMaterial", this.color = new Ei(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
				}
			}
			Ec.prototype.isPointsMaterial = !0;
			const Tc = new Fr,
				Cc = new Dr,
				Bc = new Er,
				Rc = new ir;
			class Lc extends ai {
				constructor(e = new qi, t = new Ec) {
					super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
				}
				copy(e) {
					return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
				}
				raycast(e, t) {
					const n = this.geometry,
						r = this.matrixWorld,
						i = e.params.Points.threshold,
						s = n.drawRange;
					if (null === n.boundingSphere && n.computeBoundingSphere(), Bc.copy(n.boundingSphere), Bc.applyMatrix4(r), Bc.radius += i, !1 === e.ray.intersectsSphere(Bc)) return;
					Tc.copy(r).invert(), Cc.copy(e.ray).applyMatrix4(Tc);
					const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						o = a * a;
					if (n.isBufferGeometry) {
						const i = n.index,
							a = n.attributes.position;
						if (null !== i) {
							for (let n = Math.max(0, s.start), l = Math.min(i.count, s.start + s.count); n < l; n++) {
								const s = i.getX(n);
								Rc.fromBufferAttribute(a, s), Ic(Rc, s, o, r, e, t, this)
							}
						} else {
							for (let n = Math.max(0, s.start), i = Math.min(a.count, s.start + s.count); n < i; n++) Rc.fromBufferAttribute(a, n), Ic(Rc, n, o, r, e, t, this)
						}
					} else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
				updateMorphTargets() {
					const e = this.geometry;
					if (e.isBufferGeometry) {
						const t = e.morphAttributes,
							n = Object.keys(t);
						if (n.length > 0) {
							const e = t[n[0]];
							if (void 0 !== e) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t].name || String(t);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
								}
							}
						}
					} else {
						const t = e.morphTargets;
						void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
			}

			function Ic(e, t, n, r, i, s, a) {
				const o = Cc.distanceSqToPoint(e);
				if (o < n) {
					const n = new ir;
					Cc.closestPointToPoint(e, n), n.applyMatrix4(r);
					const l = i.ray.origin.distanceTo(n);
					if (l < i.near || l > i.far) return;
					s.push({
						distance: l,
						distanceToRay: Math.sqrt(o),
						point: n,
						index: t,
						face: null,
						object: a
					})
				}
			}
			Lc.prototype.isPoints = !0;
			class Pc extends Qn {
				constructor(e, t, n, r, i, s, a, o, l) {
					super(e, t, n, r, i, s, a, o, l), this.format = void 0 !== a ? a : Ne, this.minFilter = void 0 !== s ? s : xe, this.magFilter = void 0 !== i ? i : xe, this.generateMipmaps = !1;
					const c = this;
					"requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
						c.needsUpdate = !0, e.requestVideoFrameCallback(t)
					}))
				}
				clone() {
					return new this.constructor(this.image).copy(this)
				}
				update() {
					const e = this.image;
					!1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
				}
			}
			Pc.prototype.isVideoTexture = !0;
			class Dc extends Qn {
				constructor(e, t, n) {
					super({
						width: e,
						height: t
					}), this.format = n, this.magFilter = fe, this.minFilter = fe, this.generateMipmaps = !1, this.needsUpdate = !0
				}
			}
			Dc.prototype.isFramebufferTexture = !0;
			class Fc extends Qn {
				constructor(e, t, n, r, i, s, a, o, l, c, u, h) {
					super(null, s, a, o, l, c, r, i, u, h), this.image = {
						width: t,
						height: n
					}, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
				}
			}
			Fc.prototype.isCompressedTexture = !0;
			class Oc extends Qn {
				constructor(e, t, n, r, i, s, a, o, l) {
					super(e, t, n, r, i, s, a, o, l), this.needsUpdate = !0
				}
			}
			Oc.prototype.isCanvasTexture = !0;
			class Nc extends qi {
				constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) {
					super(), this.type = "CircleGeometry", this.parameters = {
						radius: e,
						segments: t,
						thetaStart: n,
						thetaLength: r
					}, t = Math.max(3, t);
					const i = [],
						s = [],
						a = [],
						o = [],
						l = new ir,
						c = new zn;
					s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
					for (let u = 0, h = 3; u <= t; u++, h += 3) {
						const i = n + u / t * r;
						l.x = e * Math.cos(i), l.y = e * Math.sin(i), s.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (s[h] / e + 1) / 2, c.y = (s[h + 1] / e + 1) / 2, o.push(c.x, c.y)
					}
					for (let u = 1; u <= t; u++) i.push(u, u + 1, 0);
					this.setIndex(i), this.setAttribute("position", new ki(s, 3)), this.setAttribute("normal", new ki(a, 3)), this.setAttribute("uv", new ki(o, 2))
				}
				static fromJSON(e) {
					return new Nc(e.radius, e.segments, e.thetaStart, e.thetaLength)
				}
			}
			class Hc extends qi {
				constructor(e = 1, t = 1, n = 1, r = 8, i = 1, s = !1, a = 0, o = 2 * Math.PI) {
					super(), this.type = "CylinderGeometry", this.parameters = {
						radiusTop: e,
						radiusBottom: t,
						height: n,
						radialSegments: r,
						heightSegments: i,
						openEnded: s,
						thetaStart: a,
						thetaLength: o
					};
					const l = this;
					r = Math.floor(r), i = Math.floor(i);
					const c = [],
						u = [],
						h = [],
						d = [];
					let p = 0;
					const f = [],
						m = n / 2;
					let g = 0;

					function v(n) {
						const i = p,
							s = new zn,
							f = new ir;
						let v = 0;
						const y = !0 === n ? e : t,
							x = !0 === n ? 1 : -1;
						for (let e = 1; e <= r; e++) u.push(0, m * x, 0), h.push(0, x, 0), d.push(.5, .5), p++;
						const _ = p;
						for (let e = 0; e <= r; e++) {
							const t = e / r * o + a,
								n = Math.cos(t),
								i = Math.sin(t);
							f.x = y * i, f.y = m * x, f.z = y * n, u.push(f.x, f.y, f.z), h.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * i * x + .5, d.push(s.x, s.y), p++
						}
						for (let e = 0; e < r; e++) {
							const t = i + e,
								r = _ + e;
							!0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), v += 3
						}
						l.addGroup(g, v, !0 === n ? 1 : 2), g += v
					}! function() {
						const s = new ir,
							v = new ir;
						let y = 0;
						const x = (t - e) / n;
						for (let l = 0; l <= i; l++) {
							const c = [],
								g = l / i,
								y = g * (t - e) + e;
							for (let e = 0; e <= r; e++) {
								const t = e / r,
									i = t * o + a,
									l = Math.sin(i),
									f = Math.cos(i);
								v.x = y * l, v.y = -g * n + m, v.z = y * f, u.push(v.x, v.y, v.z), s.set(l, x, f).normalize(), h.push(s.x, s.y, s.z), d.push(t, 1 - g), c.push(p++)
							}
							f.push(c)
						}
						for (let e = 0; e < r; e++)
							for (let t = 0; t < i; t++) {
								const n = f[t][e],
									r = f[t + 1][e],
									i = f[t + 1][e + 1],
									s = f[t][e + 1];
								c.push(n, r, s), c.push(r, i, s), y += 6
							}
						l.addGroup(g, y, 0), g += y
					}(), !1 === s && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new ki(u, 3)), this.setAttribute("normal", new ki(h, 3)), this.setAttribute("uv", new ki(d, 2))
				}
				static fromJSON(e) {
					return new Hc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
				}
			}
			class kc extends Hc {
				constructor(e = 1, t = 1, n = 8, r = 1, i = !1, s = 0, a = 2 * Math.PI) {
					super(0, e, t, n, r, i, s, a), this.type = "ConeGeometry", this.parameters = {
						radius: e,
						height: t,
						radialSegments: n,
						heightSegments: r,
						openEnded: i,
						thetaStart: s,
						thetaLength: a
					}
				}
				static fromJSON(e) {
					return new kc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
				}
			}
			class Gc extends qi {
				constructor(e = [], t = [], n = 1, r = 0) {
					super(), this.type = "PolyhedronGeometry", this.parameters = {
						vertices: e,
						indices: t,
						radius: n,
						detail: r
					};
					const i = [],
						s = [];

					function a(e, t, n, r) {
						const i = r + 1,
							s = [];
						for (let a = 0; a <= i; a++) {
							s[a] = [];
							const r = e.clone().lerp(n, a / i),
								o = t.clone().lerp(n, a / i),
								l = i - a;
							for (let e = 0; e <= l; e++) s[a][e] = 0 === e && a === i ? r : r.clone().lerp(o, e / l)
						}
						for (let a = 0; a < i; a++)
							for (let e = 0; e < 2 * (i - a) - 1; e++) {
								const t = Math.floor(e / 2);
								e % 2 === 0 ? (o(s[a][t + 1]), o(s[a + 1][t]), o(s[a][t])) : (o(s[a][t + 1]), o(s[a + 1][t + 1]), o(s[a + 1][t]))
							}
					}

					function o(e) {
						i.push(e.x, e.y, e.z)
					}

					function l(t, n) {
						const r = 3 * t;
						n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
					}

					function c(e, t, n, r) {
						r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === n.x && 0 === n.z && (s[t] = r / 2 / Math.PI + .5)
					}

					function u(e) {
						return Math.atan2(e.z, -e.x)
					}! function(e) {
						const n = new ir,
							r = new ir,
							i = new ir;
						for (let s = 0; s < t.length; s += 3) l(t[s + 0], n), l(t[s + 1], r), l(t[s + 2], i), a(n, r, i, e)
					}(r),
					function(e) {
						const t = new ir;
						for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
					}(n),
					function() {
						const e = new ir;
						for (let n = 0; n < i.length; n += 3) {
							e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2];
							const r = u(e) / 2 / Math.PI + .5,
								a = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
							s.push(r, 1 - a)
						}
						var t;
						(function() {
							const e = new ir,
								t = new ir,
								n = new ir,
								r = new ir,
								a = new zn,
								o = new zn,
								l = new zn;
							for (let h = 0, d = 0; h < i.length; h += 9, d += 6) {
								e.set(i[h + 0], i[h + 1], i[h + 2]), t.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), r.copy(e).add(t).add(n).divideScalar(3);
								const p = u(r);
								c(a, d + 0, e, p), c(o, d + 2, t, p), c(l, d + 4, n, p)
							}
						})(),
						function() {
							for (let e = 0; e < s.length; e += 6) {
								const t = s[e + 0],
									n = s[e + 2],
									r = s[e + 4],
									i = Math.max(t, n, r),
									a = Math.min(t, n, r);
								i > .9 && a < .1 && (t < .2 && (s[e + 0] += 1), n < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1))
							}
						}()
					}(), this.setAttribute("position", new ki(i, 3)), this.setAttribute("normal", new ki(i.slice(), 3)), this.setAttribute("uv", new ki(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
				}
				static fromJSON(e) {
					return new Gc(e.vertices, e.indices, e.radius, e.details)
				}
			}
			class Uc extends Gc {
				constructor(e = 1, t = 0) {
					const n = (1 + Math.sqrt(5)) / 2,
						r = 1 / n;
					super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
						radius: e,
						detail: t
					}
				}
				static fromJSON(e) {
					return new Uc(e.radius, e.detail)
				}
			}
			const zc = new ir,
				Vc = new ir,
				Wc = new ir,
				jc = new vi;
			class Jc extends qi {
				constructor(e = null, t = 1) {
					if (super(), this.type = "EdgesGeometry", this.parameters = {
							geometry: e,
							thresholdAngle: t
						}, null !== e) {
						const n = 4,
							r = Math.pow(10, n),
							i = Math.cos(In * t),
							s = e.getIndex(),
							a = e.getAttribute("position"),
							o = s ? s.count : a.count,
							l = [0, 0, 0],
							c = ["a", "b", "c"],
							u = new Array(3),
							h = {},
							d = [];
						for (let e = 0; e < o; e += 3) {
							s ? (l[0] = s.getX(e), l[1] = s.getX(e + 1), l[2] = s.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
							const {
								a: t,
								b: n,
								c: o
							} = jc;
							if (t.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), jc.getNormal(Wc), u[0] = `${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`, u[1] = `${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`, u[2] = `${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
								for (let e = 0; e < 3; e++) {
									const t = (e + 1) % 3,
										n = u[e],
										r = u[t],
										s = jc[c[e]],
										a = jc[c[t]],
										o = `${n}_${r}`,
										p = `${r}_${n}`;
									p in h && h[p] ? (Wc.dot(h[p].normal) <= i && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), h[p] = null) : o in h || (h[o] = {
										index0: l[e],
										index1: l[t],
										normal: Wc.clone()
									})
								}
						}
						for (const e in h)
							if (h[e]) {
								const {
									index0: t,
									index1: n
								} = h[e];
								zc.fromBufferAttribute(a, t), Vc.fromBufferAttribute(a, n), d.push(zc.x, zc.y, zc.z), d.push(Vc.x, Vc.y, Vc.z)
							} this.setAttribute("position", new ki(d, 3))
					}
				}
			}
			class Xc {
				constructor() {
					this.type = "Curve", this.arcLengthDivisions = 200
				}
				getPoint() {
					return console.warn("THREE.Curve: .getPoint() not implemented."), null
				}
				getPointAt(e, t) {
					const n = this.getUtoTmapping(e);
					return this.getPoint(n, t)
				}
				getPoints(e = 5) {
					const t = [];
					for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
					return t
				}
				getSpacedPoints(e = 5) {
					const t = [];
					for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
					return t
				}
				getLength() {
					const e = this.getLengths();
					return e[e.length - 1]
				}
				getLengths(e = this.arcLengthDivisions) {
					if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
					this.needsUpdate = !1;
					const t = [];
					let n, r = this.getPoint(0),
						i = 0;
					t.push(0);
					for (let s = 1; s <= e; s++) n = this.getPoint(s / e), i += n.distanceTo(r), t.push(i), r = n;
					return this.cacheArcLengths = t, t
				}
				updateArcLengths() {
					this.needsUpdate = !0, this.getLengths()
				}
				getUtoTmapping(e, t) {
					const n = this.getLengths();
					let r = 0;
					const i = n.length;
					let s;
					s = t || e * n[i - 1];
					let a, o = 0,
						l = i - 1;
					for (; o <= l;)
						if (r = Math.floor(o + (l - o) / 2), a = n[r] - s, a < 0) o = r + 1;
						else {
							if (!(a > 0)) {
								l = r;
								break
							}
							l = r - 1
						} if (r = l, n[r] === s) return r / (i - 1);
					const c = n[r];
					return (r + (s - c) / (n[r + 1] - c)) / (i - 1)
				}
				getTangent(e, t) {
					const n = 1e-4;
					let r = e - n,
						i = e + n;
					r < 0 && (r = 0), i > 1 && (i = 1);
					const s = this.getPoint(r),
						a = this.getPoint(i),
						o = t || (s.isVector2 ? new zn : new ir);
					return o.copy(a).sub(s).normalize(), o
				}
				getTangentAt(e, t) {
					const n = this.getUtoTmapping(e);
					return this.getTangent(n, t)
				}
				computeFrenetFrames(e, t) {
					const n = new ir,
						r = [],
						i = [],
						s = [],
						a = new ir,
						o = new Fr;
					for (let d = 0; d <= e; d++) {
						const t = d / e;
						r[d] = this.getTangentAt(t, new ir)
					}
					i[0] = new ir, s[0] = new ir;
					let l = Number.MAX_VALUE;
					const c = Math.abs(r[0].x),
						u = Math.abs(r[0].y),
						h = Math.abs(r[0].z);
					c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), s[0].crossVectors(r[0], i[0]);
					for (let d = 1; d <= e; d++) {
						if (i[d] = i[d - 1].clone(), s[d] = s[d - 1].clone(), a.crossVectors(r[d - 1], r[d]), a.length() > Number.EPSILON) {
							a.normalize();
							const e = Math.acos(Fn(r[d - 1].dot(r[d]), -1, 1));
							i[d].applyMatrix4(o.makeRotationAxis(a, e))
						}
						s[d].crossVectors(r[d], i[d])
					}
					if (!0 === t) {
						let t = Math.acos(Fn(i[0].dot(i[e]), -1, 1));
						t /= e, r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
						for (let n = 1; n <= e; n++) i[n].applyMatrix4(o.makeRotationAxis(r[n], t * n)), s[n].crossVectors(r[n], i[n])
					}
					return {
						tangents: r,
						normals: i,
						binormals: s
					}
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.arcLengthDivisions = e.arcLengthDivisions, this
				}
				toJSON() {
					const e = {
						metadata: {
							version: 4.5,
							type: "Curve",
							generator: "Curve.toJSON"
						}
					};
					return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
				}
				fromJSON(e) {
					return this.arcLengthDivisions = e.arcLengthDivisions, this
				}
			}
			class qc extends Xc {
				constructor(e = 0, t = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, a = !1, o = 0) {
					super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
				}
				getPoint(e, t) {
					const n = t || new zn,
						r = 2 * Math.PI;
					let i = this.aEndAngle - this.aStartAngle;
					const s = Math.abs(i) < Number.EPSILON;
					for (; i < 0;) i += r;
					for (; i > r;) i -= r;
					i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r);
					const a = this.aStartAngle + e * i;
					let o = this.aX + this.xRadius * Math.cos(a),
						l = this.aY + this.yRadius * Math.sin(a);
					if (0 !== this.aRotation) {
						const e = Math.cos(this.aRotation),
							t = Math.sin(this.aRotation),
							n = o - this.aX,
							r = l - this.aY;
						o = n * e - r * t + this.aX, l = n * t + r * e + this.aY
					}
					return n.set(o, l)
				}
				copy(e) {
					return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
				}
				toJSON() {
					const e = super.toJSON();
					return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
				}
			}
			qc.prototype.isEllipseCurve = !0;
			class Kc extends qc {
				constructor(e, t, n, r, i, s) {
					super(e, t, n, n, r, i, s), this.type = "ArcCurve"
				}
			}

			function Yc() {
				let e = 0,
					t = 0,
					n = 0,
					r = 0;

				function i(i, s, a, o) {
					e = i, t = a, n = -3 * i + 3 * s - 2 * a - o, r = 2 * i - 2 * s + a + o
				}
				return {
					initCatmullRom: function(e, t, n, r, s) {
						i(t, n, s * (n - e), s * (r - t))
					},
					initNonuniformCatmullRom: function(e, t, n, r, s, a, o) {
						let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
							c = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
						l *= a, c *= a, i(t, n, l, c)
					},
					calc: function(i) {
						const s = i * i;
						return e + t * i + n * s + r * (s * i)
					}
				}
			}
			Kc.prototype.isArcCurve = !0;
			const Qc = new ir,
				Zc = new Yc,
				$c = new Yc,
				eu = new Yc;
			class tu extends Xc {
				constructor(e = [], t = !1, n = "centripetal", r = .5) {
					super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
				}
				getPoint(e, t = new ir) {
					const n = t,
						r = this.points,
						i = r.length,
						s = (i - (this.closed ? 0 : 1)) * e;
					let a, o, l = Math.floor(s),
						c = s - l;
					this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? a = r[(l - 1) % i] : (Qc.subVectors(r[0], r[1]).add(r[0]), a = Qc);
					const u = r[l % i],
						h = r[(l + 1) % i];
					if (this.closed || l + 2 < i ? o = r[(l + 2) % i] : (Qc.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), o = Qc), "centripetal" === this.curveType || "chordal" === this.curveType) {
						const e = "chordal" === this.curveType ? .5 : .25;
						let t = Math.pow(a.distanceToSquared(u), e),
							n = Math.pow(u.distanceToSquared(h), e),
							r = Math.pow(h.distanceToSquared(o), e);
						n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), Zc.initNonuniformCatmullRom(a.x, u.x, h.x, o.x, t, n, r), $c.initNonuniformCatmullRom(a.y, u.y, h.y, o.y, t, n, r), eu.initNonuniformCatmullRom(a.z, u.z, h.z, o.z, t, n, r)
					} else "catmullrom" === this.curveType && (Zc.initCatmullRom(a.x, u.x, h.x, o.x, this.tension), $c.initCatmullRom(a.y, u.y, h.y, o.y, this.tension), eu.initCatmullRom(a.z, u.z, h.z, o.z, this.tension));
					return n.set(Zc.calc(c), $c.calc(c), eu.calc(c)), n
				}
				copy(e) {
					super.copy(e), this.points = [];
					for (let t = 0, n = e.points.length; t < n; t++) {
						const n = e.points[t];
						this.points.push(n.clone())
					}
					return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
				}
				toJSON() {
					const e = super.toJSON();
					e.points = [];
					for (let t = 0, n = this.points.length; t < n; t++) {
						const n = this.points[t];
						e.points.push(n.toArray())
					}
					return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
				}
				fromJSON(e) {
					super.fromJSON(e), this.points = [];
					for (let t = 0, n = e.points.length; t < n; t++) {
						const n = e.points[t];
						this.points.push((new ir).fromArray(n))
					}
					return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
				}
			}

			function nu(e, t, n, r, i) {
				const s = .5 * (r - t),
					a = .5 * (i - n),
					o = e * e;
				return (2 * n - 2 * r + s + a) * (e * o) + (-3 * n + 3 * r - 2 * s - a) * o + s * e + n
			}

			function ru(e, t, n, r) {
				return function(e, t) {
					const n = 1 - e;
					return n * n * t
				}(e, t) + function(e, t) {
					return 2 * (1 - e) * e * t
				}(e, n) + function(e, t) {
					return e * e * t
				}(e, r)
			}

			function iu(e, t, n, r, i) {
				return function(e, t) {
					const n = 1 - e;
					return n * n * n * t
				}(e, t) + function(e, t) {
					const n = 1 - e;
					return 3 * n * n * e * t
				}(e, n) + function(e, t) {
					return 3 * (1 - e) * e * e * t
				}(e, r) + function(e, t) {
					return e * e * e * t
				}(e, i)
			}
			tu.prototype.isCatmullRomCurve3 = !0;
			class su extends Xc {
				constructor(e = new zn, t = new zn, n = new zn, r = new zn) {
					super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
				}
				getPoint(e, t = new zn) {
					const n = t,
						r = this.v0,
						i = this.v1,
						s = this.v2,
						a = this.v3;
					return n.set(iu(e, r.x, i.x, s.x, a.x), iu(e, r.y, i.y, s.y, a.y)), n
				}
				copy(e) {
					return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
				}
			}
			su.prototype.isCubicBezierCurve = !0;
			class au extends Xc {
				constructor(e = new ir, t = new ir, n = new ir, r = new ir) {
					super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
				}
				getPoint(e, t = new ir) {
					const n = t,
						r = this.v0,
						i = this.v1,
						s = this.v2,
						a = this.v3;
					return n.set(iu(e, r.x, i.x, s.x, a.x), iu(e, r.y, i.y, s.y, a.y), iu(e, r.z, i.z, s.z, a.z)), n
				}
				copy(e) {
					return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
				}
			}
			au.prototype.isCubicBezierCurve3 = !0;
			class ou extends Xc {
				constructor(e = new zn, t = new zn) {
					super(), this.type = "LineCurve", this.v1 = e, this.v2 = t
				}
				getPoint(e, t = new zn) {
					const n = t;
					return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
				}
				getPointAt(e, t) {
					return this.getPoint(e, t)
				}
				getTangent(e, t) {
					const n = t || new zn;
					return n.copy(this.v2).sub(this.v1).normalize(), n
				}
				copy(e) {
					return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
				}
			}
			ou.prototype.isLineCurve = !0;
			class lu extends Xc {
				constructor(e = new ir, t = new ir) {
					super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t
				}
				getPoint(e, t = new ir) {
					const n = t;
					return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
				}
				getPointAt(e, t) {
					return this.getPoint(e, t)
				}
				copy(e) {
					return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
				}
			}
			class cu extends Xc {
				constructor(e = new zn, t = new zn, n = new zn) {
					super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
				}
				getPoint(e, t = new zn) {
					const n = t,
						r = this.v0,
						i = this.v1,
						s = this.v2;
					return n.set(ru(e, r.x, i.x, s.x), ru(e, r.y, i.y, s.y)), n
				}
				copy(e) {
					return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
				}
			}
			cu.prototype.isQuadraticBezierCurve = !0;
			class uu extends Xc {
				constructor(e = new ir, t = new ir, n = new ir) {
					super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
				}
				getPoint(e, t = new ir) {
					const n = t,
						r = this.v0,
						i = this.v1,
						s = this.v2;
					return n.set(ru(e, r.x, i.x, s.x), ru(e, r.y, i.y, s.y), ru(e, r.z, i.z, s.z)), n
				}
				copy(e) {
					return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
				}
			}
			uu.prototype.isQuadraticBezierCurve3 = !0;
			class hu extends Xc {
				constructor(e = []) {
					super(), this.type = "SplineCurve", this.points = e
				}
				getPoint(e, t = new zn) {
					const n = t,
						r = this.points,
						i = (r.length - 1) * e,
						s = Math.floor(i),
						a = i - s,
						o = r[0 === s ? s : s - 1],
						l = r[s],
						c = r[s > r.length - 2 ? r.length - 1 : s + 1],
						u = r[s > r.length - 3 ? r.length - 1 : s + 2];
					return n.set(nu(a, o.x, l.x, c.x, u.x), nu(a, o.y, l.y, c.y, u.y)), n
				}
				copy(e) {
					super.copy(e), this.points = [];
					for (let t = 0, n = e.points.length; t < n; t++) {
						const n = e.points[t];
						this.points.push(n.clone())
					}
					return this
				}
				toJSON() {
					const e = super.toJSON();
					e.points = [];
					for (let t = 0, n = this.points.length; t < n; t++) {
						const n = this.points[t];
						e.points.push(n.toArray())
					}
					return e
				}
				fromJSON(e) {
					super.fromJSON(e), this.points = [];
					for (let t = 0, n = e.points.length; t < n; t++) {
						const n = e.points[t];
						this.points.push((new zn).fromArray(n))
					}
					return this
				}
			}
			hu.prototype.isSplineCurve = !0;
			var du = Object.freeze({
				__proto__: null,
				ArcCurve: Kc,
				CatmullRomCurve3: tu,
				CubicBezierCurve: su,
				CubicBezierCurve3: au,
				EllipseCurve: qc,
				LineCurve: ou,
				LineCurve3: lu,
				QuadraticBezierCurve: cu,
				QuadraticBezierCurve3: uu,
				SplineCurve: hu
			});
			class pu extends Xc {
				constructor() {
					super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
				}
				add(e) {
					this.curves.push(e)
				}
				closePath() {
					const e = this.curves[0].getPoint(0),
						t = this.curves[this.curves.length - 1].getPoint(1);
					e.equals(t) || this.curves.push(new ou(t, e))
				}
				getPoint(e, t) {
					const n = e * this.getLength(),
						r = this.getCurveLengths();
					let i = 0;
					for (; i < r.length;) {
						if (r[i] >= n) {
							const e = r[i] - n,
								s = this.curves[i],
								a = s.getLength(),
								o = 0 === a ? 0 : 1 - e / a;
							return s.getPointAt(o, t)
						}
						i++
					}
					return null
				}
				getLength() {
					const e = this.getCurveLengths();
					return e[e.length - 1]
				}
				updateArcLengths() {
					this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
				}
				getCurveLengths() {
					if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
					const e = [];
					let t = 0;
					for (let n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
					return this.cacheLengths = e, e
				}
				getSpacedPoints(e = 40) {
					const t = [];
					for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
					return this.autoClose && t.push(t[0]), t
				}
				getPoints(e = 12) {
					const t = [];
					let n;
					for (let r = 0, i = this.curves; r < i.length; r++) {
						const s = i[r],
							a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e,
							o = s.getPoints(a);
						for (let e = 0; e < o.length; e++) {
							const r = o[e];
							n && n.equals(r) || (t.push(r), n = r)
						}
					}
					return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
				}
				copy(e) {
					super.copy(e), this.curves = [];
					for (let t = 0, n = e.curves.length; t < n; t++) {
						const n = e.curves[t];
						this.curves.push(n.clone())
					}
					return this.autoClose = e.autoClose, this
				}
				toJSON() {
					const e = super.toJSON();
					e.autoClose = this.autoClose, e.curves = [];
					for (let t = 0, n = this.curves.length; t < n; t++) {
						const n = this.curves[t];
						e.curves.push(n.toJSON())
					}
					return e
				}
				fromJSON(e) {
					super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
					for (let t = 0, n = e.curves.length; t < n; t++) {
						const n = e.curves[t];
						this.curves.push((new du[n.type]).fromJSON(n))
					}
					return this
				}
			}
			class fu extends pu {
				constructor(e) {
					super(), this.type = "Path", this.currentPoint = new zn, e && this.setFromPoints(e)
				}
				setFromPoints(e) {
					this.moveTo(e[0].x, e[0].y);
					for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
					return this
				}
				moveTo(e, t) {
					return this.currentPoint.set(e, t), this
				}
				lineTo(e, t) {
					const n = new ou(this.currentPoint.clone(), new zn(e, t));
					return this.curves.push(n), this.currentPoint.set(e, t), this
				}
				quadraticCurveTo(e, t, n, r) {
					const i = new cu(this.currentPoint.clone(), new zn(e, t), new zn(n, r));
					return this.curves.push(i), this.currentPoint.set(n, r), this
				}
				bezierCurveTo(e, t, n, r, i, s) {
					const a = new su(this.currentPoint.clone(), new zn(e, t), new zn(n, r), new zn(i, s));
					return this.curves.push(a), this.currentPoint.set(i, s), this
				}
				splineThru(e) {
					const t = [this.currentPoint.clone()].concat(e),
						n = new hu(t);
					return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
				}
				arc(e, t, n, r, i, s) {
					const a = this.currentPoint.x,
						o = this.currentPoint.y;
					return this.absarc(e + a, t + o, n, r, i, s), this
				}
				absarc(e, t, n, r, i, s) {
					return this.absellipse(e, t, n, n, r, i, s), this
				}
				ellipse(e, t, n, r, i, s, a, o) {
					const l = this.currentPoint.x,
						c = this.currentPoint.y;
					return this.absellipse(e + l, t + c, n, r, i, s, a, o), this
				}
				absellipse(e, t, n, r, i, s, a, o) {
					const l = new qc(e, t, n, r, i, s, a, o);
					if (this.curves.length > 0) {
						const e = l.getPoint(0);
						e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
					}
					this.curves.push(l);
					const c = l.getPoint(1);
					return this.currentPoint.copy(c), this
				}
				copy(e) {
					return super.copy(e), this.currentPoint.copy(e.currentPoint), this
				}
				toJSON() {
					const e = super.toJSON();
					return e.currentPoint = this.currentPoint.toArray(), e
				}
				fromJSON(e) {
					return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
				}
			}
			class mu extends fu {
				constructor(e) {
					super(e), this.uuid = Dn(), this.type = "Shape", this.holes = []
				}
				getPointsHoles(e) {
					const t = [];
					for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
					return t
				}
				extractPoints(e) {
					return {
						shape: this.getPoints(e),
						holes: this.getPointsHoles(e)
					}
				}
				copy(e) {
					super.copy(e), this.holes = [];
					for (let t = 0, n = e.holes.length; t < n; t++) {
						const n = e.holes[t];
						this.holes.push(n.clone())
					}
					return this
				}
				toJSON() {
					const e = super.toJSON();
					e.uuid = this.uuid, e.holes = [];
					for (let t = 0, n = this.holes.length; t < n; t++) {
						const n = this.holes[t];
						e.holes.push(n.toJSON())
					}
					return e
				}
				fromJSON(e) {
					super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
					for (let t = 0, n = e.holes.length; t < n; t++) {
						const n = e.holes[t];
						this.holes.push((new fu).fromJSON(n))
					}
					return this
				}
			}
			const gu = function(e, t, n = 2) {
				const r = t && t.length,
					i = r ? t[0] * n : e.length;
				let s = vu(e, 0, i, n, !0);
				const a = [];
				if (!s || s.next === s.prev) return a;
				let o, l, c, u, h, d, p;
				if (r && (s = function(e, t, n, r) {
						const i = [];
						let s, a, o, l, c;
						for (s = 0, a = t.length; s < a; s++) o = t[s] * r, l = s < a - 1 ? t[s + 1] * r : e.length, c = vu(e, o, l, r, !1), c === c.next && (c.steiner = !0), i.push(Cu(c));
						for (i.sort(Au), s = 0; s < i.length; s++) Su(i[s], n), n = yu(n, n.next);
						return n
					}(e, t, s, n)), e.length > 80 * n) {
					o = c = e[0], l = u = e[1];
					for (let t = n; t < i; t += n) h = e[t], d = e[t + 1], h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
					p = Math.max(c - o, u - l), p = 0 !== p ? 1 / p : 0
				}
				return xu(s, a, n, o, l, p), a
			};

			function vu(e, t, n, r, i) {
				let s, a;
				if (i === function(e, t, n, r) {
						let i = 0;
						for (let s = t, a = n - r; s < n; s += r) i += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s;
						return i
					}(e, t, n, r) > 0)
					for (s = t; s < n; s += r) a = Hu(s, e[s], e[s + 1], a);
				else
					for (s = n - r; s >= t; s -= r) a = Hu(s, e[s], e[s + 1], a);
				return a && Iu(a, a.next) && (ku(a), a = a.next), a
			}

			function yu(e, t) {
				if (!e) return e;
				t || (t = e);
				let n, r = e;
				do {
					if (n = !1, r.steiner || !Iu(r, r.next) && 0 !== Lu(r.prev, r, r.next)) r = r.next;
					else {
						if (ku(r), r = t = r.prev, r === r.next) break;
						n = !0
					}
				} while (n || r !== t);
				return t
			}

			function xu(e, t, n, r, i, s, a) {
				if (!e) return;
				!a && s && function(e, t, n, r) {
					let i = e;
					do {
						null === i.z && (i.z = Tu(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
					} while (i !== e);
					i.prevZ.nextZ = null, i.prevZ = null,
						function(e) {
							let t, n, r, i, s, a, o, l, c = 1;
							do {
								for (n = e, e = null, s = null, a = 0; n;) {
									for (a++, r = n, o = 0, t = 0; t < c && (o++, r = r.nextZ, r); t++);
									for (l = c; o > 0 || l > 0 && r;) 0 !== o && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, o--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;
									n = r
								}
								s.nextZ = null, c *= 2
							} while (a > 1)
						}(i)
				}(e, r, i, s);
				let o, l, c = e;
				for (; e.prev !== e.next;)
					if (o = e.prev, l = e.next, s ? bu(e, r, i, s) : _u(e)) t.push(o.i / n), t.push(e.i / n), t.push(l.i / n), ku(e), e = l.next, c = l.next;
					else if ((e = l) === c) {
					a ? 1 === a ? xu(e = wu(yu(e), t, n), t, n, r, i, s, 2) : 2 === a && Mu(e, t, n, r, i, s) : xu(yu(e), t, n, r, i, s, 1);
					break
				}
			}

			function _u(e) {
				const t = e.prev,
					n = e,
					r = e.next;
				if (Lu(t, n, r) >= 0) return !1;
				let i = e.next.next;
				for (; i !== e.prev;) {
					if (Bu(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && Lu(i.prev, i, i.next) >= 0) return !1;
					i = i.next
				}
				return !0
			}

			function bu(e, t, n, r) {
				const i = e.prev,
					s = e,
					a = e.next;
				if (Lu(i, s, a) >= 0) return !1;
				const o = i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x,
					l = i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y,
					c = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x,
					u = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y,
					h = Tu(o, l, t, n, r),
					d = Tu(c, u, t, n, r);
				let p = e.prevZ,
					f = e.nextZ;
				for (; p && p.z >= h && f && f.z <= d;) {
					if (p !== e.prev && p !== e.next && Bu(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Lu(p.prev, p, p.next) >= 0) return !1;
					if (p = p.prevZ, f !== e.prev && f !== e.next && Bu(i.x, i.y, s.x, s.y, a.x, a.y, f.x, f.y) && Lu(f.prev, f, f.next) >= 0) return !1;
					f = f.nextZ
				}
				for (; p && p.z >= h;) {
					if (p !== e.prev && p !== e.next && Bu(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Lu(p.prev, p, p.next) >= 0) return !1;
					p = p.prevZ
				}
				for (; f && f.z <= d;) {
					if (f !== e.prev && f !== e.next && Bu(i.x, i.y, s.x, s.y, a.x, a.y, f.x, f.y) && Lu(f.prev, f, f.next) >= 0) return !1;
					f = f.nextZ
				}
				return !0
			}

			function wu(e, t, n) {
				let r = e;
				do {
					const i = r.prev,
						s = r.next.next;
					!Iu(i, s) && Pu(i, r, r.next, s) && Ou(i, s) && Ou(s, i) && (t.push(i.i / n), t.push(r.i / n), t.push(s.i / n), ku(r), ku(r.next), r = e = s), r = r.next
				} while (r !== e);
				return yu(r)
			}

			function Mu(e, t, n, r, i, s) {
				let a = e;
				do {
					let e = a.next.next;
					for (; e !== a.prev;) {
						if (a.i !== e.i && Ru(a, e)) {
							let o = Nu(a, e);
							return a = yu(a, a.next), o = yu(o, o.next), xu(a, t, n, r, i, s), void xu(o, t, n, r, i, s)
						}
						e = e.next
					}
					a = a.next
				} while (a !== e)
			}

			function Au(e, t) {
				return e.x - t.x
			}

			function Su(e, t) {
				if (t = function(e, t) {
						let n = t;
						const r = e.x,
							i = e.y;
						let s, a = -1 / 0;
						do {
							if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
								const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
								if (e <= r && e > a) {
									if (a = e, e === r) {
										if (i === n.y) return n;
										if (i === n.next.y) return n.next
									}
									s = n.x < n.next.x ? n : n.next
								}
							}
							n = n.next
						} while (n !== t);
						if (!s) return null;
						if (r === a) return s;
						const o = s,
							l = s.x,
							c = s.y;
						let u, h = 1 / 0;
						n = s;
						do {
							r >= n.x && n.x >= l && r !== n.x && Bu(i < c ? r : a, i, l, c, i < c ? a : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), Ou(n, e) && (u < h || u === h && (n.x > s.x || n.x === s.x && Eu(s, n))) && (s = n, h = u)), n = n.next
						} while (n !== o);
						return s
					}(e, t)) {
					const n = Nu(t, e);
					yu(t, t.next), yu(n, n.next)
				}
			}

			function Eu(e, t) {
				return Lu(e.prev, e, t.prev) < 0 && Lu(t.next, e, e.next) < 0
			}

			function Tu(e, t, n, r, i) {
				return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
			}

			function Cu(e) {
				let t = e,
					n = e;
				do {
					(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
				} while (t !== e);
				return n
			}

			function Bu(e, t, n, r, i, s, a, o) {
				return (i - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (r - o) - (n - a) * (t - o) >= 0 && (n - a) * (s - o) - (i - a) * (r - o) >= 0
			}

			function Ru(e, t) {
				return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
					let n = e;
					do {
						if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Pu(n, n.next, e, t)) return !0;
						n = n.next
					} while (n !== e);
					return !1
				}(e, t) && (Ou(e, t) && Ou(t, e) && function(e, t) {
					let n = e,
						r = !1;
					const i = (e.x + t.x) / 2,
						s = (e.y + t.y) / 2;
					do {
						n.y > s !== n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
					} while (n !== e);
					return r
				}(e, t) && (Lu(e.prev, e, t.prev) || Lu(e, t.prev, t)) || Iu(e, t) && Lu(e.prev, e, e.next) > 0 && Lu(t.prev, t, t.next) > 0)
			}

			function Lu(e, t, n) {
				return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
			}

			function Iu(e, t) {
				return e.x === t.x && e.y === t.y
			}

			function Pu(e, t, n, r) {
				const i = Fu(Lu(e, t, n)),
					s = Fu(Lu(e, t, r)),
					a = Fu(Lu(n, r, e)),
					o = Fu(Lu(n, r, t));
				return i !== s && a !== o || (!(0 !== i || !Du(e, n, t)) || (!(0 !== s || !Du(e, r, t)) || (!(0 !== a || !Du(n, e, r)) || !(0 !== o || !Du(n, t, r)))))
			}

			function Du(e, t, n) {
				return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
			}

			function Fu(e) {
				return e > 0 ? 1 : e < 0 ? -1 : 0
			}

			function Ou(e, t) {
				return Lu(e.prev, e, e.next) < 0 ? Lu(e, t, e.next) >= 0 && Lu(e, e.prev, t) >= 0 : Lu(e, t, e.prev) < 0 || Lu(e, e.next, t) < 0
			}

			function Nu(e, t) {
				const n = new Gu(e.i, e.x, e.y),
					r = new Gu(t.i, t.x, t.y),
					i = e.next,
					s = t.prev;
				return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
			}

			function Hu(e, t, n, r) {
				const i = new Gu(e, t, n);
				return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
			}

			function ku(e) {
				e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
			}

			function Gu(e, t, n) {
				this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
			}
			class Uu {
				static area(e) {
					const t = e.length;
					let n = 0;
					for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
					return .5 * n
				}
				static isClockWise(e) {
					return Uu.area(e) < 0
				}
				static triangulateShape(e, t) {
					const n = [],
						r = [],
						i = [];
					zu(e), Vu(n, e);
					let s = e.length;
					t.forEach(zu);
					for (let o = 0; o < t.length; o++) r.push(s), s += t[o].length, Vu(n, t[o]);
					const a = gu(n, r);
					for (let o = 0; o < a.length; o += 3) i.push(a.slice(o, o + 3));
					return i
				}
			}

			function zu(e) {
				const t = e.length;
				t > 2 && e[t - 1].equals(e[0]) && e.pop()
			}

			function Vu(e, t) {
				for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
			}
			class Wu extends qi {
				constructor(e = new mu([new zn(.5, .5), new zn(-.5, .5), new zn(-.5, -.5), new zn(.5, -.5)]), t = {}) {
					super(), this.type = "ExtrudeGeometry", this.parameters = {
						shapes: e,
						options: t
					}, e = Array.isArray(e) ? e : [e];
					const n = this,
						r = [],
						i = [];
					for (let a = 0, o = e.length; a < o; a++) {
						s(e[a])
					}

					function s(e) {
						const s = [],
							a = void 0 !== t.curveSegments ? t.curveSegments : 12,
							o = void 0 !== t.steps ? t.steps : 1;
						let l = void 0 !== t.depth ? t.depth : 1,
							c = void 0 === t.bevelEnabled || t.bevelEnabled,
							u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
							h = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
							d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
							p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
						const f = t.extrudePath,
							m = void 0 !== t.UVGenerator ? t.UVGenerator : ju;
						void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount);
						let g, v, y, x, _, b = !1;
						f && (g = f.getSpacedPoints(o), b = !0, c = !1, v = f.computeFrenetFrames(o, !1), y = new ir, x = new ir, _ = new ir), c || (p = 0, u = 0, h = 0, d = 0);
						const w = e.extractPoints(a);
						let M = w.shape;
						const A = w.holes;
						if (!Uu.isClockWise(M)) {
							M = M.reverse();
							for (let e = 0, t = A.length; e < t; e++) {
								const t = A[e];
								Uu.isClockWise(t) && (A[e] = t.reverse())
							}
						}
						const S = Uu.triangulateShape(M, A),
							E = M;
						for (let t = 0, n = A.length; t < n; t++) {
							const e = A[t];
							M = M.concat(e)
						}

						function T(e, t, n) {
							return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
						}
						const C = M.length,
							B = S.length;

						function R(e, t, n) {
							let r, i, s;
							const a = e.x - t.x,
								o = e.y - t.y,
								l = n.x - e.x,
								c = n.y - e.y,
								u = a * a + o * o,
								h = a * c - o * l;
							if (Math.abs(h) > Number.EPSILON) {
								const h = Math.sqrt(u),
									d = Math.sqrt(l * l + c * c),
									p = t.x - o / h,
									f = t.y + a / h,
									m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (a * c - o * l);
								r = p + a * m - e.x, i = f + o * m - e.y;
								const g = r * r + i * i;
								if (g <= 2) return new zn(r, i);
								s = Math.sqrt(g / 2)
							} else {
								let e = !1;
								a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0), e ? (r = -o, i = a, s = Math.sqrt(u)) : (r = a, i = o, s = Math.sqrt(u / 2))
							}
							return new zn(r / s, i / s)
						}
						const L = [];
						for (let t = 0, n = E.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), L[t] = R(E[t], E[r], E[i]);
						const I = [];
						let P, D = L.concat();
						for (let t = 0, n = A.length; t < n; t++) {
							const e = A[t];
							P = [];
							for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), P[t] = R(e[t], e[r], e[i]);
							I.push(P), D = D.concat(P)
						}
						for (let t = 0; t < p; t++) {
							const e = t / p,
								n = u * Math.cos(e * Math.PI / 2),
								r = h * Math.sin(e * Math.PI / 2) + d;
							for (let t = 0, i = E.length; t < i; t++) {
								const e = T(E[t], L[t], r);
								N(e.x, e.y, -n)
							}
							for (let t = 0, i = A.length; t < i; t++) {
								const e = A[t];
								P = I[t];
								for (let t = 0, i = e.length; t < i; t++) {
									const i = T(e[t], P[t], r);
									N(i.x, i.y, -n)
								}
							}
						}
						const F = h + d;
						for (let t = 0; t < C; t++) {
							const e = c ? T(M[t], D[t], F) : M[t];
							b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), N(_.x, _.y, _.z)) : N(e.x, e.y, 0)
						}
						for (let t = 1; t <= o; t++)
							for (let e = 0; e < C; e++) {
								const n = c ? T(M[e], D[e], F) : M[e];
								b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), N(_.x, _.y, _.z)) : N(n.x, n.y, l / o * t)
							}
						for (let t = p - 1; t >= 0; t--) {
							const e = t / p,
								n = u * Math.cos(e * Math.PI / 2),
								r = h * Math.sin(e * Math.PI / 2) + d;
							for (let t = 0, i = E.length; t < i; t++) {
								const e = T(E[t], L[t], r);
								N(e.x, e.y, l + n)
							}
							for (let t = 0, i = A.length; t < i; t++) {
								const e = A[t];
								P = I[t];
								for (let t = 0, i = e.length; t < i; t++) {
									const i = T(e[t], P[t], r);
									b ? N(i.x, i.y + g[o - 1].y, g[o - 1].x + n) : N(i.x, i.y, l + n)
								}
							}
						}

						function O(e, t) {
							let n = e.length;
							for (; --n >= 0;) {
								const r = n;
								let i = n - 1;
								i < 0 && (i = e.length - 1);
								for (let e = 0, n = o + 2 * p; e < n; e++) {
									const n = C * e,
										s = C * (e + 1);
									k(t + r + n, t + i + n, t + i + s, t + r + s)
								}
							}
						}

						function N(e, t, n) {
							s.push(e), s.push(t), s.push(n)
						}

						function H(e, t, i) {
							G(e), G(t), G(i);
							const s = r.length / 3,
								a = m.generateTopUV(n, r, s - 3, s - 2, s - 1);
							U(a[0]), U(a[1]), U(a[2])
						}

						function k(e, t, i, s) {
							G(e), G(t), G(s), G(t), G(i), G(s);
							const a = r.length / 3,
								o = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
							U(o[0]), U(o[1]), U(o[3]), U(o[1]), U(o[2]), U(o[3])
						}

						function G(e) {
							r.push(s[3 * e + 0]), r.push(s[3 * e + 1]), r.push(s[3 * e + 2])
						}

						function U(e) {
							i.push(e.x), i.push(e.y)
						}! function() {
							const e = r.length / 3;
							if (c) {
								let e = 0,
									t = C * e;
								for (let n = 0; n < B; n++) {
									const e = S[n];
									H(e[2] + t, e[1] + t, e[0] + t)
								}
								e = o + 2 * p, t = C * e;
								for (let n = 0; n < B; n++) {
									const e = S[n];
									H(e[0] + t, e[1] + t, e[2] + t)
								}
							} else {
								for (let e = 0; e < B; e++) {
									const t = S[e];
									H(t[2], t[1], t[0])
								}
								for (let e = 0; e < B; e++) {
									const t = S[e];
									H(t[0] + C * o, t[1] + C * o, t[2] + C * o)
								}
							}
							n.addGroup(e, r.length / 3 - e, 0)
						}(),
						function() {
							const e = r.length / 3;
							let t = 0;
							O(E, t), t += E.length;
							for (let n = 0, r = A.length; n < r; n++) {
								const e = A[n];
								O(e, t), t += e.length
							}
							n.addGroup(e, r.length / 3 - e, 1)
						}()
					}
					this.setAttribute("position", new ki(r, 3)), this.setAttribute("uv", new ki(i, 2)), this.computeVertexNormals()
				}
				toJSON() {
					const e = super.toJSON();
					return function(e, t, n) {
						if (n.shapes = [], Array.isArray(e))
							for (let r = 0, i = e.length; r < i; r++) {
								const t = e[r];
								n.shapes.push(t.uuid)
							} else n.shapes.push(e.uuid);
						void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
						return n
					}(this.parameters.shapes, this.parameters.options, e)
				}
				static fromJSON(e, t) {
					const n = [];
					for (let i = 0, s = e.shapes.length; i < s; i++) {
						const r = t[e.shapes[i]];
						n.push(r)
					}
					const r = e.options.extrudePath;
					return void 0 !== r && (e.options.extrudePath = (new du[r.type]).fromJSON(r)), new Wu(n, e.options)
				}
			}
			const ju = {
				generateTopUV: function(e, t, n, r, i) {
					const s = t[3 * n],
						a = t[3 * n + 1],
						o = t[3 * r],
						l = t[3 * r + 1],
						c = t[3 * i],
						u = t[3 * i + 1];
					return [new zn(s, a), new zn(o, l), new zn(c, u)]
				},
				generateSideWallUV: function(e, t, n, r, i, s) {
					const a = t[3 * n],
						o = t[3 * n + 1],
						l = t[3 * n + 2],
						c = t[3 * r],
						u = t[3 * r + 1],
						h = t[3 * r + 2],
						d = t[3 * i],
						p = t[3 * i + 1],
						f = t[3 * i + 2],
						m = t[3 * s],
						g = t[3 * s + 1],
						v = t[3 * s + 2];
					return Math.abs(o - u) < Math.abs(a - c) ? [new zn(a, 1 - l), new zn(c, 1 - h), new zn(d, 1 - f), new zn(m, 1 - v)] : [new zn(o, 1 - l), new zn(u, 1 - h), new zn(p, 1 - f), new zn(g, 1 - v)]
				}
			};
			class Ju extends Gc {
				constructor(e = 1, t = 0) {
					const n = (1 + Math.sqrt(5)) / 2;
					super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
						radius: e,
						detail: t
					}
				}
				static fromJSON(e) {
					return new Ju(e.radius, e.detail)
				}
			}
			class Xu extends qi {
				constructor(e = [new zn(0, .5), new zn(.5, 0), new zn(0, -.5)], t = 12, n = 0, r = 2 * Math.PI) {
					super(), this.type = "LatheGeometry", this.parameters = {
						points: e,
						segments: t,
						phiStart: n,
						phiLength: r
					}, t = Math.floor(t), r = Fn(r, 0, 2 * Math.PI);
					const i = [],
						s = [],
						a = [],
						o = [],
						l = [],
						c = 1 / t,
						u = new ir,
						h = new zn,
						d = new ir,
						p = new ir,
						f = new ir;
					let m = 0,
						g = 0;
					for (let v = 0; v <= e.length - 1; v++) switch (v) {
						case 0:
							m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, f.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
							break;
						case e.length - 1:
							o.push(f.x, f.y, f.z);
							break;
						default:
							m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, p.copy(d), d.x += f.x, d.y += f.y, d.z += f.z, d.normalize(), o.push(d.x, d.y, d.z), f.copy(p)
					}
					for (let v = 0; v <= t; v++) {
						const i = n + v * c * r,
							d = Math.sin(i),
							p = Math.cos(i);
						for (let n = 0; n <= e.length - 1; n++) {
							u.x = e[n].x * d, u.y = e[n].y, u.z = e[n].x * p, s.push(u.x, u.y, u.z), h.x = v / t, h.y = n / (e.length - 1), a.push(h.x, h.y);
							const r = o[3 * n + 0] * d,
								i = o[3 * n + 1],
								c = o[3 * n + 0] * p;
							l.push(r, i, c)
						}
					}
					for (let v = 0; v < t; v++)
						for (let t = 0; t < e.length - 1; t++) {
							const n = t + v * e.length,
								r = n,
								s = n + e.length,
								a = n + e.length + 1,
								o = n + 1;
							i.push(r, s, o), i.push(s, a, o)
						}
					this.setIndex(i), this.setAttribute("position", new ki(s, 3)), this.setAttribute("uv", new ki(a, 2)), this.setAttribute("normal", new ki(l, 3))
				}
				static fromJSON(e) {
					return new Xu(e.points, e.segments, e.phiStart, e.phiLength)
				}
			}
			class qu extends Gc {
				constructor(e = 1, t = 0) {
					super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
						radius: e,
						detail: t
					}
				}
				static fromJSON(e) {
					return new qu(e.radius, e.detail)
				}
			}
			class Ku extends qi {
				constructor(e = .5, t = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) {
					super(), this.type = "RingGeometry", this.parameters = {
						innerRadius: e,
						outerRadius: t,
						thetaSegments: n,
						phiSegments: r,
						thetaStart: i,
						thetaLength: s
					}, n = Math.max(3, n);
					const a = [],
						o = [],
						l = [],
						c = [];
					let u = e;
					const h = (t - e) / (r = Math.max(1, r)),
						d = new ir,
						p = new zn;
					for (let f = 0; f <= r; f++) {
						for (let e = 0; e <= n; e++) {
							const r = i + e / n * s;
							d.x = u * Math.cos(r), d.y = u * Math.sin(r), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y)
						}
						u += h
					}
					for (let f = 0; f < r; f++) {
						const e = f * (n + 1);
						for (let t = 0; t < n; t++) {
							const r = t + e,
								i = r,
								s = r + n + 1,
								o = r + n + 2,
								l = r + 1;
							a.push(i, s, l), a.push(s, o, l)
						}
					}
					this.setIndex(a), this.setAttribute("position", new ki(o, 3)), this.setAttribute("normal", new ki(l, 3)), this.setAttribute("uv", new ki(c, 2))
				}
				static fromJSON(e) {
					return new Ku(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
				}
			}
			class Yu extends qi {
				constructor(e = new mu([new zn(0, .5), new zn(-.5, -.5), new zn(.5, -.5)]), t = 12) {
					super(), this.type = "ShapeGeometry", this.parameters = {
						shapes: e,
						curveSegments: t
					};
					const n = [],
						r = [],
						i = [],
						s = [];
					let a = 0,
						o = 0;
					if (!1 === Array.isArray(e)) l(e);
					else
						for (let c = 0; c < e.length; c++) l(e[c]), this.addGroup(a, o, c), a += o, o = 0;

					function l(e) {
						const a = r.length / 3,
							l = e.extractPoints(t);
						let c = l.shape;
						const u = l.holes;
						!1 === Uu.isClockWise(c) && (c = c.reverse());
						for (let t = 0, n = u.length; t < n; t++) {
							const e = u[t];
							!0 === Uu.isClockWise(e) && (u[t] = e.reverse())
						}
						const h = Uu.triangulateShape(c, u);
						for (let t = 0, n = u.length; t < n; t++) {
							const e = u[t];
							c = c.concat(e)
						}
						for (let t = 0, n = c.length; t < n; t++) {
							const e = c[t];
							r.push(e.x, e.y, 0), i.push(0, 0, 1), s.push(e.x, e.y)
						}
						for (let t = 0, r = h.length; t < r; t++) {
							const e = h[t],
								r = e[0] + a,
								i = e[1] + a,
								s = e[2] + a;
							n.push(r, i, s), o += 3
						}
					}
					this.setIndex(n), this.setAttribute("position", new ki(r, 3)), this.setAttribute("normal", new ki(i, 3)), this.setAttribute("uv", new ki(s, 2))
				}
				toJSON() {
					const e = super.toJSON();
					return function(e, t) {
						if (t.shapes = [], Array.isArray(e))
							for (let n = 0, r = e.length; n < r; n++) {
								const r = e[n];
								t.shapes.push(r.uuid)
							} else t.shapes.push(e.uuid);
						return t
					}(this.parameters.shapes, e)
				}
				static fromJSON(e, t) {
					const n = [];
					for (let r = 0, i = e.shapes.length; r < i; r++) {
						const i = t[e.shapes[r]];
						n.push(i)
					}
					return new Yu(n, e.curveSegments)
				}
			}
			class Qu extends qi {
				constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, s = 0, a = Math.PI) {
					super(), this.type = "SphereGeometry", this.parameters = {
						radius: e,
						widthSegments: t,
						heightSegments: n,
						phiStart: r,
						phiLength: i,
						thetaStart: s,
						thetaLength: a
					}, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
					const o = Math.min(s + a, Math.PI);
					let l = 0;
					const c = [],
						u = new ir,
						h = new ir,
						d = [],
						p = [],
						f = [],
						m = [];
					for (let g = 0; g <= n; g++) {
						const d = [],
							v = g / n;
						let y = 0;
						0 == g && 0 == s ? y = .5 / t : g == n && o == Math.PI && (y = -.5 / t);
						for (let n = 0; n <= t; n++) {
							const o = n / t;
							u.x = -e * Math.cos(r + o * i) * Math.sin(s + v * a), u.y = e * Math.cos(s + v * a), u.z = e * Math.sin(r + o * i) * Math.sin(s + v * a), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(o + y, 1 - v), d.push(l++)
						}
						c.push(d)
					}
					for (let g = 0; g < n; g++)
						for (let e = 0; e < t; e++) {
							const t = c[g][e + 1],
								r = c[g][e],
								i = c[g + 1][e],
								a = c[g + 1][e + 1];
							(0 !== g || s > 0) && d.push(t, r, a), (g !== n - 1 || o < Math.PI) && d.push(r, i, a)
						}
					this.setIndex(d), this.setAttribute("position", new ki(p, 3)), this.setAttribute("normal", new ki(f, 3)), this.setAttribute("uv", new ki(m, 2))
				}
				static fromJSON(e) {
					return new Qu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
				}
			}
			class Zu extends Gc {
				constructor(e = 1, t = 0) {
					super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
						radius: e,
						detail: t
					}
				}
				static fromJSON(e) {
					return new Zu(e.radius, e.detail)
				}
			}
			class $u extends qi {
				constructor(e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI) {
					super(), this.type = "TorusGeometry", this.parameters = {
						radius: e,
						tube: t,
						radialSegments: n,
						tubularSegments: r,
						arc: i
					}, n = Math.floor(n), r = Math.floor(r);
					const s = [],
						a = [],
						o = [],
						l = [],
						c = new ir,
						u = new ir,
						h = new ir;
					for (let d = 0; d <= n; d++)
						for (let s = 0; s <= r; s++) {
							const p = s / r * i,
								f = d / n * Math.PI * 2;
							u.x = (e + t * Math.cos(f)) * Math.cos(p), u.y = (e + t * Math.cos(f)) * Math.sin(p), u.z = t * Math.sin(f), a.push(u.x, u.y, u.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), h.subVectors(u, c).normalize(), o.push(h.x, h.y, h.z), l.push(s / r), l.push(d / n)
						}
					for (let d = 1; d <= n; d++)
						for (let e = 1; e <= r; e++) {
							const t = (r + 1) * d + e - 1,
								n = (r + 1) * (d - 1) + e - 1,
								i = (r + 1) * (d - 1) + e,
								a = (r + 1) * d + e;
							s.push(t, n, a), s.push(n, i, a)
						}
					this.setIndex(s), this.setAttribute("position", new ki(a, 3)), this.setAttribute("normal", new ki(o, 3)), this.setAttribute("uv", new ki(l, 2))
				}
				static fromJSON(e) {
					return new $u(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
				}
			}
			class eh extends qi {
				constructor(e = 1, t = .4, n = 64, r = 8, i = 2, s = 3) {
					super(), this.type = "TorusKnotGeometry", this.parameters = {
						radius: e,
						tube: t,
						tubularSegments: n,
						radialSegments: r,
						p: i,
						q: s
					}, n = Math.floor(n), r = Math.floor(r);
					const a = [],
						o = [],
						l = [],
						c = [],
						u = new ir,
						h = new ir,
						d = new ir,
						p = new ir,
						f = new ir,
						m = new ir,
						g = new ir;
					for (let y = 0; y <= n; ++y) {
						const a = y / n * i * Math.PI * 2;
						v(a, i, s, e, d), v(a + .01, i, s, e, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
						for (let e = 0; e <= r; ++e) {
							const i = e / r * Math.PI * 2,
								s = -t * Math.cos(i),
								a = t * Math.sin(i);
							u.x = d.x + (s * g.x + a * f.x), u.y = d.y + (s * g.y + a * f.y), u.z = d.z + (s * g.z + a * f.z), o.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), l.push(h.x, h.y, h.z), c.push(y / n), c.push(e / r)
						}
					}
					for (let y = 1; y <= n; y++)
						for (let e = 1; e <= r; e++) {
							const t = (r + 1) * (y - 1) + (e - 1),
								n = (r + 1) * y + (e - 1),
								i = (r + 1) * y + e,
								s = (r + 1) * (y - 1) + e;
							a.push(t, n, s), a.push(n, i, s)
						}

					function v(e, t, n, r, i) {
						const s = Math.cos(e),
							a = Math.sin(e),
							o = n / t * e,
							l = Math.cos(o);
						i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(o) * .5
					}
					this.setIndex(a), this.setAttribute("position", new ki(o, 3)), this.setAttribute("normal", new ki(l, 3)), this.setAttribute("uv", new ki(c, 2))
				}
				static fromJSON(e) {
					return new eh(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
				}
			}
			class th extends qi {
				constructor(e = new uu(new ir(-1, -1, 0), new ir(-1, 1, 0), new ir(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) {
					super(), this.type = "TubeGeometry", this.parameters = {
						path: e,
						tubularSegments: t,
						radius: n,
						radialSegments: r,
						closed: i
					};
					const s = e.computeFrenetFrames(t, i);
					this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
					const a = new ir,
						o = new ir,
						l = new zn;
					let c = new ir;
					const u = [],
						h = [],
						d = [],
						p = [];

					function f(i) {
						c = e.getPointAt(i / t, c);
						const l = s.normals[i],
							d = s.binormals[i];
						for (let e = 0; e <= r; e++) {
							const t = e / r * Math.PI * 2,
								i = Math.sin(t),
								s = -Math.cos(t);
							o.x = s * l.x + i * d.x, o.y = s * l.y + i * d.y, o.z = s * l.z + i * d.z, o.normalize(), h.push(o.x, o.y, o.z), a.x = c.x + n * o.x, a.y = c.y + n * o.y, a.z = c.z + n * o.z, u.push(a.x, a.y, a.z)
						}
					}! function() {
						for (let e = 0; e < t; e++) f(e);
						f(!1 === i ? t : 0),
							function() {
								for (let e = 0; e <= t; e++)
									for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, d.push(l.x, l.y)
							}(),
							function() {
								for (let e = 1; e <= t; e++)
									for (let t = 1; t <= r; t++) {
										const n = (r + 1) * (e - 1) + (t - 1),
											i = (r + 1) * e + (t - 1),
											s = (r + 1) * e + t,
											a = (r + 1) * (e - 1) + t;
										p.push(n, i, a), p.push(i, s, a)
									}
							}()
					}(), this.setIndex(p), this.setAttribute("position", new ki(u, 3)), this.setAttribute("normal", new ki(h, 3)), this.setAttribute("uv", new ki(d, 2))
				}
				toJSON() {
					const e = super.toJSON();
					return e.path = this.parameters.path.toJSON(), e
				}
				static fromJSON(e) {
					return new th((new du[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
				}
			}
			class nh extends qi {
				constructor(e = null) {
					if (super(), this.type = "WireframeGeometry", this.parameters = {
							geometry: e
						}, null !== e) {
						const t = [],
							n = new Set,
							r = new ir,
							i = new ir;
						if (null !== e.index) {
							const s = e.attributes.position,
								a = e.index;
							let o = e.groups;
							0 === o.length && (o = [{
								start: 0,
								count: a.count,
								materialIndex: 0
							}]);
							for (let e = 0, l = o.length; e < l; ++e) {
								const l = o[e],
									c = l.start;
								for (let e = c, o = c + l.count; e < o; e += 3)
									for (let l = 0; l < 3; l++) {
										const o = a.getX(e + l),
											c = a.getX(e + (l + 1) % 3);
										r.fromBufferAttribute(s, o), i.fromBufferAttribute(s, c), !0 === rh(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
									}
							}
						} else {
							const s = e.attributes.position;
							for (let e = 0, a = s.count / 3; e < a; e++)
								for (let o = 0; o < 3; o++) {
									const a = 3 * e + o,
										l = 3 * e + (o + 1) % 3;
									r.fromBufferAttribute(s, a), i.fromBufferAttribute(s, l), !0 === rh(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
								}
						}
						this.setAttribute("position", new ki(t, 3))
					}
				}
			}

			function rh(e, t, n) {
				const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
					i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
				return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r, i), !0)
			}
			var ih = Object.freeze({
				__proto__: null,
				BoxGeometry: fs,
				BoxBufferGeometry: fs,
				CircleGeometry: Nc,
				CircleBufferGeometry: Nc,
				ConeGeometry: kc,
				ConeBufferGeometry: kc,
				CylinderGeometry: Hc,
				CylinderBufferGeometry: Hc,
				DodecahedronGeometry: Uc,
				DodecahedronBufferGeometry: Uc,
				EdgesGeometry: Jc,
				ExtrudeGeometry: Wu,
				ExtrudeBufferGeometry: Wu,
				IcosahedronGeometry: Ju,
				IcosahedronBufferGeometry: Ju,
				LatheGeometry: Xu,
				LatheBufferGeometry: Xu,
				OctahedronGeometry: qu,
				OctahedronBufferGeometry: qu,
				PlaneGeometry: Ds,
				PlaneBufferGeometry: Ds,
				PolyhedronGeometry: Gc,
				PolyhedronBufferGeometry: Gc,
				RingGeometry: Ku,
				RingBufferGeometry: Ku,
				ShapeGeometry: Yu,
				ShapeBufferGeometry: Yu,
				SphereGeometry: Qu,
				SphereBufferGeometry: Qu,
				TetrahedronGeometry: Zu,
				TetrahedronBufferGeometry: Zu,
				TorusGeometry: $u,
				TorusBufferGeometry: $u,
				TorusKnotGeometry: eh,
				TorusKnotBufferGeometry: eh,
				TubeGeometry: th,
				TubeBufferGeometry: th,
				WireframeGeometry: nh
			});
			class sh extends xi {
				constructor(e) {
					super(), this.type = "ShadowMaterial", this.color = new Ei(0), this.transparent = !0, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this
				}
			}
			sh.prototype.isShadowMaterial = !0;
			class ah extends xi {
				constructor(e) {
					super(), this.defines = {
						STANDARD: ""
					}, this.type = "MeshStandardMaterial", this.color = new Ei(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ei(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $t, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.defines = {
						STANDARD: ""
					}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
				}
			}
			ah.prototype.isMeshStandardMaterial = !0;
			class oh extends ah {
				constructor(e) {
					super(), this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					}, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new zn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
						get: function() {
							return Fn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
						},
						set: function(e) {
							this.ior = (1 + .4 * e) / (1 - .4 * e)
						}
					}), this.sheenColor = new Ei(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ei(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ei(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
				}
				get sheen() {
					return this._sheen
				}
				set sheen(e) {
					this._sheen > 0 !== e > 0 && this.version++, this._sheen = e
				}
				get clearcoat() {
					return this._clearcoat
				}
				set clearcoat(e) {
					this._clearcoat > 0 !== e > 0 && this.version++, this._clearcoat = e
				}
				get transmission() {
					return this._transmission
				}
				set transmission(e) {
					this._transmission > 0 !== e > 0 && this.version++, this._transmission = e
				}
				copy(e) {
					return super.copy(e), this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					}, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
				}
			}
			oh.prototype.isMeshPhysicalMaterial = !0;
			class lh extends xi {
				constructor(e) {
					super(), this.type = "MeshPhongMaterial", this.color = new Ei(16777215), this.specular = new Ei(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ei(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $t, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
				}
			}
			lh.prototype.isMeshPhongMaterial = !0;
			class ch extends xi {
				constructor(e) {
					super(), this.defines = {
						TOON: ""
					}, this.type = "MeshToonMaterial", this.color = new Ei(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ei(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $t, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
				}
			}
			ch.prototype.isMeshToonMaterial = !0;
			class uh extends xi {
				constructor(e) {
					super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $t, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
				}
			}
			uh.prototype.isMeshNormalMaterial = !0;
			class hh extends xi {
				constructor(e) {
					super(), this.type = "MeshLambertMaterial", this.color = new Ei(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ei(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
				}
			}
			hh.prototype.isMeshLambertMaterial = !0;
			class dh extends xi {
				constructor(e) {
					super(), this.defines = {
						MATCAP: ""
					}, this.type = "MeshMatcapMaterial", this.color = new Ei(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $t, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.defines = {
						MATCAP: ""
					}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
				}
			}
			dh.prototype.isMeshMatcapMaterial = !0;
			class ph extends mc {
				constructor(e) {
					super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
				}
				copy(e) {
					return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
				}
			}
			ph.prototype.isLineDashedMaterial = !0;
			var fh = Object.freeze({
				__proto__: null,
				ShadowMaterial: sh,
				SpriteMaterial: Pl,
				RawShaderMaterial: js,
				ShaderMaterial: ys,
				PointsMaterial: Ec,
				MeshPhysicalMaterial: oh,
				MeshStandardMaterial: ah,
				MeshPhongMaterial: lh,
				MeshToonMaterial: ch,
				MeshNormalMaterial: uh,
				MeshLambertMaterial: hh,
				MeshDepthMaterial: dl,
				MeshDistanceMaterial: pl,
				MeshBasicMaterial: Ti,
				MeshMatcapMaterial: dh,
				LineDashedMaterial: ph,
				LineBasicMaterial: mc,
				Material: xi
			});
			const mh = {
				arraySlice: function(e, t, n) {
					return mh.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
				},
				convertArray: function(e, t, n) {
					return !e || !n && e.constructor === t ? e : "number" === typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
				},
				isTypedArray: function(e) {
					return ArrayBuffer.isView(e) && !(e instanceof DataView)
				},
				getKeyframeOrder: function(e) {
					const t = e.length,
						n = new Array(t);
					for (let r = 0; r !== t; ++r) n[r] = r;
					return n.sort((function(t, n) {
						return e[t] - e[n]
					})), n
				},
				sortedArray: function(e, t, n) {
					const r = e.length,
						i = new e.constructor(r);
					for (let s = 0, a = 0; a !== r; ++s) {
						const r = n[s] * t;
						for (let n = 0; n !== t; ++n) i[a++] = e[r + n]
					}
					return i
				},
				flattenJSON: function(e, t, n, r) {
					let i = 1,
						s = e[0];
					for (; void 0 !== s && void 0 === s[r];) s = e[i++];
					if (void 0 === s) return;
					let a = s[r];
					if (void 0 !== a)
						if (Array.isArray(a))
							do {
								a = s[r], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[i++]
							} while (void 0 !== s);
						else if (void 0 !== a.toArray)
						do {
							a = s[r], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[i++]
						} while (void 0 !== s);
					else
						do {
							a = s[r], void 0 !== a && (t.push(s.time), n.push(a)), s = e[i++]
						} while (void 0 !== s)
				},
				subclip: function(e, t, n, r, i = 30) {
					const s = e.clone();
					s.name = t;
					const a = [];
					for (let l = 0; l < s.tracks.length; ++l) {
						const e = s.tracks[l],
							t = e.getValueSize(),
							o = [],
							c = [];
						for (let s = 0; s < e.times.length; ++s) {
							const a = e.times[s] * i;
							if (!(a < n || a >= r)) {
								o.push(e.times[s]);
								for (let n = 0; n < t; ++n) c.push(e.values[s * t + n])
							}
						}
						0 !== o.length && (e.times = mh.convertArray(o, e.times.constructor), e.values = mh.convertArray(c, e.values.constructor), a.push(e))
					}
					s.tracks = a;
					let o = 1 / 0;
					for (let l = 0; l < s.tracks.length; ++l) o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
					for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
					return s.resetDuration(), s
				},
				makeClipAdditive: function(e, t = 0, n = e, r = 30) {
					r <= 0 && (r = 30);
					const i = n.tracks.length,
						s = t / r;
					for (let a = 0; a < i; ++a) {
						const t = n.tracks[a],
							r = t.ValueTypeName;
						if ("bool" === r || "string" === r) continue;
						const i = e.tracks.find((function(e) {
							return e.name === t.name && e.ValueTypeName === r
						}));
						if (void 0 === i) continue;
						let o = 0;
						const l = t.getValueSize();
						t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
						let c = 0;
						const u = i.getValueSize();
						i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
						const h = t.times.length - 1;
						let d;
						if (s <= t.times[0]) {
							const e = o,
								n = l - o;
							d = mh.arraySlice(t.values, e, n)
						} else if (s >= t.times[h]) {
							const e = h * l + o,
								n = e + l - o;
							d = mh.arraySlice(t.values, e, n)
						} else {
							const e = t.createInterpolant(),
								n = o,
								r = l - o;
							e.evaluate(s), d = mh.arraySlice(e.resultBuffer, n, r)
						}
						if ("quaternion" === r) {
							(new rr).fromArray(d).normalize().conjugate().toArray(d)
						}
						const p = i.times.length;
						for (let e = 0; e < p; ++e) {
							const t = e * u + c;
							if ("quaternion" === r) rr.multiplyQuaternionsFlat(i.values, t, d, 0, i.values, t);
							else {
								const e = u - 2 * c;
								for (let n = 0; n < e; ++n) i.values[t + n] -= d[n]
							}
						}
					}
					return e.blendMode = jt, e
				}
			};
			class gh {
				constructor(e, t, n, r) {
					this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
				}
				evaluate(e) {
					const t = this.parameterPositions;
					let n = this._cachedIndex,
						r = t[n],
						i = t[n - 1];
					e: {
						t: {
							let s;n: {
								r: if (!(e < r)) {
									for (let s = n + 2;;) {
										if (void 0 === r) {
											if (e < i) break r;
											return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
										}
										if (n === s) break;
										if (i = r, r = t[++n], e < r) break t
									}
									s = t.length;
									break n
								}if (e >= i) break e; {
									const a = t[1];
									e < a && (n = 2, i = a);
									for (let s = n - 2;;) {
										if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
										if (n === s) break;
										if (r = i, i = t[--n - 1], e >= i) break t
									}
									s = n, n = 0
								}
							}
							for (; n < s;) {
								const r = n + s >>> 1;
								e < t[r] ? s = r : n = r + 1
							}
							if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0,
							this.beforeStart_(0, e, r);
							if (void 0 === r) return n = t.length,
							this._cachedIndex = n,
							this.afterEnd_(n - 1, i, e)
						}
						this._cachedIndex = n,
						this.intervalChanged_(n, i, r)
					}
					return this.interpolate_(n, i, e, r)
				}
				getSettings_() {
					return this.settings || this.DefaultSettings_
				}
				copySampleValue_(e) {
					const t = this.resultBuffer,
						n = this.sampleValues,
						r = this.valueSize,
						i = e * r;
					for (let s = 0; s !== r; ++s) t[s] = n[i + s];
					return t
				}
				interpolate_() {
					throw new Error("call to abstract method")
				}
				intervalChanged_() {}
			}
			gh.prototype.beforeStart_ = gh.prototype.copySampleValue_, gh.prototype.afterEnd_ = gh.prototype.copySampleValue_;
			class vh extends gh {
				constructor(e, t, n, r) {
					super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
						endingStart: Ut,
						endingEnd: Ut
					}
				}
				intervalChanged_(e, t, n) {
					const r = this.parameterPositions;
					let i = e - 2,
						s = e + 1,
						a = r[i],
						o = r[s];
					if (void 0 === a) switch (this.getSettings_().endingStart) {
						case zt:
							i = e, a = 2 * t - n;
							break;
						case Vt:
							i = r.length - 2, a = t + r[i] - r[i + 1];
							break;
						default:
							i = e, a = n
					}
					if (void 0 === o) switch (this.getSettings_().endingEnd) {
						case zt:
							s = e, o = 2 * n - t;
							break;
						case Vt:
							s = 1, o = n + r[1] - r[0];
							break;
						default:
							s = e - 1, o = t
					}
					const l = .5 * (n - t),
						c = this.valueSize;
					this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = i * c, this._offsetNext = s * c
				}
				interpolate_(e, t, n, r) {
					const i = this.resultBuffer,
						s = this.sampleValues,
						a = this.valueSize,
						o = e * a,
						l = o - a,
						c = this._offsetPrev,
						u = this._offsetNext,
						h = this._weightPrev,
						d = this._weightNext,
						p = (n - t) / (r - t),
						f = p * p,
						m = f * p,
						g = -h * m + 2 * h * f - h * p,
						v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
						y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
						x = d * m - d * f;
					for (let _ = 0; _ !== a; ++_) i[_] = g * s[c + _] + v * s[l + _] + y * s[o + _] + x * s[u + _];
					return i
				}
			}
			class yh extends gh {
				constructor(e, t, n, r) {
					super(e, t, n, r)
				}
				interpolate_(e, t, n, r) {
					const i = this.resultBuffer,
						s = this.sampleValues,
						a = this.valueSize,
						o = e * a,
						l = o - a,
						c = (n - t) / (r - t),
						u = 1 - c;
					for (let h = 0; h !== a; ++h) i[h] = s[l + h] * u + s[o + h] * c;
					return i
				}
			}
			class xh extends gh {
				constructor(e, t, n, r) {
					super(e, t, n, r)
				}
				interpolate_(e) {
					return this.copySampleValue_(e - 1)
				}
			}
			class _h {
				constructor(e, t, n, r) {
					if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
					this.name = e, this.times = mh.convertArray(t, this.TimeBufferType), this.values = mh.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
				}
				static toJSON(e) {
					const t = e.constructor;
					let n;
					if (t.toJSON !== this.toJSON) n = t.toJSON(e);
					else {
						n = {
							name: e.name,
							times: mh.convertArray(e.times, Array),
							values: mh.convertArray(e.values, Array)
						};
						const t = e.getInterpolation();
						t !== e.DefaultInterpolation && (n.interpolation = t)
					}
					return n.type = e.ValueTypeName, n
				}
				InterpolantFactoryMethodDiscrete(e) {
					return new xh(this.times, this.values, this.getValueSize(), e)
				}
				InterpolantFactoryMethodLinear(e) {
					return new yh(this.times, this.values, this.getValueSize(), e)
				}
				InterpolantFactoryMethodSmooth(e) {
					return new vh(this.times, this.values, this.getValueSize(), e)
				}
				setInterpolation(e) {
					let t;
					switch (e) {
						case Ht:
							t = this.InterpolantFactoryMethodDiscrete;
							break;
						case kt:
							t = this.InterpolantFactoryMethodLinear;
							break;
						case Gt:
							t = this.InterpolantFactoryMethodSmooth
					}
					if (void 0 === t) {
						const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
						if (void 0 === this.createInterpolant) {
							if (e === this.DefaultInterpolation) throw new Error(t);
							this.setInterpolation(this.DefaultInterpolation)
						}
						return console.warn("THREE.KeyframeTrack:", t), this
					}
					return this.createInterpolant = t, this
				}
				getInterpolation() {
					switch (this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return Ht;
						case this.InterpolantFactoryMethodLinear:
							return kt;
						case this.InterpolantFactoryMethodSmooth:
							return Gt
					}
				}
				getValueSize() {
					return this.values.length / this.times.length
				}
				shift(e) {
					if (0 !== e) {
						const t = this.times;
						for (let n = 0, r = t.length; n !== r; ++n) t[n] += e
					}
					return this
				}
				scale(e) {
					if (1 !== e) {
						const t = this.times;
						for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e
					}
					return this
				}
				trim(e, t) {
					const n = this.times,
						r = n.length;
					let i = 0,
						s = r - 1;
					for (; i !== r && n[i] < e;) ++i;
					for (; - 1 !== s && n[s] > t;) --s;
					if (++s, 0 !== i || s !== r) {
						i >= s && (s = Math.max(s, 1), i = s - 1);
						const e = this.getValueSize();
						this.times = mh.arraySlice(n, i, s), this.values = mh.arraySlice(this.values, i * e, s * e)
					}
					return this
				}
				validate() {
					let e = !0;
					const t = this.getValueSize();
					t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
					const n = this.times,
						r = this.values,
						i = n.length;
					0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
					let s = null;
					for (let a = 0; a !== i; a++) {
						const t = n[a];
						if ("number" === typeof t && isNaN(t)) {
							console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, t), e = !1;
							break
						}
						if (null !== s && s > t) {
							console.error("THREE.KeyframeTrack: Out of order keys.", this, a, t, s), e = !1;
							break
						}
						s = t
					}
					if (void 0 !== r && mh.isTypedArray(r))
						for (let a = 0, o = r.length; a !== o; ++a) {
							const t = r[a];
							if (isNaN(t)) {
								console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, t), e = !1;
								break
							}
						}
					return e
				}
				optimize() {
					const e = mh.arraySlice(this.times),
						t = mh.arraySlice(this.values),
						n = this.getValueSize(),
						r = this.getInterpolation() === Gt,
						i = e.length - 1;
					let s = 1;
					for (let a = 1; a < i; ++a) {
						let i = !1;
						const o = e[a];
						if (o !== e[a + 1] && (1 !== a || o !== e[0]))
							if (r) i = !0;
							else {
								const e = a * n,
									r = e - n,
									s = e + n;
								for (let a = 0; a !== n; ++a) {
									const n = t[e + a];
									if (n !== t[r + a] || n !== t[s + a]) {
										i = !0;
										break
									}
								}
							} if (i) {
							if (a !== s) {
								e[s] = e[a];
								const r = a * n,
									i = s * n;
								for (let e = 0; e !== n; ++e) t[i + e] = t[r + e]
							}++s
						}
					}
					if (i > 0) {
						e[s] = e[i];
						for (let e = i * n, r = s * n, a = 0; a !== n; ++a) t[r + a] = t[e + a];
						++s
					}
					return s !== e.length ? (this.times = mh.arraySlice(e, 0, s), this.values = mh.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this
				}
				clone() {
					const e = mh.arraySlice(this.times, 0),
						t = mh.arraySlice(this.values, 0),
						n = new(0, this.constructor)(this.name, e, t);
					return n.createInterpolant = this.createInterpolant, n
				}
			}
			_h.prototype.TimeBufferType = Float32Array, _h.prototype.ValueBufferType = Float32Array, _h.prototype.DefaultInterpolation = kt;
			class bh extends _h {}
			bh.prototype.ValueTypeName = "bool", bh.prototype.ValueBufferType = Array, bh.prototype.DefaultInterpolation = Ht, bh.prototype.InterpolantFactoryMethodLinear = void 0, bh.prototype.InterpolantFactoryMethodSmooth = void 0;
			class wh extends _h {}
			wh.prototype.ValueTypeName = "color";
			class Mh extends _h {}
			Mh.prototype.ValueTypeName = "number";
			class Ah extends gh {
				constructor(e, t, n, r) {
					super(e, t, n, r)
				}
				interpolate_(e, t, n, r) {
					const i = this.resultBuffer,
						s = this.sampleValues,
						a = this.valueSize,
						o = (n - t) / (r - t);
					let l = e * a;
					for (let c = l + a; l !== c; l += 4) rr.slerpFlat(i, 0, s, l - a, s, l, o);
					return i
				}
			}
			class Sh extends _h {
				InterpolantFactoryMethodLinear(e) {
					return new Ah(this.times, this.values, this.getValueSize(), e)
				}
			}
			Sh.prototype.ValueTypeName = "quaternion", Sh.prototype.DefaultInterpolation = kt, Sh.prototype.InterpolantFactoryMethodSmooth = void 0;
			class Eh extends _h {}
			Eh.prototype.ValueTypeName = "string", Eh.prototype.ValueBufferType = Array, Eh.prototype.DefaultInterpolation = Ht, Eh.prototype.InterpolantFactoryMethodLinear = void 0, Eh.prototype.InterpolantFactoryMethodSmooth = void 0;
			class Th extends _h {}
			Th.prototype.ValueTypeName = "vector";
			class Ch {
				constructor(e, t = -1, n, r = Wt) {
					this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = Dn(), this.duration < 0 && this.resetDuration()
				}
				static parse(e) {
					const t = [],
						n = e.tracks,
						r = 1 / (e.fps || 1);
					for (let s = 0, a = n.length; s !== a; ++s) t.push(Bh(n[s]).scale(r));
					const i = new this(e.name, e.duration, t, e.blendMode);
					return i.uuid = e.uuid, i
				}
				static toJSON(e) {
					const t = [],
						n = e.tracks,
						r = {
							name: e.name,
							duration: e.duration,
							tracks: t,
							uuid: e.uuid,
							blendMode: e.blendMode
						};
					for (let i = 0, s = n.length; i !== s; ++i) t.push(_h.toJSON(n[i]));
					return r
				}
				static CreateFromMorphTargetSequence(e, t, n, r) {
					const i = t.length,
						s = [];
					for (let a = 0; a < i; a++) {
						let e = [],
							o = [];
						e.push((a + i - 1) % i, a, (a + 1) % i), o.push(0, 1, 0);
						const l = mh.getKeyframeOrder(e);
						e = mh.sortedArray(e, 1, l), o = mh.sortedArray(o, 1, l), r || 0 !== e[0] || (e.push(i), o.push(o[0])), s.push(new Mh(".morphTargetInfluences[" + t[a].name + "]", e, o).scale(1 / n))
					}
					return new this(e, -1, s)
				}
				static findByName(e, t) {
					let n = e;
					if (!Array.isArray(e)) {
						const t = e;
						n = t.geometry && t.geometry.animations || t.animations
					}
					for (let r = 0; r < n.length; r++)
						if (n[r].name === t) return n[r];
					return null
				}
				static CreateClipsFromMorphTargetSequences(e, t, n) {
					const r = {},
						i = /^([\w-]*?)([\d]+)$/;
					for (let a = 0, o = e.length; a < o; a++) {
						const t = e[a],
							n = t.name.match(i);
						if (n && n.length > 1) {
							const e = n[1];
							let i = r[e];
							i || (r[e] = i = []), i.push(t)
						}
					}
					const s = [];
					for (const a in r) s.push(this.CreateFromMorphTargetSequence(a, r[a], t, n));
					return s
				}
				static parseAnimation(e, t) {
					if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
					const n = function(e, t, n, r, i) {
							if (0 !== n.length) {
								const s = [],
									a = [];
								mh.flattenJSON(n, s, a, r), 0 !== s.length && i.push(new e(t, s, a))
							}
						},
						r = [],
						i = e.name || "default",
						s = e.fps || 30,
						a = e.blendMode;
					let o = e.length || -1;
					const l = e.hierarchy || [];
					for (let c = 0; c < l.length; c++) {
						const e = l[c].keys;
						if (e && 0 !== e.length)
							if (e[0].morphTargets) {
								const t = {};
								let n;
								for (n = 0; n < e.length; n++)
									if (e[n].morphTargets)
										for (let r = 0; r < e[n].morphTargets.length; r++) t[e[n].morphTargets[r]] = -1;
								for (const i in t) {
									const t = [],
										s = [];
									for (let r = 0; r !== e[n].morphTargets.length; ++r) {
										const r = e[n];
										t.push(r.time), s.push(r.morphTarget === i ? 1 : 0)
									}
									r.push(new Mh(".morphTargetInfluence[" + i + "]", t, s))
								}
								o = t.length * (s || 1)
							} else {
								const i = ".bones[" + t[c].name + "]";
								n(Th, i + ".position", e, "pos", r), n(Sh, i + ".quaternion", e, "rot", r), n(Th, i + ".scale", e, "scl", r)
							}
					}
					if (0 === r.length) return null;
					return new this(i, o, r, a)
				}
				resetDuration() {
					let e = 0;
					for (let t = 0, n = this.tracks.length; t !== n; ++t) {
						const n = this.tracks[t];
						e = Math.max(e, n.times[n.times.length - 1])
					}
					return this.duration = e, this
				}
				trim() {
					for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
					return this
				}
				validate() {
					let e = !0;
					for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
					return e
				}
				optimize() {
					for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
					return this
				}
				clone() {
					const e = [];
					for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
					return new this.constructor(this.name, this.duration, e, this.blendMode)
				}
				toJSON() {
					return this.constructor.toJSON(this)
				}
			}

			function Bh(e) {
				if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
				const t = function(e) {
					switch (e.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return Mh;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return Th;
						case "color":
							return wh;
						case "quaternion":
							return Sh;
						case "bool":
						case "boolean":
							return bh;
						case "string":
							return Eh
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
				}(e.type);
				if (void 0 === e.times) {
					const t = [],
						n = [];
					mh.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
				}
				return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
			}
			const Rh = {
				enabled: !1,
				files: {},
				add: function(e, t) {
					!1 !== this.enabled && (this.files[e] = t)
				},
				get: function(e) {
					if (!1 !== this.enabled) return this.files[e]
				},
				remove: function(e) {
					delete this.files[e]
				},
				clear: function() {
					this.files = {}
				}
			};
			class Lh {
				constructor(e, t, n) {
					const r = this;
					let i, s = !1,
						a = 0,
						o = 0;
					const l = [];
					this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
						o++, !1 === s && void 0 !== r.onStart && r.onStart(e, a, o), s = !0
					}, this.itemEnd = function(e) {
						a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (s = !1, void 0 !== r.onLoad && r.onLoad())
					}, this.itemError = function(e) {
						void 0 !== r.onError && r.onError(e)
					}, this.resolveURL = function(e) {
						return i ? i(e) : e
					}, this.setURLModifier = function(e) {
						return i = e, this
					}, this.addHandler = function(e, t) {
						return l.push(e, t), this
					}, this.removeHandler = function(e) {
						const t = l.indexOf(e);
						return -1 !== t && l.splice(t, 2), this
					}, this.getHandler = function(e) {
						for (let t = 0, n = l.length; t < n; t += 2) {
							const n = l[t],
								r = l[t + 1];
							if (n.global && (n.lastIndex = 0), n.test(e)) return r
						}
						return null
					}
				}
			}
			const Ih = new Lh;
			class Ph {
				constructor(e) {
					this.manager = void 0 !== e ? e : Ih, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
				}
				load() {}
				loadAsync(e, t) {
					const n = this;
					return new Promise((function(r, i) {
						n.load(e, r, t, i)
					}))
				}
				parse() {}
				setCrossOrigin(e) {
					return this.crossOrigin = e, this
				}
				setWithCredentials(e) {
					return this.withCredentials = e, this
				}
				setPath(e) {
					return this.path = e, this
				}
				setResourcePath(e) {
					return this.resourcePath = e, this
				}
				setRequestHeader(e) {
					return this.requestHeader = e, this
				}
			}
			const Dh = {};
			class Fh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
					const i = Rh.get(e);
					if (void 0 !== i) return this.manager.itemStart(e), setTimeout((() => {
						t && t(i), this.manager.itemEnd(e)
					}), 0), i;
					if (void 0 !== Dh[e]) return void Dh[e].push({
						onLoad: t,
						onProgress: n,
						onError: r
					});
					Dh[e] = [], Dh[e].push({
						onLoad: t,
						onProgress: n,
						onError: r
					});
					const s = new Request(e, {
						headers: new Headers(this.requestHeader),
						credentials: this.withCredentials ? "include" : "same-origin"
					});
					fetch(s).then((t => {
						if (200 === t.status || 0 === t.status) {
							if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" === typeof ReadableStream || void 0 === t.body.getReader) return t;
							const n = Dh[e],
								r = t.body.getReader(),
								i = t.headers.get("Content-Length"),
								s = i ? parseInt(i) : 0,
								a = 0 !== s;
							let o = 0;
							const l = new ReadableStream({
								start(e) {
									! function t() {
										r.read().then((({
											done: r,
											value: i
										}) => {
											if (r) e.close();
											else {
												o += i.byteLength;
												const r = new ProgressEvent("progress", {
													lengthComputable: a,
													loaded: o,
													total: s
												});
												for (let e = 0, t = n.length; e < t; e++) {
													const t = n[e];
													t.onProgress && t.onProgress(r)
												}
												e.enqueue(i), t()
											}
										}))
									}()
								}
							});
							return new Response(l)
						}
						throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
					})).then((e => {
						switch (this.responseType) {
							case "arraybuffer":
								return e.arrayBuffer();
							case "blob":
								return e.blob();
							case "document":
								return e.text().then((e => (new DOMParser).parseFromString(e, this.mimeType)));
							case "json":
								return e.json();
							default:
								return e.text()
						}
					})).then((t => {
						Rh.add(e, t);
						const n = Dh[e];
						delete Dh[e];
						for (let e = 0, r = n.length; e < r; e++) {
							const r = n[e];
							r.onLoad && r.onLoad(t)
						}
					})).catch((t => {
						const n = Dh[e];
						if (void 0 === n) throw this.manager.itemError(e), t;
						delete Dh[e];
						for (let e = 0, r = n.length; e < r; e++) {
							const r = n[e];
							r.onError && r.onError(t)
						}
						this.manager.itemError(e)
					})).finally((() => {
						this.manager.itemEnd(e)
					})), this.manager.itemStart(e)
				}
				setResponseType(e) {
					return this.responseType = e, this
				}
				setMimeType(e) {
					return this.mimeType = e, this
				}
			}
			class Oh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = new Fh(this.manager);
					s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
						try {
							t(i.parse(JSON.parse(n)))
						} catch (s) {
							r ? r(s) : console.error(s), i.manager.itemError(e)
						}
					}), n, r)
				}
				parse(e) {
					const t = [];
					for (let n = 0; n < e.length; n++) {
						const r = Ch.parse(e[n]);
						t.push(r)
					}
					return t
				}
			}
			class Nh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = [],
						a = new Fc,
						o = new Fh(this.manager);
					o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(i.withCredentials);
					let l = 0;

					function c(c) {
						o.load(e[c], (function(e) {
							const n = i.parse(e, !0);
							s[c] = {
								width: n.width,
								height: n.height,
								format: n.format,
								mipmaps: n.mipmaps
							}, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = xe), a.image = s, a.format = n.format, a.needsUpdate = !0, t && t(a))
						}), n, r)
					}
					if (Array.isArray(e))
						for (let u = 0, h = e.length; u < h; ++u) c(u);
					else o.load(e, (function(e) {
						const n = i.parse(e, !0);
						if (n.isCubemap) {
							const e = n.mipmaps.length / n.mipmapCount;
							for (let t = 0; t < e; t++) {
								s[t] = {
									mipmaps: []
								};
								for (let e = 0; e < n.mipmapCount; e++) s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), s[t].format = n.format, s[t].width = n.width, s[t].height = n.height
							}
							a.image = s
						} else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
						1 === n.mipmapCount && (a.minFilter = xe), a.format = n.format, a.needsUpdate = !0, t && t(a)
					}), n, r);
					return a
				}
			}
			class Hh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
					const i = this,
						s = Rh.get(e);
					if (void 0 !== s) return i.manager.itemStart(e), setTimeout((function() {
						t && t(s), i.manager.itemEnd(e)
					}), 0), s;
					const a = Xn("img");

					function o() {
						c(), Rh.add(e, this), t && t(this), i.manager.itemEnd(e)
					}

					function l(t) {
						c(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
					}

					function c() {
						a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
					}
					return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
				}
			}
			class kh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = new Ms,
						s = new Hh(this.manager);
					s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
					let a = 0;

					function o(n) {
						s.load(e[n], (function(e) {
							i.images[n] = e, a++, 6 === a && (i.needsUpdate = !0, t && t(i))
						}), void 0, r)
					}
					for (let l = 0; l < e.length; ++l) o(l);
					return i
				}
			}
			class Gh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = new sc,
						a = new Fh(this.manager);
					return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(e, (function(e) {
						const n = i.parse(e);
						n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : de, s.wrapT = void 0 !== n.wrapT ? n.wrapT : de, s.magFilter = void 0 !== n.magFilter ? n.magFilter : xe, s.minFilter = void 0 !== n.minFilter ? n.minFilter : xe, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = we), 1 === n.mipmapCount && (s.minFilter = xe), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n))
					}), n, r), s
				}
			}
			class Uh extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = new Qn,
						s = new Hh(this.manager);
					return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
						i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
					}), n, r), i
				}
			}
			class zh extends ai {
				constructor(e, t = 1) {
					super(), this.type = "Light", this.color = new Ei(e), this.intensity = t
				}
				dispose() {}
				copy(e) {
					return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
				}
			}
			zh.prototype.isLight = !0;
			class Vh extends zh {
				constructor(e, t, n) {
					super(e, n), this.type = "HemisphereLight", this.position.copy(ai.DefaultUp), this.updateMatrix(), this.groundColor = new Ei(t)
				}
				copy(e) {
					return zh.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
				}
			}
			Vh.prototype.isHemisphereLight = !0;
			const Wh = new Fr,
				jh = new ir,
				Jh = new ir;
			class Xh {
				constructor(e) {
					this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new zn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Fr, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ls, this._frameExtents = new zn(1, 1), this._viewportCount = 1, this._viewports = [new $n(0, 0, 1, 1)]
				}
				getViewportCount() {
					return this._viewportCount
				}
				getFrustum() {
					return this._frustum
				}
				updateMatrices(e) {
					const t = this.camera,
						n = this.matrix;
					jh.setFromMatrixPosition(e.matrixWorld), t.position.copy(jh), Jh.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Jh), t.updateMatrixWorld(), Wh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Wh), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
				}
				getViewport(e) {
					return this._viewports[e]
				}
				getFrameExtents() {
					return this._frameExtents
				}
				dispose() {
					this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
				}
				copy(e) {
					return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				toJSON() {
					const e = {};
					return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
				}
			}
			class qh extends Xh {
				constructor() {
					super(new _s(50, 1, .5, 500)), this.focus = 1
				}
				updateMatrices(e) {
					const t = this.camera,
						n = 2 * Pn * e.angle * this.focus,
						r = this.mapSize.width / this.mapSize.height,
						i = e.distance || t.far;
					n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e)
				}
				copy(e) {
					return super.copy(e), this.focus = e.focus, this
				}
			}
			qh.prototype.isSpotLightShadow = !0;
			class Kh extends zh {
				constructor(e, t, n = 0, r = Math.PI / 3, i = 0, s = 1) {
					super(e, t), this.type = "SpotLight", this.position.copy(ai.DefaultUp), this.updateMatrix(), this.target = new ai, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new qh
				}
				get power() {
					return this.intensity * Math.PI
				}
				set power(e) {
					this.intensity = e / Math.PI
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(e) {
					return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
				}
			}
			Kh.prototype.isSpotLight = !0;
			const Yh = new Fr,
				Qh = new ir,
				Zh = new ir;
			class $h extends Xh {
				constructor() {
					super(new _s(90, 1, .5, 500)), this._frameExtents = new zn(4, 2), this._viewportCount = 6, this._viewports = [new $n(2, 1, 1, 1), new $n(0, 1, 1, 1), new $n(3, 1, 1, 1), new $n(1, 1, 1, 1), new $n(3, 0, 1, 1), new $n(1, 0, 1, 1)], this._cubeDirections = [new ir(1, 0, 0), new ir(-1, 0, 0), new ir(0, 0, 1), new ir(0, 0, -1), new ir(0, 1, 0), new ir(0, -1, 0)], this._cubeUps = [new ir(0, 1, 0), new ir(0, 1, 0), new ir(0, 1, 0), new ir(0, 1, 0), new ir(0, 0, 1), new ir(0, 0, -1)]
				}
				updateMatrices(e, t = 0) {
					const n = this.camera,
						r = this.matrix,
						i = e.distance || n.far;
					i !== n.far && (n.far = i, n.updateProjectionMatrix()), Qh.setFromMatrixPosition(e.matrixWorld), n.position.copy(Qh), Zh.copy(n.position), Zh.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Zh), n.updateMatrixWorld(), r.makeTranslation(-Qh.x, -Qh.y, -Qh.z), Yh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Yh)
				}
			}
			$h.prototype.isPointLightShadow = !0;
			class ed extends zh {
				constructor(e, t, n = 0, r = 1) {
					super(e, t), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new $h
				}
				get power() {
					return 4 * this.intensity * Math.PI
				}
				set power(e) {
					this.intensity = e / (4 * Math.PI)
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(e) {
					return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
				}
			}
			ed.prototype.isPointLight = !0;
			class td extends Xh {
				constructor() {
					super(new Ws(-5, 5, 5, -5, .5, 500))
				}
			}
			td.prototype.isDirectionalLightShadow = !0;
			class nd extends zh {
				constructor(e, t) {
					super(e, t), this.type = "DirectionalLight", this.position.copy(ai.DefaultUp), this.updateMatrix(), this.target = new ai, this.shadow = new td
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(e) {
					return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
				}
			}
			nd.prototype.isDirectionalLight = !0;
			class rd extends zh {
				constructor(e, t) {
					super(e, t), this.type = "AmbientLight"
				}
			}
			rd.prototype.isAmbientLight = !0;
			class id extends zh {
				constructor(e, t, n = 10, r = 10) {
					super(e, t), this.type = "RectAreaLight", this.width = n, this.height = r
				}
				get power() {
					return this.intensity * this.width * this.height * Math.PI
				}
				set power(e) {
					this.intensity = e / (this.width * this.height * Math.PI)
				}
				copy(e) {
					return super.copy(e), this.width = e.width, this.height = e.height, this
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.object.width = this.width, t.object.height = this.height, t
				}
			}
			id.prototype.isRectAreaLight = !0;
			class sd {
				constructor() {
					this.coefficients = [];
					for (let e = 0; e < 9; e++) this.coefficients.push(new ir)
				}
				set(e) {
					for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
					return this
				}
				zero() {
					for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
					return this
				}
				getAt(e, t) {
					const n = e.x,
						r = e.y,
						i = e.z,
						s = this.coefficients;
					return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * r * 1.092548), t.addScaledVector(s[5], r * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], n * i * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - r * r)), t
				}
				getIrradianceAt(e, t) {
					const n = e.x,
						r = e.y,
						i = e.z,
						s = this.coefficients;
					return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * r), t.addScaledVector(s[5], .858086 * r * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * n * i), t.addScaledVector(s[8], .429043 * (n * n - r * r)), t
				}
				add(e) {
					for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
					return this
				}
				addScaledSH(e, t) {
					for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
					return this
				}
				scale(e) {
					for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
					return this
				}
				lerp(e, t) {
					for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
					return this
				}
				equals(e) {
					for (let t = 0; t < 9; t++)
						if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
					return !0
				}
				copy(e) {
					return this.set(e.coefficients)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				fromArray(e, t = 0) {
					const n = this.coefficients;
					for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
					return this
				}
				toArray(e = [], t = 0) {
					const n = this.coefficients;
					for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
					return e
				}
				static getBasisAt(e, t) {
					const n = e.x,
						r = e.y,
						i = e.z;
					t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
				}
			}
			sd.prototype.isSphericalHarmonics3 = !0;
			class ad extends zh {
				constructor(e = new sd, t = 1) {
					super(void 0, t), this.sh = e
				}
				copy(e) {
					return super.copy(e), this.sh.copy(e.sh), this
				}
				fromJSON(e) {
					return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.object.sh = this.sh.toArray(), t
				}
			}
			ad.prototype.isLightProbe = !0;
			class od extends Ph {
				constructor(e) {
					super(e), this.textures = {}
				}
				load(e, t, n, r) {
					const i = this,
						s = new Fh(i.manager);
					s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, (function(n) {
						try {
							t(i.parse(JSON.parse(n)))
						} catch (s) {
							r ? r(s) : console.error(s), i.manager.itemError(e)
						}
					}), n, r)
				}
				parse(e) {
					const t = this.textures;

					function n(e) {
						return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
					}
					const r = new fh[e.type];
					if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = (new Ei).setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.format && (r.format = e.format), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" === typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
						for (const i in e.uniforms) {
							const t = e.uniforms[i];
							switch (r.uniforms[i] = {}, t.type) {
								case "t":
									r.uniforms[i].value = n(t.value);
									break;
								case "c":
									r.uniforms[i].value = (new Ei).setHex(t.value);
									break;
								case "v2":
									r.uniforms[i].value = (new zn).fromArray(t.value);
									break;
								case "v3":
									r.uniforms[i].value = (new ir).fromArray(t.value);
									break;
								case "v4":
									r.uniforms[i].value = (new $n).fromArray(t.value);
									break;
								case "m3":
									r.uniforms[i].value = (new Vn).fromArray(t.value);
									break;
								case "m4":
									r.uniforms[i].value = (new Fr).fromArray(t.value);
									break;
								default:
									r.uniforms[i].value = t.value
							}
						}
					if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
						for (const i in e.extensions) r.extensions[i] = e.extensions[i];
					if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
						let t = e.normalScale;
						!1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new zn).fromArray(t)
					}
					return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new zn).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r
				}
				setTextures(e) {
					return this.textures = e, this
				}
			}
			class ld {
				static decodeText(e) {
					if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(e);
					let t = "";
					for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
					try {
						return decodeURIComponent(escape(t))
					} catch (n) {
						return t
					}
				}
				static extractUrlBase(e) {
					const t = e.lastIndexOf("/");
					return -1 === t ? "./" : e.substr(0, t + 1)
				}
				static resolveURL(e, t) {
					return "string" !== typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
				}
			}
			class cd extends qi {
				constructor() {
					super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
				}
				copy(e) {
					return super.copy(e), this.instanceCount = e.instanceCount, this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				toJSON() {
					const e = super.toJSON(this);
					return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
				}
			}
			cd.prototype.isInstancedBufferGeometry = !0;
			class ud extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = new Fh(i.manager);
					s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, (function(n) {
						try {
							t(i.parse(JSON.parse(n)))
						} catch (s) {
							r ? r(s) : console.error(s), i.manager.itemError(e)
						}
					}), n, r)
				}
				parse(e) {
					const t = {},
						n = {};

					function r(e, r) {
						if (void 0 !== t[r]) return t[r];
						const i = e.interleavedBuffers[r],
							s = function(e, t) {
								if (void 0 !== n[t]) return n[t];
								const r = e.arrayBuffers[t],
									i = new Uint32Array(r).buffer;
								return n[t] = i, i
							}(e, i.buffer),
							a = Jn(i.type, s),
							o = new Rl(a, i.stride);
						return o.uuid = i.uuid, t[r] = o, o
					}
					const i = e.isInstancedBufferGeometry ? new cd : new qi,
						s = e.data.index;
					if (void 0 !== s) {
						const e = Jn(s.type, s.array);
						i.setIndex(new Ri(e, 1))
					}
					const a = e.data.attributes;
					for (const u in a) {
						const t = a[u];
						let n;
						if (t.isInterleavedBufferAttribute) {
							const i = r(e.data, t.data);
							n = new Il(i, t.itemSize, t.offset, t.normalized)
						} else {
							const e = Jn(t.type, t.array);
							n = new(t.isInstancedBufferAttribute ? cc : Ri)(e, t.itemSize, t.normalized)
						}
						void 0 !== t.name && (n.name = t.name), void 0 !== t.usage && n.setUsage(t.usage), void 0 !== t.updateRange && (n.updateRange.offset = t.updateRange.offset, n.updateRange.count = t.updateRange.count), i.setAttribute(u, n)
					}
					const o = e.data.morphAttributes;
					if (o)
						for (const u in o) {
							const t = o[u],
								n = [];
							for (let i = 0, s = t.length; i < s; i++) {
								const s = t[i];
								let a;
								if (s.isInterleavedBufferAttribute) {
									const t = r(e.data, s.data);
									a = new Il(t, s.itemSize, s.offset, s.normalized)
								} else {
									const e = Jn(s.type, s.array);
									a = new Ri(e, s.itemSize, s.normalized)
								}
								void 0 !== s.name && (a.name = s.name), n.push(a)
							}
							i.morphAttributes[u] = n
						}
					e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
					const l = e.data.groups || e.data.drawcalls || e.data.offsets;
					if (void 0 !== l)
						for (let u = 0, h = l.length; u !== h; ++u) {
							const e = l[u];
							i.addGroup(e.start, e.count, e.materialIndex)
						}
					const c = e.data.boundingSphere;
					if (void 0 !== c) {
						const e = new ir;
						void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new Er(e, c.radius)
					}
					return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
				}
			}
			class hd extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = "" === this.path ? ld.extractUrlBase(e) : this.path;
					this.resourcePath = this.resourcePath || s;
					const a = new Fh(this.manager);
					a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function(n) {
						let s = null;
						try {
							s = JSON.parse(n)
						} catch (o) {
							return void 0 !== r && r(o), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", o.message)
						}
						const a = s.metadata;
						void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e)
					}), n, r)
				}
				async loadAsync(e, t) {
					const n = "" === this.path ? ld.extractUrlBase(e) : this.path;
					this.resourcePath = this.resourcePath || n;
					const r = new Fh(this.manager);
					r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
					const i = await r.loadAsync(e, t),
						s = JSON.parse(i),
						a = s.metadata;
					if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
					return await this.parseAsync(s)
				}
				parse(e, t) {
					const n = this.parseAnimations(e.animations),
						r = this.parseShapes(e.shapes),
						i = this.parseGeometries(e.geometries, r),
						s = this.parseImages(e.images, (function() {
							void 0 !== t && t(l)
						})),
						a = this.parseTextures(e.textures, s),
						o = this.parseMaterials(e.materials, a),
						l = this.parseObject(e.object, i, o, a, n),
						c = this.parseSkeletons(e.skeletons, l);
					if (this.bindSkeletons(l, c), void 0 !== t) {
						let e = !1;
						for (const t in s)
							if (s[t] instanceof HTMLImageElement) {
								e = !0;
								break
							}! 1 === e && t(l)
					}
					return l
				}
				async parseAsync(e) {
					const t = this.parseAnimations(e.animations),
						n = this.parseShapes(e.shapes),
						r = this.parseGeometries(e.geometries, n),
						i = await this.parseImagesAsync(e.images),
						s = this.parseTextures(e.textures, i),
						a = this.parseMaterials(e.materials, s),
						o = this.parseObject(e.object, r, a, s, t),
						l = this.parseSkeletons(e.skeletons, o);
					return this.bindSkeletons(o, l), o
				}
				parseShapes(e) {
					const t = {};
					if (void 0 !== e)
						for (let n = 0, r = e.length; n < r; n++) {
							const r = (new mu).fromJSON(e[n]);
							t[r.uuid] = r
						}
					return t
				}
				parseSkeletons(e, t) {
					const n = {},
						r = {};
					if (t.traverse((function(e) {
							e.isBone && (r[e.uuid] = e)
						})), void 0 !== e)
						for (let i = 0, s = e.length; i < s; i++) {
							const t = (new lc).fromJSON(e[i], r);
							n[t.uuid] = t
						}
					return n
				}
				parseGeometries(e, t) {
					const n = {};
					if (void 0 !== e) {
						const r = new ud;
						for (let i = 0, s = e.length; i < s; i++) {
							let s;
							const a = e[i];
							switch (a.type) {
								case "BufferGeometry":
								case "InstancedBufferGeometry":
									s = r.parse(a);
									break;
								case "Geometry":
									console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
									break;
								default:
									a.type in ih ? s = ih[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
							}
							s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
						}
					}
					return n
				}
				parseMaterials(e, t) {
					const n = {},
						r = {};
					if (void 0 !== e) {
						const i = new od;
						i.setTextures(t);
						for (let t = 0, s = e.length; t < s; t++) {
							const s = e[t];
							if ("MultiMaterial" === s.type) {
								const e = [];
								for (let t = 0; t < s.materials.length; t++) {
									const r = s.materials[t];
									void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)), e.push(n[r.uuid])
								}
								r[s.uuid] = e
							} else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
						}
					}
					return r
				}
				parseAnimations(e) {
					const t = {};
					if (void 0 !== e)
						for (let n = 0; n < e.length; n++) {
							const r = e[n],
								i = Ch.parse(r);
							t[i.uuid] = i
						}
					return t
				}
				parseImages(e, t) {
					const n = this,
						r = {};
					let i;

					function s(e) {
						if ("string" === typeof e) {
							const t = e;
							return function(e) {
								return n.manager.itemStart(e), i.load(e, (function() {
									n.manager.itemEnd(e)
								}), void 0, (function() {
									n.manager.itemError(e), n.manager.itemEnd(e)
								}))
							}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
						}
						return e.data ? {
							data: Jn(e.type, e.data),
							width: e.width,
							height: e.height
						} : null
					}
					if (void 0 !== e && e.length > 0) {
						const n = new Lh(t);
						i = new Hh(n), i.setCrossOrigin(this.crossOrigin);
						for (let t = 0, i = e.length; t < i; t++) {
							const n = e[t],
								i = n.url;
							if (Array.isArray(i)) {
								r[n.uuid] = [];
								for (let e = 0, t = i.length; e < t; e++) {
									const t = s(i[e]);
									null !== t && (t instanceof HTMLImageElement ? r[n.uuid].push(t) : r[n.uuid].push(new sc(t.data, t.width, t.height)))
								}
							} else {
								const e = s(n.url);
								null !== e && (r[n.uuid] = e)
							}
						}
					}
					return r
				}
				async parseImagesAsync(e) {
					const t = this,
						n = {};
					let r;
					async function i(e) {
						if ("string" === typeof e) {
							const n = e,
								i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
							return await r.loadAsync(i)
						}
						return e.data ? {
							data: Jn(e.type, e.data),
							width: e.width,
							height: e.height
						} : null
					}
					if (void 0 !== e && e.length > 0) {
						r = new Hh(this.manager), r.setCrossOrigin(this.crossOrigin);
						for (let t = 0, r = e.length; t < r; t++) {
							const r = e[t],
								s = r.url;
							if (Array.isArray(s)) {
								n[r.uuid] = [];
								for (let e = 0, t = s.length; e < t; e++) {
									const t = s[e],
										a = await i(t);
									null !== a && (a instanceof HTMLImageElement ? n[r.uuid].push(a) : n[r.uuid].push(new sc(a.data, a.width, a.height)))
								}
							} else {
								const e = await i(r.url);
								null !== e && (n[r.uuid] = e)
							}
						}
					}
					return n
				}
				parseTextures(e, t) {
					function n(e, t) {
						return "number" === typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
					}
					const r = {};
					if (void 0 !== e)
						for (let i = 0, s = e.length; i < s; i++) {
							const s = e[i];
							let a;
							void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
							const o = t[s.image];
							Array.isArray(o) ? (a = new Ms(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new sc(o.data, o.width, o.height) : new Qn(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, dd)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], pd), a.wrapT = n(s.wrap[1], pd)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, fd)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, fd)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (a.userData = s.userData), r[s.uuid] = a
						}
					return r
				}
				parseObject(e, t, n, r, i) {
					let s, a, o;

					function l(e) {
						return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
					}

					function c(e) {
						if (void 0 !== e) {
							if (Array.isArray(e)) {
								const t = [];
								for (let r = 0, i = e.length; r < i; r++) {
									const i = e[r];
									void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i])
								}
								return t
							}
							return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
						}
					}

					function u(e) {
						return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e]
					}
					switch (e.type) {
						case "Scene":
							s = new Bl, void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new Ei(e.background) : s.background = u(e.background)), void 0 !== e.environment && (s.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new Cl(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new Tl(e.fog.color, e.fog.density)));
							break;
						case "PerspectiveCamera":
							s = new _s(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view));
							break;
						case "OrthographicCamera":
							s = new Ws(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view));
							break;
						case "AmbientLight":
							s = new rd(e.color, e.intensity);
							break;
						case "DirectionalLight":
							s = new nd(e.color, e.intensity);
							break;
						case "PointLight":
							s = new ed(e.color, e.intensity, e.distance, e.decay);
							break;
						case "RectAreaLight":
							s = new id(e.color, e.intensity, e.width, e.height);
							break;
						case "SpotLight":
							s = new Kh(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
							break;
						case "HemisphereLight":
							s = new Vh(e.color, e.groundColor, e.intensity);
							break;
						case "LightProbe":
							s = (new ad).fromJSON(e);
							break;
						case "SkinnedMesh":
							a = l(e.geometry), o = c(e.material), s = new rc(a, o), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton);
							break;
						case "Mesh":
							a = l(e.geometry), o = c(e.material), s = new ds(a, o);
							break;
						case "InstancedMesh":
							a = l(e.geometry), o = c(e.material);
							const t = e.count,
								n = e.instanceMatrix,
								r = e.instanceColor;
							s = new fc(a, o, t), s.instanceMatrix = new cc(new Float32Array(n.array), 16), void 0 !== r && (s.instanceColor = new cc(new Float32Array(r.array), r.itemSize));
							break;
						case "LOD":
							s = new Ql;
							break;
						case "Line":
							s = new bc(l(e.geometry), c(e.material));
							break;
						case "LineLoop":
							s = new Sc(l(e.geometry), c(e.material));
							break;
						case "LineSegments":
							s = new Ac(l(e.geometry), c(e.material));
							break;
						case "PointCloud":
						case "Points":
							s = new Lc(l(e.geometry), c(e.material));
							break;
						case "Sprite":
							s = new Xl(c(e.material));
							break;
						case "Group":
							s = new xl;
							break;
						case "Bone":
							s = new ic;
							break;
						default:
							s = new ai
					}
					if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) {
						const a = e.children;
						for (let e = 0; e < a.length; e++) s.add(this.parseObject(a[e], t, n, r, i))
					}
					if (void 0 !== e.animations) {
						const t = e.animations;
						for (let e = 0; e < t.length; e++) {
							const n = t[e];
							s.animations.push(i[n])
						}
					}
					if ("LOD" === e.type) {
						void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
						const t = e.levels;
						for (let e = 0; e < t.length; e++) {
							const n = t[e],
								r = s.getObjectByProperty("uuid", n.object);
							void 0 !== r && s.addLevel(r, n.distance)
						}
					}
					return s
				}
				bindSkeletons(e, t) {
					0 !== Object.keys(t).length && e.traverse((function(e) {
						if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
							const n = t[e.skeleton];
							void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
						}
					}))
				}
				setTexturePath(e) {
					return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
				}
			}
			const dd = {
					UVMapping: ie,
					CubeReflectionMapping: se,
					CubeRefractionMapping: ae,
					EquirectangularReflectionMapping: oe,
					EquirectangularRefractionMapping: le,
					CubeUVReflectionMapping: ce,
					CubeUVRefractionMapping: ue
				},
				pd = {
					RepeatWrapping: he,
					ClampToEdgeWrapping: de,
					MirroredRepeatWrapping: pe
				},
				fd = {
					NearestFilter: fe,
					NearestMipmapNearestFilter: me,
					NearestMipmapLinearFilter: ve,
					LinearFilter: xe,
					LinearMipmapNearestFilter: _e,
					LinearMipmapLinearFilter: we
				};
			class md extends Ph {
				constructor(e) {
					super(e), "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
						premultiplyAlpha: "none"
					}
				}
				setOptions(e) {
					return this.options = e, this
				}
				load(e, t, n, r) {
					void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
					const i = this,
						s = Rh.get(e);
					if (void 0 !== s) return i.manager.itemStart(e), setTimeout((function() {
						t && t(s), i.manager.itemEnd(e)
					}), 0), s;
					const a = {};
					a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function(e) {
						return e.blob()
					})).then((function(e) {
						return createImageBitmap(e, Object.assign(i.options, {
							colorSpaceConversion: "none"
						}))
					})).then((function(n) {
						Rh.add(e, n), t && t(n), i.manager.itemEnd(e)
					})).catch((function(t) {
						r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
					})), i.manager.itemStart(e)
				}
			}
			let gd;
			md.prototype.isImageBitmapLoader = !0;
			const vd = {
				getContext: function() {
					return void 0 === gd && (gd = new(window.AudioContext || window.webkitAudioContext)), gd
				},
				setContext: function(e) {
					gd = e
				}
			};
			class yd extends Ph {
				constructor(e) {
					super(e)
				}
				load(e, t, n, r) {
					const i = this,
						s = new Fh(this.manager);
					s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
						try {
							const e = n.slice(0);
							vd.getContext().decodeAudioData(e, (function(e) {
								t(e)
							}))
						} catch (s) {
							r ? r(s) : console.error(s), i.manager.itemError(e)
						}
					}), n, r)
				}
			}
			class xd extends ad {
				constructor(e, t, n = 1) {
					super(void 0, n);
					const r = (new Ei).set(e),
						i = (new Ei).set(t),
						s = new ir(r.r, r.g, r.b),
						a = new ir(i.r, i.g, i.b),
						o = Math.sqrt(Math.PI),
						l = o * Math.sqrt(.75);
					this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
				}
			}
			xd.prototype.isHemisphereLightProbe = !0;
			class _d extends ad {
				constructor(e, t = 1) {
					super(void 0, t);
					const n = (new Ei).set(e);
					this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
				}
			}
			_d.prototype.isAmbientLightProbe = !0;
			const bd = new Fr,
				wd = new Fr,
				Md = new Fr;
			class Ad {
				constructor() {
					this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new _s, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new _s, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
						focus: null,
						fov: null,
						aspect: null,
						near: null,
						far: null,
						zoom: null,
						eyeSep: null
					}
				}
				update(e) {
					const t = this._cache;
					if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
						t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Md.copy(e.projectionMatrix);
						const n = t.eyeSep / 2,
							r = n * t.near / t.focus,
							i = t.near * Math.tan(In * t.fov * .5) / t.zoom;
						let s, a;
						wd.elements[12] = -n, bd.elements[12] = n, s = -i * t.aspect + r, a = i * t.aspect + r, Md.elements[0] = 2 * t.near / (a - s), Md.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(Md), s = -i * t.aspect - r, a = i * t.aspect - r, Md.elements[0] = 2 * t.near / (a - s), Md.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(Md)
					}
					this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(wd), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(bd)
				}
			}
			class Sd {
				constructor(e = !0) {
					this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
				}
				start() {
					this.startTime = Ed(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
				}
				stop() {
					this.getElapsedTime(), this.running = !1, this.autoStart = !1
				}
				getElapsedTime() {
					return this.getDelta(), this.elapsedTime
				}
				getDelta() {
					let e = 0;
					if (this.autoStart && !this.running) return this.start(), 0;
					if (this.running) {
						const t = Ed();
						e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
					}
					return e
				}
			}

			function Ed() {
				return ("undefined" === typeof performance ? Date : performance).now()
			}
			const Td = new ir,
				Cd = new rr,
				Bd = new ir,
				Rd = new ir;
			class Ld extends ai {
				constructor() {
					super(), this.type = "AudioListener", this.context = vd.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sd
				}
				getInput() {
					return this.gain
				}
				removeFilter() {
					return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
				}
				getFilter() {
					return this.filter
				}
				setFilter(e) {
					return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
				}
				getMasterVolume() {
					return this.gain.gain.value
				}
				setMasterVolume(e) {
					return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
				}
				updateMatrixWorld(e) {
					super.updateMatrixWorld(e);
					const t = this.context.listener,
						n = this.up;
					if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Td, Cd, Bd), Rd.set(0, 0, -1).applyQuaternion(Cd), t.positionX) {
						const e = this.context.currentTime + this.timeDelta;
						t.positionX.linearRampToValueAtTime(Td.x, e), t.positionY.linearRampToValueAtTime(Td.y, e), t.positionZ.linearRampToValueAtTime(Td.z, e), t.forwardX.linearRampToValueAtTime(Rd.x, e), t.forwardY.linearRampToValueAtTime(Rd.y, e), t.forwardZ.linearRampToValueAtTime(Rd.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
					} else t.setPosition(Td.x, Td.y, Td.z), t.setOrientation(Rd.x, Rd.y, Rd.z, n.x, n.y, n.z)
				}
			}
			class Id extends ai {
				constructor(e) {
					super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
				}
				getOutput() {
					return this.gain
				}
				setNodeSource(e) {
					return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
				}
				setMediaElementSource(e) {
					return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
				}
				setMediaStreamSource(e) {
					return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
				}
				setBuffer(e) {
					return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
				}
				play(e = 0) {
					if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
					if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
					this._startedAt = this.context.currentTime + e;
					const t = this.context.createBufferSource();
					return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
				}
				pause() {
					if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				stop() {
					if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				connect() {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
						this.filters[this.filters.length - 1].connect(this.getOutput())
					} else this.source.connect(this.getOutput());
					return this._connected = !0, this
				}
				disconnect() {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput())
					} else this.source.disconnect(this.getOutput());
					return this._connected = !1, this
				}
				getFilters() {
					return this.filters
				}
				setFilters(e) {
					return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
				}
				setDetune(e) {
					if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
				}
				getDetune() {
					return this.detune
				}
				getFilter() {
					return this.getFilters()[0]
				}
				setFilter(e) {
					return this.setFilters(e ? [e] : [])
				}
				setPlaybackRate(e) {
					if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				getPlaybackRate() {
					return this.playbackRate
				}
				onEnded() {
					this.isPlaying = !1
				}
				getLoop() {
					return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
				}
				setLoop(e) {
					if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				setLoopStart(e) {
					return this.loopStart = e, this
				}
				setLoopEnd(e) {
					return this.loopEnd = e, this
				}
				getVolume() {
					return this.gain.gain.value
				}
				setVolume(e) {
					return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
				}
			}
			const Pd = new ir,
				Dd = new rr,
				Fd = new ir,
				Od = new ir;
			class Nd extends Id {
				constructor(e) {
					super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
				}
				getOutput() {
					return this.panner
				}
				getRefDistance() {
					return this.panner.refDistance
				}
				setRefDistance(e) {
					return this.panner.refDistance = e, this
				}
				getRolloffFactor() {
					return this.panner.rolloffFactor
				}
				setRolloffFactor(e) {
					return this.panner.rolloffFactor = e, this
				}
				getDistanceModel() {
					return this.panner.distanceModel
				}
				setDistanceModel(e) {
					return this.panner.distanceModel = e, this
				}
				getMaxDistance() {
					return this.panner.maxDistance
				}
				setMaxDistance(e) {
					return this.panner.maxDistance = e, this
				}
				setDirectionalCone(e, t, n) {
					return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
				}
				updateMatrixWorld(e) {
					if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
					this.matrixWorld.decompose(Pd, Dd, Fd), Od.set(0, 0, 1).applyQuaternion(Dd);
					const t = this.panner;
					if (t.positionX) {
						const e = this.context.currentTime + this.listener.timeDelta;
						t.positionX.linearRampToValueAtTime(Pd.x, e), t.positionY.linearRampToValueAtTime(Pd.y, e), t.positionZ.linearRampToValueAtTime(Pd.z, e), t.orientationX.linearRampToValueAtTime(Od.x, e), t.orientationY.linearRampToValueAtTime(Od.y, e), t.orientationZ.linearRampToValueAtTime(Od.z, e)
					} else t.setPosition(Pd.x, Pd.y, Pd.z), t.setOrientation(Od.x, Od.y, Od.z)
				}
			}
			class Hd {
				constructor(e, t = 2048) {
					this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
				}
				getFrequencyData() {
					return this.analyser.getByteFrequencyData(this.data), this.data
				}
				getAverageFrequency() {
					let e = 0;
					const t = this.getFrequencyData();
					for (let n = 0; n < t.length; n++) e += t[n];
					return e / t.length
				}
			}
			class kd {
				constructor(e, t, n) {
					let r, i, s;
					switch (this.binding = e, this.valueSize = n, t) {
						case "quaternion":
							r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
							break;
						case "string":
						case "bool":
							r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
							break;
						default:
							r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
					}
					this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
				}
				accumulate(e, t) {
					const n = this.buffer,
						r = this.valueSize,
						i = e * r + r;
					let s = this.cumulativeWeight;
					if (0 === s) {
						for (let e = 0; e !== r; ++e) n[i + e] = n[e];
						s = t
					} else {
						s += t;
						const e = t / s;
						this._mixBufferRegion(n, i, 0, e, r)
					}
					this.cumulativeWeight = s
				}
				accumulateAdditive(e) {
					const t = this.buffer,
						n = this.valueSize,
						r = n * this._addIndex;
					0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
				}
				apply(e) {
					const t = this.valueSize,
						n = this.buffer,
						r = e * t + t,
						i = this.cumulativeWeight,
						s = this.cumulativeWeightAdditive,
						a = this.binding;
					if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
						const e = t * this._origIndex;
						this._mixBufferRegion(n, r, e, 1 - i, t)
					}
					s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
					for (let o = t, l = t + t; o !== l; ++o)
						if (n[o] !== n[o + t]) {
							a.setValue(n, r);
							break
						}
				}
				saveOriginalState() {
					const e = this.binding,
						t = this.buffer,
						n = this.valueSize,
						r = n * this._origIndex;
					e.getValue(t, r);
					for (let i = n, s = r; i !== s; ++i) t[i] = t[r + i % n];
					this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
				}
				restoreOriginalState() {
					const e = 3 * this.valueSize;
					this.binding.setValue(this.buffer, e)
				}
				_setAdditiveIdentityNumeric() {
					const e = this._addIndex * this.valueSize,
						t = e + this.valueSize;
					for (let n = e; n < t; n++) this.buffer[n] = 0
				}
				_setAdditiveIdentityQuaternion() {
					this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
				}
				_setAdditiveIdentityOther() {
					const e = this._origIndex * this.valueSize,
						t = this._addIndex * this.valueSize;
					for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
				}
				_select(e, t, n, r, i) {
					if (r >= .5)
						for (let s = 0; s !== i; ++s) e[t + s] = e[n + s]
				}
				_slerp(e, t, n, r) {
					rr.slerpFlat(e, t, e, t, e, n, r)
				}
				_slerpAdditive(e, t, n, r, i) {
					const s = this._workIndex * i;
					rr.multiplyQuaternionsFlat(e, s, e, t, e, n), rr.slerpFlat(e, t, e, t, e, s, r)
				}
				_lerp(e, t, n, r, i) {
					const s = 1 - r;
					for (let a = 0; a !== i; ++a) {
						const i = t + a;
						e[i] = e[i] * s + e[n + a] * r
					}
				}
				_lerpAdditive(e, t, n, r, i) {
					for (let s = 0; s !== i; ++s) {
						const i = t + s;
						e[i] = e[i] + e[n + s] * r
					}
				}
			}
			const Gd = "\\[\\]\\.:\\/",
				Ud = new RegExp("[\\[\\]\\.:\\/]", "g"),
				zd = "[^\\[\\]\\.:\\/]",
				Vd = "[^" + Gd.replace("\\.", "") + "]",
				Wd = /((?:WC+[\/:])*)/.source.replace("WC", zd),
				jd = /(WCOD+)?/.source.replace("WCOD", Vd),
				Jd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", zd),
				Xd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", zd),
				qd = new RegExp("^" + Wd + jd + Jd + Xd + "$"),
				Kd = ["material", "materials", "bones"];
			class Yd {
				constructor(e, t, n) {
					this.path = t, this.parsedPath = n || Yd.parseTrackName(t), this.node = Yd.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
				}
				static create(e, t, n) {
					return e && e.isAnimationObjectGroup ? new Yd.Composite(e, t, n) : new Yd(e, t, n)
				}
				static sanitizeNodeName(e) {
					return e.replace(/\s/g, "_").replace(Ud, "")
				}
				static parseTrackName(e) {
					const t = qd.exec(e);
					if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
					const n = {
							nodeName: t[2],
							objectName: t[3],
							objectIndex: t[4],
							propertyName: t[5],
							propertyIndex: t[6]
						},
						r = n.nodeName && n.nodeName.lastIndexOf(".");
					if (void 0 !== r && -1 !== r) {
						const e = n.nodeName.substring(r + 1); - 1 !== Kd.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)
					}
					if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
					return n
				}
				static findNode(e, t) {
					if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
					if (e.skeleton) {
						const n = e.skeleton.getBoneByName(t);
						if (void 0 !== n) return n
					}
					if (e.children) {
						const n = function(e) {
								for (let r = 0; r < e.length; r++) {
									const i = e[r];
									if (i.name === t || i.uuid === t) return i;
									const s = n(i.children);
									if (s) return s
								}
								return null
							},
							r = n(e.children);
						if (r) return r
					}
					return null
				}
				_getValue_unavailable() {}
				_setValue_unavailable() {}
				_getValue_direct(e, t) {
					e[t] = this.targetObject[this.propertyName]
				}
				_getValue_array(e, t) {
					const n = this.resolvedProperty;
					for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
				}
				_getValue_arrayElement(e, t) {
					e[t] = this.resolvedProperty[this.propertyIndex]
				}
				_getValue_toArray(e, t) {
					this.resolvedProperty.toArray(e, t)
				}
				_setValue_direct(e, t) {
					this.targetObject[this.propertyName] = e[t]
				}
				_setValue_direct_setNeedsUpdate(e, t) {
					this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
				}
				_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
					this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_array(e, t) {
					const n = this.resolvedProperty;
					for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
				}
				_setValue_array_setNeedsUpdate(e, t) {
					const n = this.resolvedProperty;
					for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
					this.targetObject.needsUpdate = !0
				}
				_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
					const n = this.resolvedProperty;
					for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
					this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_arrayElement(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t]
				}
				_setValue_arrayElement_setNeedsUpdate(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
				}
				_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_fromArray(e, t) {
					this.resolvedProperty.fromArray(e, t)
				}
				_setValue_fromArray_setNeedsUpdate(e, t) {
					this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
				}
				_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
					this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_getValue_unbound(e, t) {
					this.bind(), this.getValue(e, t)
				}
				_setValue_unbound(e, t) {
					this.bind(), this.setValue(e, t)
				}
				bind() {
					let e = this.node;
					const t = this.parsedPath,
						n = t.objectName,
						r = t.propertyName;
					let i = t.propertyIndex;
					if (e || (e = Yd.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
					if (n) {
						let r = t.objectIndex;
						switch (n) {
							case "materials":
								if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
								e = e.material.materials;
								break;
							case "bones":
								if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								e = e.skeleton.bones;
								for (let t = 0; t < e.length; t++)
									if (e[t].name === r) {
										r = t;
										break
									} break;
							default:
								if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								e = e[n]
						}
						if (void 0 !== r) {
							if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
							e = e[r]
						}
					}
					const s = e[r];
					if (void 0 === s) {
						const n = t.nodeName;
						return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
					}
					let a = this.Versioning.None;
					this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
					let o = this.BindingType.Direct;
					if (void 0 !== i) {
						if ("morphTargetInfluences" === r) {
							if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
							if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
							void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
						}
						o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
					} else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
					this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
				}
				unbind() {
					this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
				}
			}
			Yd.Composite = class {
				constructor(e, t, n) {
					const r = n || Yd.parseTrackName(t);
					this._targetGroup = e, this._bindings = e.subscribe_(t, r)
				}
				getValue(e, t) {
					this.bind();
					const n = this._targetGroup.nCachedObjects_,
						r = this._bindings[n];
					void 0 !== r && r.getValue(e, t)
				}
				setValue(e, t) {
					const n = this._bindings;
					for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
				}
				bind() {
					const e = this._bindings;
					for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
				}
				unbind() {
					const e = this._bindings;
					for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
				}
			}, Yd.prototype.BindingType = {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			}, Yd.prototype.Versioning = {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			}, Yd.prototype.GetterByBindingType = [Yd.prototype._getValue_direct, Yd.prototype._getValue_array, Yd.prototype._getValue_arrayElement, Yd.prototype._getValue_toArray], Yd.prototype.SetterByBindingTypeAndVersioning = [
				[Yd.prototype._setValue_direct, Yd.prototype._setValue_direct_setNeedsUpdate, Yd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
				[Yd.prototype._setValue_array, Yd.prototype._setValue_array_setNeedsUpdate, Yd.prototype._setValue_array_setMatrixWorldNeedsUpdate],
				[Yd.prototype._setValue_arrayElement, Yd.prototype._setValue_arrayElement_setNeedsUpdate, Yd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
				[Yd.prototype._setValue_fromArray, Yd.prototype._setValue_fromArray_setNeedsUpdate, Yd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
			];
			class Qd {
				constructor() {
					this.uuid = Dn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
					const e = {};
					this._indicesByUUID = e;
					for (let n = 0, r = arguments.length; n !== r; ++n) e[arguments[n].uuid] = n;
					this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
					const t = this;
					this.stats = {
						objects: {
							get total() {
								return t._objects.length
							},
							get inUse() {
								return this.total - t.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return t._bindings.length
						}
					}
				}
				add() {
					const e = this._objects,
						t = this._indicesByUUID,
						n = this._paths,
						r = this._parsedPaths,
						i = this._bindings,
						s = i.length;
					let a, o = e.length,
						l = this.nCachedObjects_;
					for (let c = 0, u = arguments.length; c !== u; ++c) {
						const u = arguments[c],
							h = u.uuid;
						let d = t[h];
						if (void 0 === d) {
							d = o++, t[h] = d, e.push(u);
							for (let e = 0, t = s; e !== t; ++e) i[e].push(new Yd(u, n[e], r[e]))
						} else if (d < l) {
							a = e[d];
							const o = --l,
								c = e[o];
							t[c.uuid] = d, e[d] = c, t[h] = o, e[o] = u;
							for (let e = 0, t = s; e !== t; ++e) {
								const t = i[e],
									s = t[o];
								let a = t[d];
								t[d] = s, void 0 === a && (a = new Yd(u, n[e], r[e])), t[o] = a
							}
						} else e[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
					}
					this.nCachedObjects_ = l
				}
				remove() {
					const e = this._objects,
						t = this._indicesByUUID,
						n = this._bindings,
						r = n.length;
					let i = this.nCachedObjects_;
					for (let s = 0, a = arguments.length; s !== a; ++s) {
						const a = arguments[s],
							o = a.uuid,
							l = t[o];
						if (void 0 !== l && l >= i) {
							const s = i++,
								c = e[s];
							t[c.uuid] = l, e[l] = c, t[o] = s, e[s] = a;
							for (let e = 0, t = r; e !== t; ++e) {
								const t = n[e],
									r = t[s],
									i = t[l];
								t[l] = r, t[s] = i
							}
						}
					}
					this.nCachedObjects_ = i
				}
				uncache() {
					const e = this._objects,
						t = this._indicesByUUID,
						n = this._bindings,
						r = n.length;
					let i = this.nCachedObjects_,
						s = e.length;
					for (let a = 0, o = arguments.length; a !== o; ++a) {
						const o = arguments[a].uuid,
							l = t[o];
						if (void 0 !== l)
							if (delete t[o], l < i) {
								const a = --i,
									o = e[a],
									c = --s,
									u = e[c];
								t[o.uuid] = l, e[l] = o, t[u.uuid] = a, e[a] = u, e.pop();
								for (let e = 0, t = r; e !== t; ++e) {
									const t = n[e],
										r = t[a],
										i = t[c];
									t[l] = r, t[a] = i, t.pop()
								}
							} else {
								const i = --s,
									a = e[i];
								i > 0 && (t[a.uuid] = l), e[l] = a, e.pop();
								for (let e = 0, t = r; e !== t; ++e) {
									const t = n[e];
									t[l] = t[i], t.pop()
								}
							}
					}
					this.nCachedObjects_ = i
				}
				subscribe_(e, t) {
					const n = this._bindingsIndicesByPath;
					let r = n[e];
					const i = this._bindings;
					if (void 0 !== r) return i[r];
					const s = this._paths,
						a = this._parsedPaths,
						o = this._objects,
						l = o.length,
						c = this.nCachedObjects_,
						u = new Array(l);
					r = i.length, n[e] = r, s.push(e), a.push(t), i.push(u);
					for (let h = c, d = o.length; h !== d; ++h) {
						const n = o[h];
						u[h] = new Yd(n, e, t)
					}
					return u
				}
				unsubscribe_(e) {
					const t = this._bindingsIndicesByPath,
						n = t[e];
					if (void 0 !== n) {
						const r = this._paths,
							i = this._parsedPaths,
							s = this._bindings,
							a = s.length - 1,
							o = s[a];
						t[e[a]] = n, s[n] = o, s.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
					}
				}
			}
			Qd.prototype.isAnimationObjectGroup = !0;
			class Zd {
				constructor(e, t, n = null, r = t.blendMode) {
					this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
					const i = t.tracks,
						s = i.length,
						a = new Array(s),
						o = {
							endingStart: Ut,
							endingEnd: Ut
						};
					for (let l = 0; l !== s; ++l) {
						const e = i[l].createInterpolant(null);
						a[l] = e, e.settings = o
					}
					this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Ot, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
				}
				play() {
					return this._mixer._activateAction(this), this
				}
				stop() {
					return this._mixer._deactivateAction(this), this.reset()
				}
				reset() {
					return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
				}
				isRunning() {
					return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
				}
				isScheduled() {
					return this._mixer._isActiveAction(this)
				}
				startAt(e) {
					return this._startTime = e, this
				}
				setLoop(e, t) {
					return this.loop = e, this.repetitions = t, this
				}
				setEffectiveWeight(e) {
					return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
				}
				getEffectiveWeight() {
					return this._effectiveWeight
				}
				fadeIn(e) {
					return this._scheduleFading(e, 0, 1)
				}
				fadeOut(e) {
					return this._scheduleFading(e, 1, 0)
				}
				crossFadeFrom(e, t, n) {
					if (e.fadeOut(t), this.fadeIn(t), n) {
						const n = this._clip.duration,
							r = e._clip.duration,
							i = r / n,
							s = n / r;
						e.warp(1, i, t), this.warp(s, 1, t)
					}
					return this
				}
				crossFadeTo(e, t, n) {
					return e.crossFadeFrom(this, t, n)
				}
				stopFading() {
					const e = this._weightInterpolant;
					return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
				}
				setEffectiveTimeScale(e) {
					return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
				}
				getEffectiveTimeScale() {
					return this._effectiveTimeScale
				}
				setDuration(e) {
					return this.timeScale = this._clip.duration / e, this.stopWarping()
				}
				syncWith(e) {
					return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
				}
				halt(e) {
					return this.warp(this._effectiveTimeScale, 0, e)
				}
				warp(e, t, n) {
					const r = this._mixer,
						i = r.time,
						s = this.timeScale;
					let a = this._timeScaleInterpolant;
					null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
					const o = a.parameterPositions,
						l = a.sampleValues;
					return o[0] = i, o[1] = i + n, l[0] = e / s, l[1] = t / s, this
				}
				stopWarping() {
					const e = this._timeScaleInterpolant;
					return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
				}
				getMixer() {
					return this._mixer
				}
				getClip() {
					return this._clip
				}
				getRoot() {
					return this._localRoot || this._mixer._root
				}
				_update(e, t, n, r) {
					if (!this.enabled) return void this._updateWeight(e);
					const i = this._startTime;
					if (null !== i) {
						const r = (e - i) * n;
						if (r < 0 || 0 === n) return;
						this._startTime = null, t = n * r
					}
					t *= this._updateTimeScale(e);
					const s = this._updateTime(t),
						a = this._updateWeight(e);
					if (a > 0) {
						const e = this._interpolants,
							t = this._propertyBindings;
						switch (this.blendMode) {
							case jt:
								for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(s), t[n].accumulateAdditive(a);
								break;
							case Wt:
							default:
								for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(s), t[n].accumulate(r, a)
						}
					}
				}
				_updateWeight(e) {
					let t = 0;
					if (this.enabled) {
						t = this.weight;
						const n = this._weightInterpolant;
						if (null !== n) {
							const r = n.evaluate(e)[0];
							t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
						}
					}
					return this._effectiveWeight = t, t
				}
				_updateTimeScale(e) {
					let t = 0;
					if (!this.paused) {
						t = this.timeScale;
						const n = this._timeScaleInterpolant;
						if (null !== n) {
							t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
						}
					}
					return this._effectiveTimeScale = t, t
				}
				_updateTime(e) {
					const t = this._clip.duration,
						n = this.loop;
					let r = this.time + e,
						i = this._loopCount;
					const s = n === Nt;
					if (0 === e) return -1 === i ? r : s && 1 === (1 & i) ? t - r : r;
					if (n === Ft) {
						-1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
						e: {
							if (r >= t) r = t;
							else {
								if (!(r < 0)) {
									this.time = r;
									break e
								}
								r = 0
							}
							this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
							this.time = r,
							this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: e < 0 ? -1 : 1
							})
						}
					} else {
						if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) {
							const n = Math.floor(r / t);
							r -= t * n, i += Math.abs(n);
							const a = this.repetitions - i;
							if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: e > 0 ? 1 : -1
							});
							else {
								if (1 === a) {
									const t = e < 0;
									this._setEndings(t, !t, s)
								} else this._setEndings(!1, !1, s);
								this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
									type: "loop",
									action: this,
									loopDelta: n
								})
							}
						} else this.time = r;
						if (s && 1 === (1 & i)) return t - r
					}
					return r
				}
				_setEndings(e, t, n) {
					const r = this._interpolantSettings;
					n ? (r.endingStart = zt, r.endingEnd = zt) : (r.endingStart = e ? this.zeroSlopeAtStart ? zt : Ut : Vt, r.endingEnd = t ? this.zeroSlopeAtEnd ? zt : Ut : Vt)
				}
				_scheduleFading(e, t, n) {
					const r = this._mixer,
						i = r.time;
					let s = this._weightInterpolant;
					null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
					const a = s.parameterPositions,
						o = s.sampleValues;
					return a[0] = i, o[0] = t, a[1] = i + e, o[1] = n, this
				}
			}
			class $d extends Bn {
				constructor(e) {
					super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
				}
				_bindAction(e, t) {
					const n = e._localRoot || this._root,
						r = e._clip.tracks,
						i = r.length,
						s = e._propertyBindings,
						a = e._interpolants,
						o = n.uuid,
						l = this._bindingsByRootAndName;
					let c = l[o];
					void 0 === c && (c = {}, l[o] = c);
					for (let u = 0; u !== i; ++u) {
						const e = r[u],
							i = e.name;
						let l = c[i];
						if (void 0 !== l) s[u] = l;
						else {
							if (l = s[u], void 0 !== l) {
								null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, o, i));
								continue
							}
							const r = t && t._propertyBindings[u].binding.parsedPath;
							l = new kd(Yd.create(n, i, r), e.ValueTypeName, e.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, o, i), s[u] = l
						}
						a[u].resultBuffer = l.buffer
					}
				}
				_activateAction(e) {
					if (!this._isActiveAction(e)) {
						if (null === e._cacheIndex) {
							const t = (e._localRoot || this._root).uuid,
								n = e._clip.uuid,
								r = this._actionsByClip[n];
							this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
						}
						const t = e._propertyBindings;
						for (let e = 0, n = t.length; e !== n; ++e) {
							const n = t[e];
							0 === n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
						}
						this._lendAction(e)
					}
				}
				_deactivateAction(e) {
					if (this._isActiveAction(e)) {
						const t = e._propertyBindings;
						for (let e = 0, n = t.length; e !== n; ++e) {
							const n = t[e];
							0 === --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
						}
						this._takeBackAction(e)
					}
				}
				_initMemoryManager() {
					this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
					const e = this;
					this.stats = {
						actions: {
							get total() {
								return e._actions.length
							},
							get inUse() {
								return e._nActiveActions
							}
						},
						bindings: {
							get total() {
								return e._bindings.length
							},
							get inUse() {
								return e._nActiveBindings
							}
						},
						controlInterpolants: {
							get total() {
								return e._controlInterpolants.length
							},
							get inUse() {
								return e._nActiveControlInterpolants
							}
						}
					}
				}
				_isActiveAction(e) {
					const t = e._cacheIndex;
					return null !== t && t < this._nActiveActions
				}
				_addInactiveAction(e, t, n) {
					const r = this._actions,
						i = this._actionsByClip;
					let s = i[t];
					if (void 0 === s) s = {
						knownActions: [e],
						actionByRoot: {}
					}, e._byClipCacheIndex = 0, i[t] = s;
					else {
						const t = s.knownActions;
						e._byClipCacheIndex = t.length, t.push(e)
					}
					e._cacheIndex = r.length, r.push(e), s.actionByRoot[n] = e
				}
				_removeInactiveAction(e) {
					const t = this._actions,
						n = t[t.length - 1],
						r = e._cacheIndex;
					n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
					const i = e._clip.uuid,
						s = this._actionsByClip,
						a = s[i],
						o = a.knownActions,
						l = o[o.length - 1],
						c = e._byClipCacheIndex;
					l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null;
					delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete s[i], this._removeInactiveBindingsForAction(e)
				}
				_removeInactiveBindingsForAction(e) {
					const t = e._propertyBindings;
					for (let n = 0, r = t.length; n !== r; ++n) {
						const e = t[n];
						0 === --e.referenceCount && this._removeInactiveBinding(e)
					}
				}
				_lendAction(e) {
					const t = this._actions,
						n = e._cacheIndex,
						r = this._nActiveActions++,
						i = t[r];
					e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
				}
				_takeBackAction(e) {
					const t = this._actions,
						n = e._cacheIndex,
						r = --this._nActiveActions,
						i = t[r];
					e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
				}
				_addInactiveBinding(e, t, n) {
					const r = this._bindingsByRootAndName,
						i = this._bindings;
					let s = r[t];
					void 0 === s && (s = {}, r[t] = s), s[n] = e, e._cacheIndex = i.length, i.push(e)
				}
				_removeInactiveBinding(e) {
					const t = this._bindings,
						n = e.binding,
						r = n.rootNode.uuid,
						i = n.path,
						s = this._bindingsByRootAndName,
						a = s[r],
						o = t[t.length - 1],
						l = e._cacheIndex;
					o._cacheIndex = l, t[l] = o, t.pop(), delete a[i], 0 === Object.keys(a).length && delete s[r]
				}
				_lendBinding(e) {
					const t = this._bindings,
						n = e._cacheIndex,
						r = this._nActiveBindings++,
						i = t[r];
					e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
				}
				_takeBackBinding(e) {
					const t = this._bindings,
						n = e._cacheIndex,
						r = --this._nActiveBindings,
						i = t[r];
					e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
				}
				_lendControlInterpolant() {
					const e = this._controlInterpolants,
						t = this._nActiveControlInterpolants++;
					let n = e[t];
					return void 0 === n && (n = new yh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
				}
				_takeBackControlInterpolant(e) {
					const t = this._controlInterpolants,
						n = e.__cacheIndex,
						r = --this._nActiveControlInterpolants,
						i = t[r];
					e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
				}
				clipAction(e, t, n) {
					const r = t || this._root,
						i = r.uuid;
					let s = "string" === typeof e ? Ch.findByName(r, e) : e;
					const a = null !== s ? s.uuid : e,
						o = this._actionsByClip[a];
					let l = null;
					if (void 0 === n && (n = null !== s ? s.blendMode : Wt), void 0 !== o) {
						const e = o.actionByRoot[i];
						if (void 0 !== e && e.blendMode === n) return e;
						l = o.knownActions[0], null === s && (s = l._clip)
					}
					if (null === s) return null;
					const c = new Zd(this, s, t, n);
					return this._bindAction(c, l), this._addInactiveAction(c, a, i), c
				}
				existingAction(e, t) {
					const n = t || this._root,
						r = n.uuid,
						i = "string" === typeof e ? Ch.findByName(n, e) : e,
						s = i ? i.uuid : e,
						a = this._actionsByClip[s];
					return void 0 !== a && a.actionByRoot[r] || null
				}
				stopAllAction() {
					const e = this._actions;
					for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
					return this
				}
				update(e) {
					e *= this.timeScale;
					const t = this._actions,
						n = this._nActiveActions,
						r = this.time += e,
						i = Math.sign(e),
						s = this._accuIndex ^= 1;
					for (let l = 0; l !== n; ++l) {
						t[l]._update(r, e, i, s)
					}
					const a = this._bindings,
						o = this._nActiveBindings;
					for (let l = 0; l !== o; ++l) a[l].apply(s);
					return this
				}
				setTime(e) {
					this.time = 0;
					for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
					return this.update(e)
				}
				getRoot() {
					return this._root
				}
				uncacheClip(e) {
					const t = this._actions,
						n = e.uuid,
						r = this._actionsByClip,
						i = r[n];
					if (void 0 !== i) {
						const e = i.knownActions;
						for (let n = 0, r = e.length; n !== r; ++n) {
							const r = e[n];
							this._deactivateAction(r);
							const i = r._cacheIndex,
								s = t[t.length - 1];
							r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(r)
						}
						delete r[n]
					}
				}
				uncacheRoot(e) {
					const t = e.uuid,
						n = this._actionsByClip;
					for (const i in n) {
						const e = n[i].actionByRoot[t];
						void 0 !== e && (this._deactivateAction(e), this._removeInactiveAction(e))
					}
					const r = this._bindingsByRootAndName[t];
					if (void 0 !== r)
						for (const i in r) {
							const e = r[i];
							e.restoreOriginalState(), this._removeInactiveBinding(e)
						}
				}
				uncacheAction(e, t) {
					const n = this.existingAction(e, t);
					null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
				}
			}
			$d.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
			class ep {
				constructor(e) {
					"string" === typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
				}
				clone() {
					return new ep(void 0 === this.value.clone ? this.value : this.value.clone())
				}
			}
			class tp extends Rl {
				constructor(e, t, n = 1) {
					super(e, t), this.meshPerAttribute = n
				}
				copy(e) {
					return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
				}
				clone(e) {
					const t = super.clone(e);
					return t.meshPerAttribute = this.meshPerAttribute, t
				}
				toJSON(e) {
					const t = super.toJSON(e);
					return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
				}
			}
			tp.prototype.isInstancedInterleavedBuffer = !0;
			class np {
				constructor(e, t, n, r, i) {
					this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
				}
				set needsUpdate(e) {
					!0 === e && this.version++
				}
				setBuffer(e) {
					return this.buffer = e, this
				}
				setType(e, t) {
					return this.type = e, this.elementSize = t, this
				}
				setItemSize(e) {
					return this.itemSize = e, this
				}
				setCount(e) {
					return this.count = e, this
				}
			}
			np.prototype.isGLBufferAttribute = !0;
			class rp {
				constructor(e, t, n = 0, r = 1 / 0) {
					this.ray = new Dr(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Jr, this.params = {
						Mesh: {},
						Line: {
							threshold: 1
						},
						LOD: {},
						Points: {
							threshold: 1
						},
						Sprite: {}
					}
				}
				set(e, t) {
					this.ray.set(e, t)
				}
				setFromCamera(e, t) {
					t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
				}
				intersectObject(e, t = !0, n = []) {
					return sp(e, this, n, t), n.sort(ip), n
				}
				intersectObjects(e, t = !0, n = []) {
					for (let r = 0, i = e.length; r < i; r++) sp(e[r], this, n, t);
					return n.sort(ip), n
				}
			}

			function ip(e, t) {
				return e.distance - t.distance
			}

			function sp(e, t, n, r) {
				if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
					const r = e.children;
					for (let e = 0, i = r.length; e < i; e++) sp(r[e], t, n, !0)
				}
			}
			class ap {
				constructor(e = 1, t = 0, n = 0) {
					return this.radius = e, this.phi = t, this.theta = n, this
				}
				set(e, t, n) {
					return this.radius = e, this.phi = t, this.theta = n, this
				}
				copy(e) {
					return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
				}
				makeSafe() {
					const e = 1e-6;
					return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
				}
				setFromVector3(e) {
					return this.setFromCartesianCoords(e.x, e.y, e.z)
				}
				setFromCartesianCoords(e, t, n) {
					return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Fn(t / this.radius, -1, 1))), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			class op {
				constructor(e = 1, t = 0, n = 0) {
					return this.radius = e, this.theta = t, this.y = n, this
				}
				set(e, t, n) {
					return this.radius = e, this.theta = t, this.y = n, this
				}
				copy(e) {
					return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
				}
				setFromVector3(e) {
					return this.setFromCartesianCoords(e.x, e.y, e.z)
				}
				setFromCartesianCoords(e, t, n) {
					return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			const lp = new zn;
			class cp {
				constructor(e = new zn(1 / 0, 1 / 0), t = new zn(-1 / 0, -1 / 0)) {
					this.min = e, this.max = t
				}
				set(e, t) {
					return this.min.copy(e), this.max.copy(t), this
				}
				setFromPoints(e) {
					this.makeEmpty();
					for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
					return this
				}
				setFromCenterAndSize(e, t) {
					const n = lp.copy(t).multiplyScalar(.5);
					return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(e) {
					return this.min.copy(e.min), this.max.copy(e.max), this
				}
				makeEmpty() {
					return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y
				}
				getCenter(e) {
					return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
				}
				getSize(e) {
					return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
				}
				expandByPoint(e) {
					return this.min.min(e), this.max.max(e), this
				}
				expandByVector(e) {
					return this.min.sub(e), this.max.add(e), this
				}
				expandByScalar(e) {
					return this.min.addScalar(-e), this.max.addScalar(e), this
				}
				containsPoint(e) {
					return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
				}
				containsBox(e) {
					return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
				}
				getParameter(e, t) {
					return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
				}
				intersectsBox(e) {
					return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
				}
				clampPoint(e, t) {
					return t.copy(e).clamp(this.min, this.max)
				}
				distanceToPoint(e) {
					return lp.copy(e).clamp(this.min, this.max).sub(e).length()
				}
				intersect(e) {
					return this.min.max(e.min), this.max.min(e.max), this
				}
				union(e) {
					return this.min.min(e.min), this.max.max(e.max), this
				}
				translate(e) {
					return this.min.add(e), this.max.add(e), this
				}
				equals(e) {
					return e.min.equals(this.min) && e.max.equals(this.max)
				}
			}
			cp.prototype.isBox2 = !0;
			const up = new ir,
				hp = new ir;
			class dp {
				constructor(e = new ir, t = new ir) {
					this.start = e, this.end = t
				}
				set(e, t) {
					return this.start.copy(e), this.end.copy(t), this
				}
				copy(e) {
					return this.start.copy(e.start), this.end.copy(e.end), this
				}
				getCenter(e) {
					return e.addVectors(this.start, this.end).multiplyScalar(.5)
				}
				delta(e) {
					return e.subVectors(this.end, this.start)
				}
				distanceSq() {
					return this.start.distanceToSquared(this.end)
				}
				distance() {
					return this.start.distanceTo(this.end)
				}
				at(e, t) {
					return this.delta(t).multiplyScalar(e).add(this.start)
				}
				closestPointToPointParameter(e, t) {
					up.subVectors(e, this.start), hp.subVectors(this.end, this.start);
					const n = hp.dot(hp);
					let r = hp.dot(up) / n;
					return t && (r = Fn(r, 0, 1)), r
				}
				closestPointToPoint(e, t, n) {
					const r = this.closestPointToPointParameter(e, t);
					return this.delta(n).multiplyScalar(r).add(this.start)
				}
				applyMatrix4(e) {
					return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
				}
				equals(e) {
					return e.start.equals(this.start) && e.end.equals(this.end)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			const pp = new ir;
			class fp extends ai {
				constructor(e, t) {
					super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
					const n = new qi,
						r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
					for (let s = 0, a = 1, o = 32; s < o; s++, a++) {
						const e = s / o * Math.PI * 2,
							t = a / o * Math.PI * 2;
						r.push(Math.cos(e), Math.sin(e), 1, Math.cos(t), Math.sin(t), 1)
					}
					n.setAttribute("position", new ki(r, 3));
					const i = new mc({
						fog: !1,
						toneMapped: !1
					});
					this.cone = new Ac(n, i), this.add(this.cone), this.update()
				}
				dispose() {
					this.cone.geometry.dispose(), this.cone.material.dispose()
				}
				update() {
					this.light.updateMatrixWorld();
					const e = this.light.distance ? this.light.distance : 1e3,
						t = e * Math.tan(this.light.angle);
					this.cone.scale.set(t, t, e), pp.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(pp), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
				}
			}
			const mp = new ir,
				gp = new Fr,
				vp = new Fr;
			class yp extends Ac {
				constructor(e) {
					const t = xp(e),
						n = new qi,
						r = [],
						i = [],
						s = new Ei(0, 0, 1),
						a = new Ei(0, 1, 0);
					for (let o = 0; o < t.length; o++) {
						const e = t[o];
						e.parent && e.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(a.r, a.g, a.b))
					}
					n.setAttribute("position", new ki(r, 3)), n.setAttribute("color", new ki(i, 3));
					super(n, new mc({
						vertexColors: !0,
						depthTest: !1,
						depthWrite: !1,
						toneMapped: !1,
						transparent: !0
					})), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
				}
				updateMatrixWorld(e) {
					const t = this.bones,
						n = this.geometry,
						r = n.getAttribute("position");
					vp.copy(this.root.matrixWorld).invert();
					for (let i = 0, s = 0; i < t.length; i++) {
						const e = t[i];
						e.parent && e.parent.isBone && (gp.multiplyMatrices(vp, e.matrixWorld), mp.setFromMatrixPosition(gp), r.setXYZ(s, mp.x, mp.y, mp.z), gp.multiplyMatrices(vp, e.parent.matrixWorld), mp.setFromMatrixPosition(gp), r.setXYZ(s + 1, mp.x, mp.y, mp.z), s += 2)
					}
					n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
				}
			}

			function xp(e) {
				const t = [];
				e && e.isBone && t.push(e);
				for (let n = 0; n < e.children.length; n++) t.push.apply(t, xp(e.children[n]));
				return t
			}
			class _p extends ds {
				constructor(e, t, n) {
					super(new Qu(t, 4, 2), new Ti({
						wireframe: !0,
						fog: !1,
						toneMapped: !1
					})), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
				}
				dispose() {
					this.geometry.dispose(), this.material.dispose()
				}
				update() {
					void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
				}
			}
			const bp = new ir,
				wp = new Ei,
				Mp = new Ei;
			class Ap extends ai {
				constructor(e, t, n) {
					super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
					const r = new qu(t);
					r.rotateY(.5 * Math.PI), this.material = new Ti({
						wireframe: !0,
						fog: !1,
						toneMapped: !1
					}), void 0 === this.color && (this.material.vertexColors = !0);
					const i = r.getAttribute("position"),
						s = new Float32Array(3 * i.count);
					r.setAttribute("color", new Ri(s, 3)), this.add(new ds(r, this.material)), this.update()
				}
				dispose() {
					this.children[0].geometry.dispose(), this.children[0].material.dispose()
				}
				update() {
					const e = this.children[0];
					if (void 0 !== this.color) this.material.color.set(this.color);
					else {
						const t = e.geometry.getAttribute("color");
						wp.copy(this.light.color), Mp.copy(this.light.groundColor);
						for (let e = 0, n = t.count; e < n; e++) {
							const r = e < n / 2 ? wp : Mp;
							t.setXYZ(e, r.r, r.g, r.b)
						}
						t.needsUpdate = !0
					}
					e.lookAt(bp.setFromMatrixPosition(this.light.matrixWorld).negate())
				}
			}
			class Sp extends Ac {
				constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
					n = new Ei(n), r = new Ei(r);
					const i = t / 2,
						s = e / t,
						a = e / 2,
						o = [],
						l = [];
					for (let u = 0, h = 0, d = -a; u <= t; u++, d += s) {
						o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a);
						const e = u === i ? n : r;
						e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3
					}
					const c = new qi;
					c.setAttribute("position", new ki(o, 3)), c.setAttribute("color", new ki(l, 3));
					super(c, new mc({
						vertexColors: !0,
						toneMapped: !1
					})), this.type = "GridHelper"
				}
			}
			class Ep extends Ac {
				constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
					i = new Ei(i), s = new Ei(s);
					const a = [],
						o = [];
					for (let c = 0; c <= t; c++) {
						const n = c / t * (2 * Math.PI),
							r = Math.sin(n) * e,
							l = Math.cos(n) * e;
						a.push(0, 0, 0), a.push(r, 0, l);
						const u = 1 & c ? i : s;
						o.push(u.r, u.g, u.b), o.push(u.r, u.g, u.b)
					}
					for (let c = 0; c <= n; c++) {
						const t = 1 & c ? i : s,
							l = e - e / n * c;
						for (let e = 0; e < r; e++) {
							let n = e / r * (2 * Math.PI),
								i = Math.sin(n) * l,
								s = Math.cos(n) * l;
							a.push(i, 0, s), o.push(t.r, t.g, t.b), n = (e + 1) / r * (2 * Math.PI), i = Math.sin(n) * l, s = Math.cos(n) * l, a.push(i, 0, s), o.push(t.r, t.g, t.b)
						}
					}
					const l = new qi;
					l.setAttribute("position", new ki(a, 3)), l.setAttribute("color", new ki(o, 3));
					super(l, new mc({
						vertexColors: !0,
						toneMapped: !1
					})), this.type = "PolarGridHelper"
				}
			}
			const Tp = new ir,
				Cp = new ir,
				Bp = new ir;
			class Rp extends ai {
				constructor(e, t, n) {
					super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
					let r = new qi;
					r.setAttribute("position", new ki([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
					const i = new mc({
						fog: !1,
						toneMapped: !1
					});
					this.lightPlane = new bc(r, i), this.add(this.lightPlane), r = new qi, r.setAttribute("position", new ki([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new bc(r, i), this.add(this.targetLine), this.update()
				}
				dispose() {
					this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
				}
				update() {
					Tp.setFromMatrixPosition(this.light.matrixWorld), Cp.setFromMatrixPosition(this.light.target.matrixWorld), Bp.subVectors(Cp, Tp), this.lightPlane.lookAt(Cp), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Cp), this.targetLine.scale.z = Bp.length()
				}
			}
			const Lp = new ir,
				Ip = new xs;
			class Pp extends Ac {
				constructor(e) {
					const t = new qi,
						n = new mc({
							color: 16777215,
							vertexColors: !0,
							toneMapped: !1
						}),
						r = [],
						i = [],
						s = {},
						a = new Ei(16755200),
						o = new Ei(16711680),
						l = new Ei(43775),
						c = new Ei(16777215),
						u = new Ei(3355443);

					function h(e, t, n) {
						d(e, n), d(t, n)
					}

					function d(e, t) {
						r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1)
					}
					h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", o), h("p", "n2", o), h("p", "n3", o), h("p", "n4", o), h("u1", "u2", l), h("u2", "u3", l), h("u3", "u1", l), h("c", "t", c), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), t.setAttribute("position", new ki(r, 3)), t.setAttribute("color", new ki(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
				}
				update() {
					const e = this.geometry,
						t = this.pointMap;
					Ip.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Dp("c", t, e, Ip, 0, 0, -1), Dp("t", t, e, Ip, 0, 0, 1), Dp("n1", t, e, Ip, -1, -1, -1), Dp("n2", t, e, Ip, 1, -1, -1), Dp("n3", t, e, Ip, -1, 1, -1), Dp("n4", t, e, Ip, 1, 1, -1), Dp("f1", t, e, Ip, -1, -1, 1), Dp("f2", t, e, Ip, 1, -1, 1), Dp("f3", t, e, Ip, -1, 1, 1), Dp("f4", t, e, Ip, 1, 1, 1), Dp("u1", t, e, Ip, .7, 1.1, -1), Dp("u2", t, e, Ip, -.7, 1.1, -1), Dp("u3", t, e, Ip, 0, 2, -1), Dp("cf1", t, e, Ip, -1, 0, 1), Dp("cf2", t, e, Ip, 1, 0, 1), Dp("cf3", t, e, Ip, 0, -1, 1), Dp("cf4", t, e, Ip, 0, 1, 1), Dp("cn1", t, e, Ip, -1, 0, -1), Dp("cn2", t, e, Ip, 1, 0, -1), Dp("cn3", t, e, Ip, 0, -1, -1), Dp("cn4", t, e, Ip, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
				}
				dispose() {
					this.geometry.dispose(), this.material.dispose()
				}
			}

			function Dp(e, t, n, r, i, s, a) {
				Lp.set(i, s, a).unproject(r);
				const o = t[e];
				if (void 0 !== o) {
					const e = n.getAttribute("position");
					for (let t = 0, n = o.length; t < n; t++) e.setXYZ(o[t], Lp.x, Lp.y, Lp.z)
				}
			}
			const Fp = new or;
			class Op extends Ac {
				constructor(e, t = 16776960) {
					const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						r = new Float32Array(24),
						i = new qi;
					i.setIndex(new Ri(n, 1)), i.setAttribute("position", new Ri(r, 3)), super(i, new mc({
						color: t,
						toneMapped: !1
					})), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
				}
				update(e) {
					if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Fp.setFromObject(this.object), Fp.isEmpty()) return;
					const t = Fp.min,
						n = Fp.max,
						r = this.geometry.attributes.position,
						i = r.array;
					i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
				}
				setFromObject(e) {
					return this.object = e, this.update(), this
				}
				copy(e) {
					return Ac.prototype.copy.call(this, e), this.object = e.object, this
				}
			}
			class Np extends Ac {
				constructor(e, t = 16776960) {
					const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						r = new qi;
					r.setIndex(new Ri(n, 1)), r.setAttribute("position", new ki([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new mc({
						color: t,
						toneMapped: !1
					})), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
				}
				updateMatrixWorld(e) {
					const t = this.box;
					t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
				}
			}
			class Hp extends bc {
				constructor(e, t = 1, n = 16776960) {
					const r = n,
						i = new qi;
					i.setAttribute("position", new ki([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new mc({
						color: r,
						toneMapped: !1
					})), this.type = "PlaneHelper", this.plane = e, this.size = t;
					const s = new qi;
					s.setAttribute("position", new ki([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new ds(s, new Ti({
						color: r,
						opacity: .2,
						transparent: !0,
						depthWrite: !1,
						toneMapped: !1
					})))
				}
				updateMatrixWorld(e) {
					let t = -this.plane.constant;
					Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? m : f, this.lookAt(this.plane.normal), super.updateMatrixWorld(e)
				}
			}
			const kp = new ir;
			let Gp, Up;
			class zp extends ai {
				constructor(e = new ir(0, 0, 1), t = new ir(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) {
					super(), this.type = "ArrowHelper", void 0 === Gp && (Gp = new qi, Gp.setAttribute("position", new ki([0, 0, 0, 0, 1, 0], 3)), Up = new Hc(0, .5, 1, 5, 1), Up.translate(0, -.5, 0)), this.position.copy(t), this.line = new bc(Gp, new mc({
						color: r,
						toneMapped: !1
					})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ds(Up, new Ti({
						color: r,
						toneMapped: !1
					})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s)
				}
				setDirection(e) {
					if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
					else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
					else {
						kp.set(e.z, 0, -e.x).normalize();
						const t = Math.acos(e.y);
						this.quaternion.setFromAxisAngle(kp, t)
					}
				}
				setLength(e, t = .2 * e, n = .2 * t) {
					this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
				}
				setColor(e) {
					this.line.material.color.set(e), this.cone.material.color.set(e)
				}
				copy(e) {
					return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
				}
			}
			class Vp extends Ac {
				constructor(e = 1) {
					const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
						n = new qi;
					n.setAttribute("position", new ki(t, 3)), n.setAttribute("color", new ki([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
					super(n, new mc({
						vertexColors: !0,
						toneMapped: !1
					})), this.type = "AxesHelper"
				}
				setColors(e, t, n) {
					const r = new Ei,
						i = this.geometry.attributes.color.array;
					return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
				}
				dispose() {
					this.geometry.dispose(), this.material.dispose()
				}
			}
			class Wp {
				constructor() {
					this.type = "ShapePath", this.color = new Ei, this.subPaths = [], this.currentPath = null
				}
				moveTo(e, t) {
					return this.currentPath = new fu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
				}
				lineTo(e, t) {
					return this.currentPath.lineTo(e, t), this
				}
				quadraticCurveTo(e, t, n, r) {
					return this.currentPath.quadraticCurveTo(e, t, n, r), this
				}
				bezierCurveTo(e, t, n, r, i, s) {
					return this.currentPath.bezierCurveTo(e, t, n, r, i, s), this
				}
				splineThru(e) {
					return this.currentPath.splineThru(e), this
				}
				toShapes(e, t) {
					function n(e) {
						const t = [];
						for (let n = 0, r = e.length; n < r; n++) {
							const r = e[n],
								i = new mu;
							i.curves = r.curves, t.push(i)
						}
						return t
					}

					function r(e, t) {
						const n = t.length;
						let r = !1;
						for (let i = n - 1, s = 0; s < n; i = s++) {
							let n = t[i],
								a = t[s],
								o = a.x - n.x,
								l = a.y - n.y;
							if (Math.abs(l) > Number.EPSILON) {
								if (l < 0 && (n = t[s], o = -o, a = t[i], l = -l), e.y < n.y || e.y > a.y) continue;
								if (e.y === n.y) {
									if (e.x === n.x) return !0
								} else {
									const t = l * (e.x - n.x) - o * (e.y - n.y);
									if (0 === t) return !0;
									if (t < 0) continue;
									r = !r
								}
							} else {
								if (e.y !== n.y) continue;
								if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x) return !0
							}
						}
						return r
					}
					const i = Uu.isClockWise,
						s = this.subPaths;
					if (0 === s.length) return [];
					if (!0 === t) return n(s);
					let a, o, l;
					const c = [];
					if (1 === s.length) return o = s[0], l = new mu, l.curves = o.curves, c.push(l), c;
					let u = !i(s[0].getPoints());
					u = e ? !u : u;
					const h = [],
						d = [];
					let p, f, m = [],
						g = 0;
					d[g] = void 0, m[g] = [];
					for (let v = 0, y = s.length; v < y; v++) o = s[v], p = o.getPoints(), a = i(p), a = e ? !a : a, a ? (!u && d[g] && g++, d[g] = {
						s: new mu,
						p: p
					}, d[g].s.curves = o.curves, u && g++, m[g] = []) : m[g].push({
						h: o,
						p: p[0]
					});
					if (!d[0]) return n(s);
					if (d.length > 1) {
						let e = !1;
						const t = [];
						for (let n = 0, r = d.length; n < r; n++) h[n] = [];
						for (let n = 0, i = d.length; n < i; n++) {
							const i = m[n];
							for (let s = 0; s < i.length; s++) {
								const a = i[s];
								let o = !0;
								for (let i = 0; i < d.length; i++) r(a.p, d[i].p) && (n !== i && t.push({
									froms: n,
									tos: i,
									hole: s
								}), o ? (o = !1, h[i].push(a)) : e = !0);
								o && h[n].push(a)
							}
						}
						t.length > 0 && (e || (m = h))
					}
					for (let v = 0, y = d.length; v < y; v++) {
						l = d[v].s, c.push(l), f = m[v];
						for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h)
					}
					return c
				}
			}
			const jp = new Float32Array(1),
				Jp = new Int32Array(jp.buffer);
			class Xp {
				static toHalfFloat(e) {
					e > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), e = 65504), jp[0] = e;
					const t = Jp[0];
					let n = t >> 16 & 32768,
						r = t >> 12 & 2047;
					const i = t >> 23 & 255;
					return i < 103 ? n : i > 142 ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & t, n) : i < 113 ? (r |= 2048, n |= (r >> 114 - i) + (r >> 113 - i & 1), n) : (n |= i - 112 << 10 | r >> 1, n += 1 & r, n)
				}
			}
			const qp = 0,
				Kp = 1,
				Yp = 0,
				Qp = 1,
				Zp = 2;

			function $p(e) {
				return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
			}

			function ef(e = []) {
				return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
					return e.slice()
				}, e
			}

			function tf(e, t) {
				return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Lc(e, t)
			}

			function nf(e) {
				return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Xl(e)
			}

			function rf(e, t) {
				return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Lc(e, t)
			}

			function sf(e) {
				return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ec(e)
			}

			function af(e) {
				return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ec(e)
			}

			function of (e) {
				return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ec(e)
			}

			function lf(e, t, n) {
				return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new ir(e, t, n)
			}

			function cf(e, t) {
				return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Ri(e, t).setUsage(xn)
			}

			function uf(e, t) {
				return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Li(e, t)
			}

			function hf(e, t) {
				return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ii(e, t)
			}

			function df(e, t) {
				return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Pi(e, t)
			}

			function pf(e, t) {
				return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Di(e, t)
			}

			function ff(e, t) {
				return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Fi(e, t)
			}

			function mf(e, t) {
				return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Oi(e, t)
			}

			function gf(e, t) {
				return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ni(e, t)
			}

			function vf(e, t) {
				return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new ki(e, t)
			}

			function yf(e, t) {
				return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Gi(e, t)
			}

			function xf(e) {
				return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Vp(e)
			}

			function _f(e, t) {
				return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Op(e, t)
			}

			function bf(e, t) {
				return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ac(new Jc(e.geometry), new mc({
					color: void 0 !== t ? t : 16777215
				}))
			}

			function wf(e, t) {
				return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ac(new nh(e.geometry), new mc({
					color: void 0 !== t ? t : 16777215
				}))
			}

			function Mf(e) {
				return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fh(e)
			}

			function Af(e) {
				return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Gh(e)
			}

			function Sf(e, t, n) {
				return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new As(e, n)
			}

			function Ef() {
				console.error("THREE.CanvasRenderer has been removed")
			}

			function Tf() {
				console.error("THREE.JSONLoader has been removed.")
			}
			Xc.create = function(e, t) {
				return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Xc.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
			}, fu.prototype.fromPoints = function(e) {
				return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
			}, Sp.prototype.setColors = function() {
				console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
			}, yp.prototype.update = function() {
				console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
			}, Ph.prototype.extractUrlBase = function(e) {
				return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ld.extractUrlBase(e)
			}, Ph.Handlers = {
				add: function() {
					console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
				},
				get: function() {
					console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
				}
			}, cp.prototype.center = function(e) {
				return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
			}, cp.prototype.empty = function() {
				return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, cp.prototype.isIntersectionBox = function(e) {
				return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
			}, cp.prototype.size = function(e) {
				return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
			}, or.prototype.center = function(e) {
				return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
			}, or.prototype.empty = function() {
				return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, or.prototype.isIntersectionBox = function(e) {
				return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
			}, or.prototype.isIntersectionSphere = function(e) {
				return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
			}, or.prototype.size = function(e) {
				return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
			}, Er.prototype.empty = function() {
				return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, Ls.prototype.setFromMatrix = function(e) {
				return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
			}, dp.prototype.center = function(e) {
				return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
			}, Vn.prototype.flattenToArrayOffset = function(e, t) {
				return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
			}, Vn.prototype.multiplyVector3 = function(e) {
				return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
			}, Vn.prototype.multiplyVector3Array = function() {
				console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
			}, Vn.prototype.applyToBufferAttribute = function(e) {
				return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
			}, Vn.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
			}, Vn.prototype.getInverse = function(e) {
				return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
			}, Fr.prototype.extractPosition = function(e) {
				return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
			}, Fr.prototype.flattenToArrayOffset = function(e, t) {
				return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
			}, Fr.prototype.getPosition = function() {
				return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ir).setFromMatrixColumn(this, 3)
			}, Fr.prototype.setRotationFromQuaternion = function(e) {
				return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
			}, Fr.prototype.multiplyToArray = function() {
				console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
			}, Fr.prototype.multiplyVector3 = function(e) {
				return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
			}, Fr.prototype.multiplyVector4 = function(e) {
				return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
			}, Fr.prototype.multiplyVector3Array = function() {
				console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
			}, Fr.prototype.rotateAxis = function(e) {
				console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
			}, Fr.prototype.crossVector = function(e) {
				return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
			}, Fr.prototype.translate = function() {
				console.error("THREE.Matrix4: .translate() has been removed.")
			}, Fr.prototype.rotateX = function() {
				console.error("THREE.Matrix4: .rotateX() has been removed.")
			}, Fr.prototype.rotateY = function() {
				console.error("THREE.Matrix4: .rotateY() has been removed.")
			}, Fr.prototype.rotateZ = function() {
				console.error("THREE.Matrix4: .rotateZ() has been removed.")
			}, Fr.prototype.rotateByAxis = function() {
				console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
			}, Fr.prototype.applyToBufferAttribute = function(e) {
				return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
			}, Fr.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
			}, Fr.prototype.makeFrustum = function(e, t, n, r, i, s) {
				return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, s)
			}, Fr.prototype.getInverse = function(e) {
				return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
			}, Cs.prototype.isIntersectionLine = function(e) {
				return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
			}, rr.prototype.multiplyVector3 = function(e) {
				return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
			}, rr.prototype.inverse = function() {
				return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
			}, Dr.prototype.isIntersectionBox = function(e) {
				return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
			}, Dr.prototype.isIntersectionPlane = function(e) {
				return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
			}, Dr.prototype.isIntersectionSphere = function(e) {
				return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
			}, vi.prototype.area = function() {
				return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
			}, vi.prototype.barycoordFromPoint = function(e, t) {
				return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
			}, vi.prototype.midpoint = function(e) {
				return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
			}, vi.prototypenormal = function(e) {
				return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
			}, vi.prototype.plane = function(e) {
				return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
			}, vi.barycoordFromPoint = function(e, t, n, r, i) {
				return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), vi.getBarycoord(e, t, n, r, i)
			}, vi.normal = function(e, t, n, r) {
				return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), vi.getNormal(e, t, n, r)
			}, mu.prototype.extractAllPoints = function(e) {
				return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
			}, mu.prototype.extrude = function(e) {
				return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Wu(this, e)
			}, mu.prototype.makeGeometry = function(e) {
				return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Yu(this, e)
			}, zn.prototype.fromAttribute = function(e, t, n) {
				return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
			}, zn.prototype.distanceToManhattan = function(e) {
				return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
			}, zn.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, ir.prototype.setEulerFromRotationMatrix = function() {
				console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
			}, ir.prototype.setEulerFromQuaternion = function() {
				console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
			}, ir.prototype.getPositionFromMatrix = function(e) {
				return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
			}, ir.prototype.getScaleFromMatrix = function(e) {
				return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
			}, ir.prototype.getColumnFromMatrix = function(e, t) {
				return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
			}, ir.prototype.applyProjection = function(e) {
				return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
			}, ir.prototype.fromAttribute = function(e, t, n) {
				return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
			}, ir.prototype.distanceToManhattan = function(e) {
				return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
			}, ir.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, $n.prototype.fromAttribute = function(e, t, n) {
				return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
			}, $n.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, ai.prototype.getChildByName = function(e) {
				return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
			}, ai.prototype.renderDepth = function() {
				console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
			}, ai.prototype.translate = function(e, t) {
				return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
			}, ai.prototype.getWorldRotation = function() {
				console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
			}, ai.prototype.applyMatrix = function(e) {
				return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
			}, Object.defineProperties(ai.prototype, {
				eulerOrder: {
					get: function() {
						return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
					},
					set: function(e) {
						console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
					}
				},
				useQuaternion: {
					get: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					},
					set: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					}
				}
			}), ds.prototype.setDrawMode = function() {
				console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
			}, Object.defineProperties(ds.prototype, {
				drawMode: {
					get: function() {
						return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Jt
					},
					set: function() {
						console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
					}
				}
			}), rc.prototype.initBones = function() {
				console.error("THREE.SkinnedMesh: initBones() has been removed.")
			}, _s.prototype.setLens = function(e, t) {
				console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
			}, Object.defineProperties(zh.prototype, {
				onlyShadow: {
					set: function() {
						console.warn("THREE.Light: .onlyShadow has been removed.")
					}
				},
				shadowCameraFov: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
					}
				},
				shadowCameraLeft: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
					}
				},
				shadowCameraRight: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
					}
				},
				shadowCameraTop: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
					}
				},
				shadowCameraBottom: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
					}
				},
				shadowCameraNear: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
					}
				},
				shadowCameraFar: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
					}
				},
				shadowCameraVisible: {
					set: function() {
						console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
					}
				},
				shadowBias: {
					set: function(e) {
						console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
					}
				},
				shadowDarkness: {
					set: function() {
						console.warn("THREE.Light: .shadowDarkness has been removed.")
					}
				},
				shadowMapWidth: {
					set: function(e) {
						console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
					}
				},
				shadowMapHeight: {
					set: function(e) {
						console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
					}
				}
			}), Object.defineProperties(Ri.prototype, {
				length: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
					}
				},
				dynamic: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === xn
					},
					set: function() {
						console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(xn)
					}
				}
			}), Ri.prototype.setDynamic = function(e) {
				return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? xn : yn), this
			}, Ri.prototype.copyIndicesArray = function() {
				console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
			}, Ri.prototype.setArray = function() {
				console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
			}, qi.prototype.addIndex = function(e) {
				console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
			}, qi.prototype.addAttribute = function(e, t) {
				return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Ri(arguments[1], arguments[2])))
			}, qi.prototype.addDrawCall = function(e, t, n) {
				void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
			}, qi.prototype.clearDrawCalls = function() {
				console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
			}, qi.prototype.computeOffsets = function() {
				console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
			}, qi.prototype.removeAttribute = function(e) {
				return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
			}, qi.prototype.applyMatrix = function(e) {
				return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
			}, Object.defineProperties(qi.prototype, {
				drawcalls: {
					get: function() {
						return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
					}
				},
				offsets: {
					get: function() {
						return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
					}
				}
			}), Rl.prototype.setDynamic = function(e) {
				return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? xn : yn), this
			}, Rl.prototype.setArray = function() {
				console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
			}, Wu.prototype.getArrays = function() {
				console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
			}, Wu.prototype.addShapeList = function() {
				console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
			}, Wu.prototype.addShape = function() {
				console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
			}, Bl.prototype.dispose = function() {
				console.error("THREE.Scene: .dispose() has been removed.")
			}, ep.prototype.onUpdate = function() {
				return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
			}, Object.defineProperties(xi.prototype, {
				wrapAround: {
					get: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					}
				},
				overdraw: {
					get: function() {
						console.warn("THREE.Material: .overdraw has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .overdraw has been removed.")
					}
				},
				wrapRGB: {
					get: function() {
						return console.warn("THREE.Material: .wrapRGB has been removed."), new Ei
					}
				},
				shading: {
					get: function() {
						console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
					},
					set: function(e) {
						console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === v
					}
				},
				stencilMask: {
					get: function() {
						return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
					},
					set: function(e) {
						console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
					}
				},
				vertexTangents: {
					get: function() {
						console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
					},
					set: function() {
						console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
					}
				}
			}), Object.defineProperties(ys.prototype, {
				derivatives: {
					get: function() {
						return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
					},
					set: function(e) {
						console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
					}
				}
			}), Sl.prototype.clearTarget = function(e, t, n, r) {
				console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
			}, Sl.prototype.animate = function(e) {
				console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
			}, Sl.prototype.getCurrentRenderTarget = function() {
				return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
			}, Sl.prototype.getMaxAnisotropy = function() {
				return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
			}, Sl.prototype.getPrecision = function() {
				return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
			}, Sl.prototype.resetGLState = function() {
				return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
			}, Sl.prototype.supportsFloatTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
			}, Sl.prototype.supportsHalfFloatTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
			}, Sl.prototype.supportsStandardDerivatives = function() {
				return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
			}, Sl.prototype.supportsCompressedTextureS3TC = function() {
				return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
			}, Sl.prototype.supportsCompressedTexturePVRTC = function() {
				return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
			}, Sl.prototype.supportsBlendMinMax = function() {
				return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
			}, Sl.prototype.supportsVertexTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
			}, Sl.prototype.supportsInstancedArrays = function() {
				return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
			}, Sl.prototype.enableScissorTest = function(e) {
				console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
			}, Sl.prototype.initMaterial = function() {
				console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
			}, Sl.prototype.addPrePlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
			}, Sl.prototype.addPostPlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
			}, Sl.prototype.updateShadowMap = function() {
				console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
			}, Sl.prototype.setFaceCulling = function() {
				console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
			}, Sl.prototype.allocTextureUnit = function() {
				console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
			}, Sl.prototype.setTexture = function() {
				console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
			}, Sl.prototype.setTexture2D = function() {
				console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
			}, Sl.prototype.setTextureCube = function() {
				console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
			}, Sl.prototype.getActiveMipMapLevel = function() {
				return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
			}, Object.defineProperties(Sl.prototype, {
				shadowMapEnabled: {
					get: function() {
						return this.shadowMap.enabled
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
					}
				},
				shadowMapType: {
					get: function() {
						return this.shadowMap.type
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
					}
				},
				shadowMapCullFace: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
					}
				},
				context: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
					}
				},
				vr: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
					}
				},
				gammaInput: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
					}
				},
				gammaOutput: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Yt : Kt
					}
				},
				toneMappingWhitePoint: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
					}
				},
				gammaFactor: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
					}
				}
			}), Object.defineProperties(fl.prototype, {
				cullFace: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
					}
				},
				renderReverseSided: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
					}
				},
				renderSingleSided: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
					}
				}
			}), Object.defineProperties(er.prototype, {
				wrapS: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
					}
				},
				wrapT: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
					}
				},
				magFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
					}
				},
				minFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
					}
				},
				anisotropy: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
					}
				},
				offset: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
					}
				},
				repeat: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
					}
				},
				format: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
					}
				},
				type: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
					}
				},
				generateMipmaps: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
					}
				}
			}), Id.prototype.load = function(e) {
				console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
				const t = this;
				return (new yd).load(e, (function(e) {
					t.setBuffer(e)
				})), this
			}, Hd.prototype.getData = function() {
				return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
			}, ws.prototype.updateCubeMap = function(e, t) {
				return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
			}, ws.prototype.clear = function(e, t, n, r) {
				return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, r)
			}, Kn.crossOrigin = void 0, Kn.loadTexture = function(e, t, n, r) {
				console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
				const i = new Uh;
				i.setCrossOrigin(this.crossOrigin);
				const s = i.load(e, n, void 0, r);
				return t && (s.mapping = t), s
			}, Kn.loadTextureCube = function(e, t, n, r) {
				console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
				const i = new kh;
				i.setCrossOrigin(this.crossOrigin);
				const s = i.load(e, n, void 0, r);
				return t && (s.mapping = t), s
			}, Kn.loadCompressedTexture = function() {
				console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
			}, Kn.loadCompressedTextureCube = function() {
				console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
			};
			const Cf = {
				createMultiMaterialObject: function() {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				},
				detach: function() {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				},
				attach: function() {
					console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
				}
			};

			function Bf() {
				console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
			}

			function Rf() {
				return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new qi
			}

			function Lf() {
				return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new qi
			}

			function If() {
				console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
			}

			function Pf() {
				console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
			}

			function Df() {
				console.error("THREE.ImmediateRenderObject has been removed.")
			}
			"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
				detail: {
					revision: r
				}
			})), "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
		},
		655: function(e, t, n) {
			"use strict";
			n.d(t, {
				ZT: function() {
					return i
				},
				pi: function() {
					return s
				},
				_T: function() {
					return a
				},
				XA: function() {
					return o
				},
				CR: function() {
					return l
				},
				fl: function() {
					return c
				}
			});
			var r = function(e, t) {
				return (r = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(e, t) {
						e.__proto__ = t
					} || function(e, t) {
						for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
					})(e, t)
			};

			function i(e, t) {
				function n() {
					this.constructor = e
				}
				r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
			}
			var s = function() {
				return (s = Object.assign || function(e) {
					for (var t, n = 1, r = arguments.length; n < r; n++)
						for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
					return e
				}).apply(this, arguments)
			};

			function a(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
					var i = 0;
					for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
				}
				return n
			}

			function o(e) {
				var t = "function" === typeof Symbol && Symbol.iterator,
					n = t && e[t],
					r = 0;
				if (n) return n.call(e);
				if (e && "number" === typeof e.length) return {
					next: function() {
						return e && r >= e.length && (e = void 0), {
							value: e && e[r++],
							done: !e
						}
					}
				};
				throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
			}

			function l(e, t) {
				var n = "function" === typeof Symbol && e[Symbol.iterator];
				if (!n) return e;
				var r, i, s = n.call(e),
					a = [];
				try {
					for (;
						(void 0 === t || t-- > 0) && !(r = s.next()).done;) a.push(r.value)
				} catch (o) {
					i = {
						error: o
					}
				} finally {
					try {
						r && !r.done && (n = s.return) && n.call(s)
					} finally {
						if (i) throw i.error
					}
				}
				return a
			}

			function c() {
				for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(l(arguments[t]));
				return e
			}
		},
		7462: function(e, t, n) {
			"use strict";

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			n.d(t, {
				Z: function() {
					return r
				}
			})
		},
		5068: function(e, t, n) {
			"use strict";

			function r(e, t) {
				return (r = Object.setPrototypeOf || function(e, t) {
					return e.__proto__ = t, e
				})(e, t)
			}

			function i(e, t) {
				e.prototype = Object.create(t.prototype), e.prototype.constructor = e, r(e, t)
			}
			n.d(t, {
				Z: function() {
					return i
				}
			})
		},
		3366: function(e, t, n) {
			"use strict";

			function r(e, t) {
				if (null == e) return {};
				var n, r, i = {},
					s = Object.keys(e);
				for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
				return i
			}
			n.d(t, {
				Z: function() {
					return r
				}
			})
		}
	},
	function(e) {
		var t = function(t) {
			return e(e.s = t)
		};
		e.O(0, [774, 179], (function() {
			return t(9484), t(9831), t(6363), t(387)
		}));
		var n = e.O();
		_N_E = n
	}
]);
//# sourceMappingURL=_app-1c80a5956b1b5e3e.js.map